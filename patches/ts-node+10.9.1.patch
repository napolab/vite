diff --git a/node_modules/ts-node/dist/bin-cwd.js b/node_modules/ts-node/dist/bin-cwd.js
old mode 100755
new mode 100644
diff --git a/node_modules/ts-node/dist/bin-esm.js b/node_modules/ts-node/dist/bin-esm.js
old mode 100755
new mode 100644
diff --git a/node_modules/ts-node/dist/bin-script.js b/node_modules/ts-node/dist/bin-script.js
old mode 100755
new mode 100644
diff --git a/node_modules/ts-node/dist/bin-transpile.js b/node_modules/ts-node/dist/bin-transpile.js
old mode 100755
new mode 100644
diff --git a/node_modules/ts-node/dist/bin.js b/node_modules/ts-node/dist/bin.js
old mode 100755
new mode 100644
diff --git a/node_modules/ts-node/dist/test/ci-node-and-ts-versions.spec.d.ts b/node_modules/ts-node/dist/test/ci-node-and-ts-versions.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/ci-node-and-ts-versions.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/ci-node-and-ts-versions.spec.js b/node_modules/ts-node/dist/test/ci-node-and-ts-versions.spec.js
new file mode 100644
index 0000000..e2a96fb
--- /dev/null
+++ b/node_modules/ts-node/dist/test/ci-node-and-ts-versions.spec.js
@@ -0,0 +1,44 @@
+"use strict";
+// When running on CI, double-check that we are testing against the versions of node
+// and typescript in the test matrix.
+Object.defineProperty(exports, "__esModule", { value: true });
+const child_process_1 = require("child_process");
+const semver = require("semver");
+const helpers_1 = require("./helpers");
+const testlib_1 = require("./testlib");
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+test.suite('Confirm node and typescript versions on CI', (test) => {
+    test.if(!!process.env.CI);
+    test('node version is correct', async (t) => {
+        const expectedVersion = process.env.TEST_MATRIX_NODE_VERSION;
+        const actualVersion = process.versions.node;
+        t.log({ expectedVersion, actualVersion });
+        (0, testlib_1.expect)(expectedVersion).toBeDefined();
+        const major = expectedVersion.match(/^(\d+)-nightly$/)?.[1];
+        if (major != null) {
+            (0, testlib_1.expect)(actualVersion).toMatch(new RegExp('^' + major));
+            (0, testlib_1.expect)(actualVersion).toMatch('-nightly');
+        }
+        else {
+            (0, testlib_1.expect)(semver.satisfies(actualVersion, expectedVersion)).toBe(true);
+        }
+    });
+    test('typescript version is correct', async (t) => {
+        let expectedVersion = process.env.TEST_MATRIX_TYPESCRIPT_VERSION;
+        const actualVersion = helpers_1.ts.version;
+        t.log({ expectedVersion, actualVersion });
+        (0, testlib_1.expect)(expectedVersion).toBeDefined();
+        if (expectedVersion === 'next' || expectedVersion === 'latest') {
+            const stdout = (0, child_process_1.execSync)(`npm view typescript@${expectedVersion} version --json`, {
+                encoding: 'utf8',
+            });
+            t.log({ stdout });
+            expectedVersion = JSON.parse(stdout);
+            (0, testlib_1.expect)(helpers_1.ts.version).toBe(expectedVersion);
+        }
+        else {
+            (0, testlib_1.expect)(semver.satisfies(helpers_1.ts.version, expectedVersion)).toBe(true);
+        }
+    });
+});
+//# sourceMappingURL=ci-node-and-ts-versions.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/ci-node-and-ts-versions.spec.js.map b/node_modules/ts-node/dist/test/ci-node-and-ts-versions.spec.js.map
new file mode 100644
index 0000000..c841c37
--- /dev/null
+++ b/node_modules/ts-node/dist/test/ci-node-and-ts-versions.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ci-node-and-ts-versions.spec.js","sourceRoot":"","sources":["../../src/test/ci-node-and-ts-versions.spec.ts"],"names":[],"mappings":";AAAA,oFAAoF;AACpF,qCAAqC;;AAErC,iDAAyC;AACzC,iCAAkC;AAClC,uCAA0C;AAC1C,uCAA4C;AAE5C,MAAM,IAAI,GAAG,IAAA,iBAAO,EAAC,mBAAS,CAAC,CAAC;AAChC,IAAI,CAAC,KAAK,CAAC,4CAA4C,EAAE,CAAC,IAAI,EAAE,EAAE;IAChE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAC1B,IAAI,CAAC,yBAAyB,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAC1C,MAAM,eAAe,GAAG,OAAO,CAAC,GAAG,CAAC,wBAAyB,CAAC;QAC9D,MAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC;QAC5C,CAAC,CAAC,GAAG,CAAC,EAAE,eAAe,EAAE,aAAa,EAAE,CAAC,CAAC;QAC1C,IAAA,gBAAM,EAAC,eAAe,CAAC,CAAC,WAAW,EAAE,CAAC;QACtC,MAAM,KAAK,GAAG,eAAe,CAAC,KAAK,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAC5D,IAAI,KAAK,IAAI,IAAI,EAAE;YACjB,IAAA,gBAAM,EAAC,aAAa,CAAC,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC;YACvD,IAAA,gBAAM,EAAC,aAAa,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;SAC3C;aAAM;YACL,IAAA,gBAAM,EAAC,MAAM,CAAC,SAAS,CAAC,aAAa,EAAE,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACrE;IACH,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,+BAA+B,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAChD,IAAI,eAAe,GAAG,OAAO,CAAC,GAAG,CAAC,8BAA+B,CAAC;QAClE,MAAM,aAAa,GAAG,YAAE,CAAC,OAAO,CAAC;QACjC,CAAC,CAAC,GAAG,CAAC,EAAE,eAAe,EAAE,aAAa,EAAE,CAAC,CAAC;QAC1C,IAAA,gBAAM,EAAC,eAAe,CAAC,CAAC,WAAW,EAAE,CAAC;QACtC,IAAI,eAAe,KAAK,MAAM,IAAI,eAAe,KAAK,QAAQ,EAAE;YAC9D,MAAM,MAAM,GAAG,IAAA,wBAAQ,EAAC,uBAAuB,eAAe,iBAAiB,EAAE;gBAC/E,QAAQ,EAAE,MAAM;aACjB,CAAC,CAAC;YACH,CAAC,CAAC,GAAG,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC;YAClB,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YACrC,IAAA,gBAAM,EAAC,YAAE,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;SAC1C;aAAM;YACL,IAAA,gBAAM,EAAC,MAAM,CAAC,SAAS,CAAC,YAAE,CAAC,OAAO,EAAE,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAClE;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["// When running on CI, double-check that we are testing against the versions of node\n// and typescript in the test matrix.\n\nimport { execSync } from 'child_process';\nimport semver = require('semver');\nimport { ctxTsNode, ts } from './helpers';\nimport { context, expect } from './testlib';\n\nconst test = context(ctxTsNode);\ntest.suite('Confirm node and typescript versions on CI', (test) => {\n  test.if(!!process.env.CI);\n  test('node version is correct', async (t) => {\n    const expectedVersion = process.env.TEST_MATRIX_NODE_VERSION!;\n    const actualVersion = process.versions.node;\n    t.log({ expectedVersion, actualVersion });\n    expect(expectedVersion).toBeDefined();\n    const major = expectedVersion.match(/^(\\d+)-nightly$/)?.[1];\n    if (major != null) {\n      expect(actualVersion).toMatch(new RegExp('^' + major));\n      expect(actualVersion).toMatch('-nightly');\n    } else {\n      expect(semver.satisfies(actualVersion, expectedVersion)).toBe(true);\n    }\n  });\n  test('typescript version is correct', async (t) => {\n    let expectedVersion = process.env.TEST_MATRIX_TYPESCRIPT_VERSION!;\n    const actualVersion = ts.version;\n    t.log({ expectedVersion, actualVersion });\n    expect(expectedVersion).toBeDefined();\n    if (expectedVersion === 'next' || expectedVersion === 'latest') {\n      const stdout = execSync(`npm view typescript@${expectedVersion} version --json`, {\n        encoding: 'utf8',\n      });\n      t.log({ stdout });\n      expectedVersion = JSON.parse(stdout);\n      expect(ts.version).toBe(expectedVersion);\n    } else {\n      expect(semver.satisfies(ts.version, expectedVersion)).toBe(true);\n    }\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/configuration/resolution.spec.d.ts b/node_modules/ts-node/dist/test/configuration/resolution.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/configuration/resolution.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/configuration/resolution.spec.js b/node_modules/ts-node/dist/test/configuration/resolution.spec.js
new file mode 100644
index 0000000..8abd0b6
--- /dev/null
+++ b/node_modules/ts-node/dist/test/configuration/resolution.spec.js
@@ -0,0 +1,57 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const fs_1 = require("fs");
+const path_1 = require("path");
+const helpers_1 = require("../helpers");
+const testlib_1 = require("../testlib");
+const exec = (0, helpers_1.createExec)({
+    cwd: helpers_1.TEST_DIR,
+});
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+test('should locate tsconfig relative to entry-point by default', async () => {
+    const r = await exec(`${helpers_1.BIN_PATH} ../a/index`, {
+        cwd: (0, path_1.join)(helpers_1.TEST_DIR, 'cwd-and-script-mode/b'),
+    });
+    (0, testlib_1.expect)(r.err).toBe(null);
+    (0, testlib_1.expect)(r.stdout).toMatch(/plugin-a/);
+});
+test('should locate tsconfig relative to entry-point via ts-node-script', async () => {
+    const r = await exec(`${helpers_1.BIN_SCRIPT_PATH} ../a/index`, {
+        cwd: (0, path_1.join)(helpers_1.TEST_DIR, 'cwd-and-script-mode/b'),
+    });
+    (0, testlib_1.expect)(r.err).toBe(null);
+    (0, testlib_1.expect)(r.stdout).toMatch(/plugin-a/);
+});
+test('should locate tsconfig relative to entry-point with --script-mode', async () => {
+    const r = await exec(`${helpers_1.BIN_PATH} --script-mode ../a/index`, {
+        cwd: (0, path_1.join)(helpers_1.TEST_DIR, 'cwd-and-script-mode/b'),
+    });
+    (0, testlib_1.expect)(r.err).toBe(null);
+    (0, testlib_1.expect)(r.stdout).toMatch(/plugin-a/);
+});
+test('should locate tsconfig relative to cwd via ts-node-cwd', async () => {
+    const r = await exec(`${helpers_1.BIN_CWD_PATH} ../a/index`, {
+        cwd: (0, path_1.join)(helpers_1.TEST_DIR, 'cwd-and-script-mode/b'),
+    });
+    (0, testlib_1.expect)(r.err).toBe(null);
+    (0, testlib_1.expect)(r.stdout).toMatch(/plugin-b/);
+});
+test('should locate tsconfig relative to cwd in --cwd-mode', async () => {
+    const r = await exec(`${helpers_1.BIN_PATH} --cwd-mode ../a/index`, {
+        cwd: (0, path_1.join)(helpers_1.TEST_DIR, 'cwd-and-script-mode/b'),
+    });
+    (0, testlib_1.expect)(r.err).toBe(null);
+    (0, testlib_1.expect)(r.stdout).toMatch(/plugin-b/);
+});
+test('should locate tsconfig relative to realpath, not symlink, when entrypoint is a symlink', async (t) => {
+    if ((0, fs_1.lstatSync)((0, path_1.join)(helpers_1.TEST_DIR, 'main-realpath/symlink/symlink.tsx')).isSymbolicLink()) {
+        const r = await exec(`${helpers_1.BIN_PATH} main-realpath/symlink/symlink.tsx`);
+        (0, testlib_1.expect)(r.err).toBe(null);
+        (0, testlib_1.expect)(r.stdout).toBe('');
+    }
+    else {
+        t.log('Skipping');
+        return;
+    }
+});
+//# sourceMappingURL=resolution.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/configuration/resolution.spec.js.map b/node_modules/ts-node/dist/test/configuration/resolution.spec.js.map
new file mode 100644
index 0000000..e89fc7c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/configuration/resolution.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"resolution.spec.js","sourceRoot":"","sources":["../../../src/test/configuration/resolution.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { lstatSync } from 'fs';\nimport { join } from 'path';\nimport { BIN_CWD_PATH, BIN_PATH, BIN_SCRIPT_PATH, createExec, ctxTsNode, TEST_DIR } from '../helpers';\nimport { context, expect } from '../testlib';\n\nconst exec = createExec({\n  cwd: TEST_DIR,\n});\n\nconst test = context(ctxTsNode);\n\ntest('should locate tsconfig relative to entry-point by default', async () => {\n  const r = await exec(`${BIN_PATH} ../a/index`, {\n    cwd: join(TEST_DIR, 'cwd-and-script-mode/b'),\n  });\n  expect(r.err).toBe(null);\n  expect(r.stdout).toMatch(/plugin-a/);\n});\ntest('should locate tsconfig relative to entry-point via ts-node-script', async () => {\n  const r = await exec(`${BIN_SCRIPT_PATH} ../a/index`, {\n    cwd: join(TEST_DIR, 'cwd-and-script-mode/b'),\n  });\n  expect(r.err).toBe(null);\n  expect(r.stdout).toMatch(/plugin-a/);\n});\ntest('should locate tsconfig relative to entry-point with --script-mode', async () => {\n  const r = await exec(`${BIN_PATH} --script-mode ../a/index`, {\n    cwd: join(TEST_DIR, 'cwd-and-script-mode/b'),\n  });\n  expect(r.err).toBe(null);\n  expect(r.stdout).toMatch(/plugin-a/);\n});\ntest('should locate tsconfig relative to cwd via ts-node-cwd', async () => {\n  const r = await exec(`${BIN_CWD_PATH} ../a/index`, {\n    cwd: join(TEST_DIR, 'cwd-and-script-mode/b'),\n  });\n  expect(r.err).toBe(null);\n  expect(r.stdout).toMatch(/plugin-b/);\n});\ntest('should locate tsconfig relative to cwd in --cwd-mode', async () => {\n  const r = await exec(`${BIN_PATH} --cwd-mode ../a/index`, {\n    cwd: join(TEST_DIR, 'cwd-and-script-mode/b'),\n  });\n  expect(r.err).toBe(null);\n  expect(r.stdout).toMatch(/plugin-b/);\n});\ntest('should locate tsconfig relative to realpath, not symlink, when entrypoint is a symlink', async (t) => {\n  if (lstatSync(join(TEST_DIR, 'main-realpath/symlink/symlink.tsx')).isSymbolicLink()) {\n    const r = await exec(`${BIN_PATH} main-realpath/symlink/symlink.tsx`);\n    expect(r.err).toBe(null);\n    expect(r.stdout).toBe('');\n  } else {\n    t.log('Skipping');\n    return;\n  }\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/configuration/tsnode-opts-from-tsconfig.spec.d.ts b/node_modules/ts-node/dist/test/configuration/tsnode-opts-from-tsconfig.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/configuration/tsnode-opts-from-tsconfig.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/configuration/tsnode-opts-from-tsconfig.spec.js b/node_modules/ts-node/dist/test/configuration/tsnode-opts-from-tsconfig.spec.js
new file mode 100644
index 0000000..9ee0cbe
--- /dev/null
+++ b/node_modules/ts-node/dist/test/configuration/tsnode-opts-from-tsconfig.spec.js
@@ -0,0 +1,127 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const paths_1 = require("../helpers/paths");
+const exec_1 = require("../helpers/exec");
+const paths_2 = require("../helpers/paths");
+const testlib_1 = require("../testlib");
+const path_1 = require("path");
+const version_checks_1 = require("../helpers/version-checks");
+const ctx_ts_node_1 = require("../helpers/ctx-ts-node");
+const test = (0, testlib_1.context)(ctx_ts_node_1.ctxTsNode);
+const exec = (0, exec_1.createExec)({
+    cwd: paths_2.TEST_DIR,
+});
+test.suite('should read ts-node options from tsconfig.json', (test) => {
+    const BIN_EXEC = `"${paths_1.BIN_PATH}" --project tsconfig-options/tsconfig.json`;
+    test('should override compiler options from env', async () => {
+        const r = await exec(`${BIN_EXEC} tsconfig-options/log-options1.js`, {
+            env: {
+                ...process.env,
+                TS_NODE_COMPILER_OPTIONS: '{"typeRoots": ["env-typeroots"]}',
+            },
+        });
+        (0, testlib_1.expect)(r.err).toBe(null);
+        const { config } = JSON.parse(r.stdout);
+        (0, testlib_1.expect)(config.options.typeRoots).toEqual([(0, path_1.join)(paths_2.TEST_DIR, './tsconfig-options/env-typeroots').replace(/\\/g, '/')]);
+    });
+    test('should use options from `tsconfig.json`', async () => {
+        const r = await exec(`${BIN_EXEC} tsconfig-options/log-options1.js`);
+        (0, testlib_1.expect)(r.err).toBe(null);
+        const { options, config } = JSON.parse(r.stdout);
+        (0, testlib_1.expect)(config.options.typeRoots).toEqual([
+            (0, path_1.join)(paths_2.TEST_DIR, './tsconfig-options/tsconfig-typeroots').replace(/\\/g, '/'),
+        ]);
+        (0, testlib_1.expect)(config.options.types).toEqual(['tsconfig-tsnode-types']);
+        (0, testlib_1.expect)(options.pretty).toBe(undefined);
+        (0, testlib_1.expect)(options.skipIgnore).toBe(false);
+        (0, testlib_1.expect)(options.transpileOnly).toBe(true);
+        (0, testlib_1.expect)(options.require).toEqual([(0, path_1.join)(paths_2.TEST_DIR, './tsconfig-options/required1.js')]);
+    });
+    test('should ignore empty strings in the array options', async () => {
+        const r = await exec(`${BIN_EXEC} tsconfig-options/log-options1.js`, {
+            env: {
+                ...process.env,
+                TS_NODE_IGNORE: '',
+            },
+        });
+        (0, testlib_1.expect)(r.err).toBe(null);
+        const { options } = JSON.parse(r.stdout);
+        (0, testlib_1.expect)(options.ignore).toEqual([]);
+    });
+    test('should have flags override / merge with `tsconfig.json`', async () => {
+        const r = await exec(`${BIN_EXEC} --skip-ignore --compiler-options "{\\"types\\":[\\"flags-types\\"]}" --require ./tsconfig-options/required2.js tsconfig-options/log-options2.js`);
+        (0, testlib_1.expect)(r.err).toBe(null);
+        const { options, config } = JSON.parse(r.stdout);
+        (0, testlib_1.expect)(config.options.typeRoots).toEqual([
+            (0, path_1.join)(paths_2.TEST_DIR, './tsconfig-options/tsconfig-typeroots').replace(/\\/g, '/'),
+        ]);
+        (0, testlib_1.expect)(config.options.types).toEqual(['flags-types']);
+        (0, testlib_1.expect)(options.pretty).toBe(undefined);
+        (0, testlib_1.expect)(options.skipIgnore).toBe(true);
+        (0, testlib_1.expect)(options.transpileOnly).toBe(true);
+        (0, testlib_1.expect)(options.require).toEqual([
+            (0, path_1.join)(paths_2.TEST_DIR, './tsconfig-options/required1.js'),
+            './tsconfig-options/required2.js',
+        ]);
+    });
+    test('should have `tsconfig.json` override environment', async () => {
+        const r = await exec(`${BIN_EXEC} tsconfig-options/log-options1.js`, {
+            env: {
+                ...process.env,
+                TS_NODE_PRETTY: 'true',
+                TS_NODE_SKIP_IGNORE: 'true',
+            },
+        });
+        (0, testlib_1.expect)(r.err).toBe(null);
+        const { options, config } = JSON.parse(r.stdout);
+        (0, testlib_1.expect)(config.options.typeRoots).toEqual([
+            (0, path_1.join)(paths_2.TEST_DIR, './tsconfig-options/tsconfig-typeroots').replace(/\\/g, '/'),
+        ]);
+        (0, testlib_1.expect)(config.options.types).toEqual(['tsconfig-tsnode-types']);
+        (0, testlib_1.expect)(options.pretty).toBe(true);
+        (0, testlib_1.expect)(options.skipIgnore).toBe(false);
+        (0, testlib_1.expect)(options.transpileOnly).toBe(true);
+        (0, testlib_1.expect)(options.require).toEqual([(0, path_1.join)(paths_2.TEST_DIR, './tsconfig-options/required1.js')]);
+    });
+    test('should pull ts-node options from extended `tsconfig.json`', async () => {
+        const r = await exec(`${paths_1.BIN_PATH} --show-config --project ./tsconfig-extends/tsconfig.json`);
+        (0, testlib_1.expect)(r.err).toBe(null);
+        const config = JSON.parse(r.stdout);
+        (0, testlib_1.expect)(config['ts-node'].require).toEqual([(0, path_1.resolve)(paths_2.TEST_DIR, 'tsconfig-extends/other/require-hook.js')]);
+        (0, testlib_1.expect)(config['ts-node'].scopeDir).toBe((0, path_1.resolve)(paths_2.TEST_DIR, 'tsconfig-extends/other/scopedir'));
+        (0, testlib_1.expect)(config['ts-node'].preferTsExts).toBe(true);
+    });
+    test.suite('should pull ts-node options from extended `tsconfig.json`', (test) => {
+        test.if(version_checks_1.tsSupportsExtendsArray);
+        test('test', async () => {
+            const r = await exec(`${paths_1.BIN_PATH} --show-config --project ./tsconfig-extends-multiple/tsconfig.json`);
+            (0, testlib_1.expect)(r.err).toBe(null);
+            const config = JSON.parse(r.stdout);
+            // root tsconfig extends [a, c]
+            // a extends b
+            // c extends d
+            // https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#supporting-multiple-configuration-files-in-extends
+            // If any fields "conflict", the latter entry wins.
+            // This value comes from c
+            (0, testlib_1.expect)(config.compilerOptions.target).toBe('es2017');
+            // From root
+            (0, testlib_1.expect)(config['ts-node'].preferTsExts).toBe(true);
+            // From a
+            (0, testlib_1.expect)(config['ts-node'].require).toEqual([
+                (0, path_1.resolve)(paths_2.TEST_DIR, 'tsconfig-extends-multiple/a/require-hook-from-a.js'),
+            ]);
+            // From a, overrides declaration in b
+            (0, testlib_1.expect)(config['ts-node'].scopeDir).toBe((0, path_1.resolve)(paths_2.TEST_DIR, 'tsconfig-extends-multiple/a/scopedir-from-a'));
+            // From b
+            const key = process.platform === 'win32' ? 'b\\module-types-from-b' : 'b/module-types-from-b';
+            (0, testlib_1.expect)(config['ts-node'].moduleTypes).toStrictEqual({
+                [key]: 'cjs',
+            });
+            // From c, overrides declaration in b
+            (0, testlib_1.expect)(config['ts-node'].transpiler).toBe('transpiler-from-c');
+            // From d, inherited by c, overrides value from b
+            (0, testlib_1.expect)(config['ts-node'].ignore).toStrictEqual(['ignore-pattern-from-d']);
+        });
+    });
+});
+//# sourceMappingURL=tsnode-opts-from-tsconfig.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/configuration/tsnode-opts-from-tsconfig.spec.js.map b/node_modules/ts-node/dist/test/configuration/tsnode-opts-from-tsconfig.spec.js.map
new file mode 100644
index 0000000..30d938f
--- /dev/null
+++ b/node_modules/ts-node/dist/test/configuration/tsnode-opts-from-tsconfig.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"tsnode-opts-from-tsconfig.spec.js","sourceRoot":"","sources":["../../../src/test/configuration/tsnode-opts-from-tsconfig.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { BIN_PATH } from '../helpers/paths';\nimport { createExec } from '../helpers/exec';\nimport { TEST_DIR } from '../helpers/paths';\nimport { context, expect } from '../testlib';\nimport { join, resolve } from 'path';\nimport { tsSupportsExtendsArray } from '../helpers/version-checks';\nimport { ctxTsNode } from '../helpers/ctx-ts-node';\n\nconst test = context(ctxTsNode);\n\nconst exec = createExec({\n  cwd: TEST_DIR,\n});\n\ntest.suite('should read ts-node options from tsconfig.json', (test) => {\n  const BIN_EXEC = `\"${BIN_PATH}\" --project tsconfig-options/tsconfig.json`;\n\n  test('should override compiler options from env', async () => {\n    const r = await exec(`${BIN_EXEC} tsconfig-options/log-options1.js`, {\n      env: {\n        ...process.env,\n        TS_NODE_COMPILER_OPTIONS: '{\"typeRoots\": [\"env-typeroots\"]}',\n      },\n    });\n    expect(r.err).toBe(null);\n    const { config } = JSON.parse(r.stdout);\n    expect(config.options.typeRoots).toEqual([join(TEST_DIR, './tsconfig-options/env-typeroots').replace(/\\\\/g, '/')]);\n  });\n\n  test('should use options from `tsconfig.json`', async () => {\n    const r = await exec(`${BIN_EXEC} tsconfig-options/log-options1.js`);\n    expect(r.err).toBe(null);\n    const { options, config } = JSON.parse(r.stdout);\n    expect(config.options.typeRoots).toEqual([\n      join(TEST_DIR, './tsconfig-options/tsconfig-typeroots').replace(/\\\\/g, '/'),\n    ]);\n    expect(config.options.types).toEqual(['tsconfig-tsnode-types']);\n    expect(options.pretty).toBe(undefined);\n    expect(options.skipIgnore).toBe(false);\n    expect(options.transpileOnly).toBe(true);\n    expect(options.require).toEqual([join(TEST_DIR, './tsconfig-options/required1.js')]);\n  });\n\n  test('should ignore empty strings in the array options', async () => {\n    const r = await exec(`${BIN_EXEC} tsconfig-options/log-options1.js`, {\n      env: {\n        ...process.env,\n        TS_NODE_IGNORE: '',\n      },\n    });\n    expect(r.err).toBe(null);\n    const { options } = JSON.parse(r.stdout);\n    expect(options.ignore).toEqual([]);\n  });\n\n  test('should have flags override / merge with `tsconfig.json`', async () => {\n    const r = await exec(\n      `${BIN_EXEC} --skip-ignore --compiler-options \"{\\\\\"types\\\\\":[\\\\\"flags-types\\\\\"]}\" --require ./tsconfig-options/required2.js tsconfig-options/log-options2.js`\n    );\n    expect(r.err).toBe(null);\n    const { options, config } = JSON.parse(r.stdout);\n    expect(config.options.typeRoots).toEqual([\n      join(TEST_DIR, './tsconfig-options/tsconfig-typeroots').replace(/\\\\/g, '/'),\n    ]);\n    expect(config.options.types).toEqual(['flags-types']);\n    expect(options.pretty).toBe(undefined);\n    expect(options.skipIgnore).toBe(true);\n    expect(options.transpileOnly).toBe(true);\n    expect(options.require).toEqual([\n      join(TEST_DIR, './tsconfig-options/required1.js'),\n      './tsconfig-options/required2.js',\n    ]);\n  });\n\n  test('should have `tsconfig.json` override environment', async () => {\n    const r = await exec(`${BIN_EXEC} tsconfig-options/log-options1.js`, {\n      env: {\n        ...process.env,\n        TS_NODE_PRETTY: 'true',\n        TS_NODE_SKIP_IGNORE: 'true',\n      },\n    });\n    expect(r.err).toBe(null);\n    const { options, config } = JSON.parse(r.stdout);\n    expect(config.options.typeRoots).toEqual([\n      join(TEST_DIR, './tsconfig-options/tsconfig-typeroots').replace(/\\\\/g, '/'),\n    ]);\n    expect(config.options.types).toEqual(['tsconfig-tsnode-types']);\n    expect(options.pretty).toBe(true);\n    expect(options.skipIgnore).toBe(false);\n    expect(options.transpileOnly).toBe(true);\n    expect(options.require).toEqual([join(TEST_DIR, './tsconfig-options/required1.js')]);\n  });\n\n  test('should pull ts-node options from extended `tsconfig.json`', async () => {\n    const r = await exec(`${BIN_PATH} --show-config --project ./tsconfig-extends/tsconfig.json`);\n    expect(r.err).toBe(null);\n    const config = JSON.parse(r.stdout);\n    expect(config['ts-node'].require).toEqual([resolve(TEST_DIR, 'tsconfig-extends/other/require-hook.js')]);\n    expect(config['ts-node'].scopeDir).toBe(resolve(TEST_DIR, 'tsconfig-extends/other/scopedir'));\n    expect(config['ts-node'].preferTsExts).toBe(true);\n  });\n\n  test.suite('should pull ts-node options from extended `tsconfig.json`', (test) => {\n    test.if(tsSupportsExtendsArray);\n    test('test', async () => {\n      const r = await exec(`${BIN_PATH} --show-config --project ./tsconfig-extends-multiple/tsconfig.json`);\n      expect(r.err).toBe(null);\n      const config = JSON.parse(r.stdout);\n\n      // root tsconfig extends [a, c]\n      // a extends b\n      // c extends d\n\n      // https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#supporting-multiple-configuration-files-in-extends\n      // If any fields \"conflict\", the latter entry wins.\n\n      // This value comes from c\n      expect(config.compilerOptions.target).toBe('es2017');\n\n      // From root\n      expect(config['ts-node'].preferTsExts).toBe(true);\n\n      // From a\n      expect(config['ts-node'].require).toEqual([\n        resolve(TEST_DIR, 'tsconfig-extends-multiple/a/require-hook-from-a.js'),\n      ]);\n\n      // From a, overrides declaration in b\n      expect(config['ts-node'].scopeDir).toBe(resolve(TEST_DIR, 'tsconfig-extends-multiple/a/scopedir-from-a'));\n\n      // From b\n      const key = process.platform === 'win32' ? 'b\\\\module-types-from-b' : 'b/module-types-from-b';\n      expect(config['ts-node'].moduleTypes).toStrictEqual({\n        [key]: 'cjs',\n      });\n\n      // From c, overrides declaration in b\n      expect(config['ts-node'].transpiler).toBe('transpiler-from-c');\n\n      // From d, inherited by c, overrides value from b\n      expect(config['ts-node'].ignore).toStrictEqual(['ignore-pattern-from-d']);\n    });\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/create.spec.d.ts b/node_modules/ts-node/dist/test/create.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/create.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/create.spec.js b/node_modules/ts-node/dist/test/create.spec.js
new file mode 100644
index 0000000..d6f5db4
--- /dev/null
+++ b/node_modules/ts-node/dist/test/create.spec.js
@@ -0,0 +1,34 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const helpers_1 = require("./helpers");
+const testlib_1 = require("./testlib");
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+test.suite('create', ({ contextEach }) => {
+    const test = contextEach(async (t) => {
+        return {
+            service: t.context.tsNodeUnderTest.create({
+                compilerOptions: { target: 'es5' },
+                skipProject: true,
+            }),
+        };
+    });
+    test('should create generic compiler instances', (t) => {
+        const output = t.context.service.compile('const x = 10', 'test.ts');
+        (0, testlib_1.expect)(output).toMatch('var x = 10;');
+    });
+    test.suite('should get type information', (test) => {
+        test('given position of identifier', (t) => {
+            (0, testlib_1.expect)(t.context.service.getTypeInfo('/**jsdoc here*/const x = 10', 'test.ts', 21)).toEqual({
+                comment: 'jsdoc here',
+                name: 'const x: 10',
+            });
+        });
+        test('given position that does not point to an identifier', (t) => {
+            (0, testlib_1.expect)(t.context.service.getTypeInfo('/**jsdoc here*/const x = 10', 'test.ts', 0)).toEqual({
+                comment: '',
+                name: '',
+            });
+        });
+    });
+});
+//# sourceMappingURL=create.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/create.spec.js.map b/node_modules/ts-node/dist/test/create.spec.js.map
new file mode 100644
index 0000000..120d856
--- /dev/null
+++ b/node_modules/ts-node/dist/test/create.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"create.spec.js","sourceRoot":"","sources":["../../src/test/create.spec.ts"],"names":[],"mappings":";;AAAA,uCAAsC;AACtC,uCAA4C;AAE5C,MAAM,IAAI,GAAG,IAAA,iBAAO,EAAC,mBAAS,CAAC,CAAC;AAEhC,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE;IACvC,MAAM,IAAI,GAAG,WAAW,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;QACnC,OAAO;YACL,OAAO,EAAE,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC,MAAM,CAAC;gBACxC,eAAe,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE;gBAClC,WAAW,EAAE,IAAI;aAClB,CAAC;SACH,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,0CAA0C,EAAE,CAAC,CAAC,EAAE,EAAE;QACrD,MAAM,MAAM,GAAG,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,cAAc,EAAE,SAAS,CAAC,CAAC;QACpE,IAAA,gBAAM,EAAC,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,KAAK,CAAC,6BAA6B,EAAE,CAAC,IAAI,EAAE,EAAE;QACjD,IAAI,CAAC,8BAA8B,EAAE,CAAC,CAAC,EAAE,EAAE;YACzC,IAAA,gBAAM,EAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,6BAA6B,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC;gBAC1F,OAAO,EAAE,YAAY;gBACrB,IAAI,EAAE,aAAa;aACpB,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,qDAAqD,EAAE,CAAC,CAAC,EAAE,EAAE;YAChE,IAAA,gBAAM,EAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,6BAA6B,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;gBACzF,OAAO,EAAE,EAAE;gBACX,IAAI,EAAE,EAAE;aACT,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { ctxTsNode } from './helpers';\nimport { context, expect } from './testlib';\n\nconst test = context(ctxTsNode);\n\ntest.suite('create', ({ contextEach }) => {\n  const test = contextEach(async (t) => {\n    return {\n      service: t.context.tsNodeUnderTest.create({\n        compilerOptions: { target: 'es5' },\n        skipProject: true,\n      }),\n    };\n  });\n\n  test('should create generic compiler instances', (t) => {\n    const output = t.context.service.compile('const x = 10', 'test.ts');\n    expect(output).toMatch('var x = 10;');\n  });\n\n  test.suite('should get type information', (test) => {\n    test('given position of identifier', (t) => {\n      expect(t.context.service.getTypeInfo('/**jsdoc here*/const x = 10', 'test.ts', 21)).toEqual({\n        comment: 'jsdoc here',\n        name: 'const x: 10',\n      });\n    });\n    test('given position that does not point to an identifier', (t) => {\n      expect(t.context.service.getTypeInfo('/**jsdoc here*/const x = 10', 'test.ts', 0)).toEqual({\n        comment: '',\n        name: '',\n      });\n    });\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/diagnostics.spec.d.ts b/node_modules/ts-node/dist/test/diagnostics.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/diagnostics.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/diagnostics.spec.js b/node_modules/ts-node/dist/test/diagnostics.spec.js
new file mode 100644
index 0000000..c0a0d96
--- /dev/null
+++ b/node_modules/ts-node/dist/test/diagnostics.spec.js
@@ -0,0 +1,47 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const helpers_1 = require("./helpers");
+const testlib_1 = require("./testlib");
+require("semver");
+require("lodash");
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+test.suite('TSError diagnostics', ({ context }) => {
+    const test = context(async (t) => {
+        // Locking to es2020, because:
+        // 1) es2022 -- default in @tsconfig/bases for node18 -- changes this diagnostic
+        //   to be a composite "No overload matches this call."
+        // 2) TS 4.2 doesn't support es2021 or higher
+        const service = t.context.tsNodeUnderTest.create({
+            compilerOptions: { target: 'es5', lib: ['es2020'] },
+            skipProject: true,
+        });
+        try {
+            service.compile('new Error(123)', 'test.ts');
+        }
+        catch (err) {
+            return { err: err };
+        }
+        return { err: undefined };
+    });
+    const diagnosticCode = 2345;
+    const diagnosticMessage = /Argument of type '.*?' is not assignable to parameter of type 'string( \| undefined)?'./;
+    const diagnosticErrorMessage = /TS2345: Argument of type '.*?' is not assignable to parameter of type 'string( \| undefined)?'./;
+    test('should throw errors', (t) => {
+        const { err } = t.context;
+        (0, testlib_1.expect)(err).toBeDefined();
+        (0, testlib_1.expect)(err).toMatchObject({
+            message: testlib_1.expect.stringMatching(diagnosticErrorMessage),
+            diagnosticText: testlib_1.expect.stringMatching(diagnosticErrorMessage),
+            diagnosticCodes: [diagnosticCode],
+            diagnostics: [
+                {
+                    code: diagnosticCode,
+                    start: 10,
+                    length: 3,
+                    messageText: testlib_1.expect.stringMatching(diagnosticMessage),
+                },
+            ],
+        });
+    });
+});
+//# sourceMappingURL=diagnostics.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/diagnostics.spec.js.map b/node_modules/ts-node/dist/test/diagnostics.spec.js.map
new file mode 100644
index 0000000..697465f
--- /dev/null
+++ b/node_modules/ts-node/dist/test/diagnostics.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"diagnostics.spec.js","sourceRoot":"","sources":["../../src/test/diagnostics.spec.ts"],"names":[],"mappings":";;AACA,uCAA0C;AAC1C,uCAA4C;AAC5C,kBAAiC;AACjC,kBAA8B;AAC9B,MAAM,IAAI,GAAG,IAAA,iBAAO,EAAC,mBAAS,CAAC,CAAC;AAEhC,IAAI,CAAC,KAAK,CAAC,qBAAqB,EAAE,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE;IAChD,MAAM,IAAI,GAAG,OAAO,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;QAC/B,8BAA8B;QAC9B,gFAAgF;QAChF,uDAAuD;QACvD,6CAA6C;QAC7C,MAAM,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC,MAAM,CAAC;YAC/C,eAAe,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,QAAQ,CAAC,EAAE;YACnD,WAAW,EAAE,IAAI;SAClB,CAAC,CAAC;QACH,IAAI;YACF,OAAO,CAAC,OAAO,CAAC,gBAAgB,EAAE,SAAS,CAAC,CAAC;SAC9C;QAAC,OAAO,GAAG,EAAE;YACZ,OAAO,EAAE,GAAG,EAAE,GAAc,EAAE,CAAC;SAChC;QACD,OAAO,EAAE,GAAG,EAAE,SAAS,EAAE,CAAC;IAC5B,CAAC,CAAC,CAAC;IAEH,MAAM,cAAc,GAAG,IAAI,CAAC;IAC5B,MAAM,iBAAiB,GAAG,yFAAyF,CAAC;IACpH,MAAM,sBAAsB,GAC1B,iGAAiG,CAAC;IAEpG,IAAI,CAAC,qBAAqB,EAAE,CAAC,CAAC,EAAE,EAAE;QAChC,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC;QAC1B,IAAA,gBAAM,EAAC,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC;QAC1B,IAAA,gBAAM,EAAC,GAAI,CAAC,CAAC,aAAa,CAAC;YACzB,OAAO,EAAE,gBAAM,CAAC,cAAc,CAAC,sBAAsB,CAAC;YACtD,cAAc,EAAE,gBAAM,CAAC,cAAc,CAAC,sBAAsB,CAAC;YAC7D,eAAe,EAAE,CAAC,cAAc,CAAC;YACjC,WAAW,EAAE;gBACX;oBACE,IAAI,EAAE,cAAc;oBACpB,KAAK,EAAE,EAAE;oBACT,MAAM,EAAE,CAAC;oBACT,WAAW,EAAE,gBAAM,CAAC,cAAc,CAAC,iBAAiB,CAAC;iBACtD;aACF;SACF,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import type { TSError } from '..';\nimport { ctxTsNode, ts } from './helpers';\nimport { context, expect } from './testlib';\nimport * as semver from 'semver';\nimport { once } from 'lodash';\nconst test = context(ctxTsNode);\n\ntest.suite('TSError diagnostics', ({ context }) => {\n  const test = context(async (t) => {\n    // Locking to es2020, because:\n    // 1) es2022 -- default in @tsconfig/bases for node18 -- changes this diagnostic\n    //   to be a composite \"No overload matches this call.\"\n    // 2) TS 4.2 doesn't support es2021 or higher\n    const service = t.context.tsNodeUnderTest.create({\n      compilerOptions: { target: 'es5', lib: ['es2020'] },\n      skipProject: true,\n    });\n    try {\n      service.compile('new Error(123)', 'test.ts');\n    } catch (err) {\n      return { err: err as TSError };\n    }\n    return { err: undefined };\n  });\n\n  const diagnosticCode = 2345;\n  const diagnosticMessage = /Argument of type '.*?' is not assignable to parameter of type 'string( \\| undefined)?'./;\n  const diagnosticErrorMessage =\n    /TS2345: Argument of type '.*?' is not assignable to parameter of type 'string( \\| undefined)?'./;\n\n  test('should throw errors', (t) => {\n    const { err } = t.context;\n    expect(err).toBeDefined();\n    expect(err!).toMatchObject({\n      message: expect.stringMatching(diagnosticErrorMessage),\n      diagnosticText: expect.stringMatching(diagnosticErrorMessage),\n      diagnosticCodes: [diagnosticCode],\n      diagnostics: [\n        {\n          code: diagnosticCode,\n          start: 10,\n          length: 3,\n          messageText: expect.stringMatching(diagnosticMessage),\n        },\n      ],\n    });\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/esm-loader.spec.d.ts b/node_modules/ts-node/dist/test/esm-loader.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/esm-loader.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/esm-loader.spec.js b/node_modules/ts-node/dist/test/esm-loader.spec.js
new file mode 100644
index 0000000..c630549
--- /dev/null
+++ b/node_modules/ts-node/dist/test/esm-loader.spec.js
@@ -0,0 +1,326 @@
+"use strict";
+// ESM loader hook tests
+// TODO: at the time of writing, other ESM loader hook tests have not been moved into this file.
+// Should consolidate them here.
+Object.defineProperty(exports, "__esModule", { value: true });
+const testlib_1 = require("./testlib");
+const semver = require("semver");
+const helpers_1 = require("./helpers");
+const path_1 = require("path");
+const expect = require("expect");
+const url_1 = require("url");
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+const exec = (0, helpers_1.createExec)({
+    cwd: helpers_1.TEST_DIR,
+});
+const spawn = (0, helpers_1.createSpawn)({
+    cwd: helpers_1.TEST_DIR,
+});
+test.suite('esm', (test) => {
+    test('should compile and execute as ESM', async () => {
+        const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} index.ts`, {
+            cwd: (0, path_1.join)(helpers_1.TEST_DIR, './esm'),
+        });
+        expect(r.err).toBe(null);
+        expect(r.stdout).toBe('foo bar baz biff libfoo\n');
+    });
+    test('should use source maps', async (t) => {
+        const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} "throw error.ts"`, {
+            cwd: (0, path_1.join)(helpers_1.TEST_DIR, './esm'),
+        });
+        expect(r.err).not.toBe(null);
+        const expectedModuleUrl = (0, url_1.pathToFileURL)((0, path_1.join)(helpers_1.TEST_DIR, './esm/throw error.ts')).toString();
+        expect(r.err.message).toMatch([
+            `${expectedModuleUrl}:100`,
+            "  bar() { throw new Error('this is a demo'); }",
+            '                ^',
+            'Error: this is a demo',
+            `    at Foo.bar (${expectedModuleUrl}:100:17)`,
+        ].join('\n'));
+    });
+    test.suite('supports experimental-specifier-resolution=node', (test) => {
+        test('via --experimental-specifier-resolution', async () => {
+            const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} --experimental-specifier-resolution=node index.ts`, {
+                cwd: (0, path_1.join)(helpers_1.TEST_DIR, './esm-node-resolver'),
+            });
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('foo bar baz biff libfoo\n');
+        });
+        test('via NODE_OPTIONS', async () => {
+            const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} index.ts`, {
+                cwd: (0, path_1.join)(helpers_1.TEST_DIR, './esm-node-resolver'),
+                env: {
+                    ...process.env,
+                    NODE_OPTIONS: `--experimental-specifier-resolution=node`,
+                },
+            });
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('foo bar baz biff libfoo\n');
+        });
+    });
+    test('throws ERR_REQUIRE_ESM when attempting to require() an ESM script when ESM loader is enabled', async () => {
+        const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} ./index.js`, {
+            cwd: (0, path_1.join)(helpers_1.TEST_DIR, './esm-err-require-esm'),
+        });
+        expect(r.err).not.toBe(null);
+        expect(r.stderr).toMatch('Error [ERR_REQUIRE_ESM]: Must use import to load ES Module:');
+    });
+    test('defers to fallback loaders when URL should not be handled by ts-node', async () => {
+        const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} index.mjs`, {
+            cwd: (0, path_1.join)(helpers_1.TEST_DIR, './esm-import-http-url'),
+        });
+        expect(r.err).not.toBe(null);
+        // expect error from node's default resolver
+        expect(r.stderr).toMatch(/Error \[ERR_UNSUPPORTED_ESM_URL_SCHEME\]:.*(?:\n.*){0,2}\n *at defaultResolve/);
+    });
+    test('should bypass import cache when changing search params', async () => {
+        const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} index.ts`, {
+            cwd: (0, path_1.join)(helpers_1.TEST_DIR, './esm-import-cache'),
+        });
+        expect(r.err).toBe(null);
+        expect(r.stdout).toBe('log1\nlog2\nlog2\n');
+    });
+    test('should support transpile only mode via dedicated loader entrypoint', async () => {
+        const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT}/transpile-only index.ts`, {
+            cwd: (0, path_1.join)(helpers_1.TEST_DIR, './esm-transpile-only'),
+        });
+        expect(r.err).toBe(null);
+        expect(r.stdout).toBe('');
+    });
+    test('should throw type errors without transpile-only enabled', async () => {
+        const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} index.ts`, {
+            cwd: (0, path_1.join)(helpers_1.TEST_DIR, './esm-transpile-only'),
+        });
+        if (r.err === null) {
+            throw new Error('Command was expected to fail, but it succeeded.');
+        }
+        expect(r.err.message).toMatch('Unable to compile TypeScript');
+        expect(r.err.message).toMatch(new RegExp("TS2345: Argument of type '(?:number|1101)' is not assignable to parameter of type 'string'\\."));
+        expect(r.err.message).toMatch(new RegExp("TS2322: Type '(?:\"hello world\"|string)' is not assignable to type 'number'\\."));
+        expect(r.stdout).toBe('');
+    });
+    test.suite('moduleTypes', (test) => {
+        suite('with vanilla ts transpilation', 'tsconfig.json');
+        suite('with third-party-transpiler', 'tsconfig-swc.json');
+        function suite(name, tsconfig) {
+            test.suite(name, (test) => {
+                test('supports CJS webpack.config.ts in an otherwise ESM project', async (t) => {
+                    // A notable case where you can use ts-node's CommonJS loader, not the ESM loader, in an ESM project:
+                    // when loading a webpack.config.ts or similar config
+                    const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --project ./module-types/override-to-cjs/${tsconfig} ./module-types/override-to-cjs/test-webpack-config.cjs`);
+                    expect(r.err).toBe(null);
+                    expect(r.stdout).toBe(``);
+                });
+                test('should allow importing CJS in an otherwise ESM project', async (t) => {
+                    await run('override-to-cjs', tsconfig, 'cjs');
+                    if (semver.gte(process.version, '14.13.1'))
+                        await run('override-to-cjs', tsconfig, 'mjs');
+                });
+                test('should allow importing ESM in an otherwise CJS project', async (t) => {
+                    await run('override-to-esm', tsconfig, 'cjs');
+                    // Node 14.13.0 has a bug(?) where it checks for ESM-only syntax *before* we transform the code.
+                    if (semver.gte(process.version, '14.13.1'))
+                        await run('override-to-esm', tsconfig, 'mjs');
+                });
+            });
+        }
+        async function run(project, config, ext) {
+            const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} ./module-types/${project}/test.${ext}`, {
+                env: {
+                    ...process.env,
+                    TS_NODE_PROJECT: `./module-types/${project}/${config}`,
+                },
+            });
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe(`Failures: 0\n`);
+        }
+    });
+    test.suite('createEsmHooks()', (test) => {
+        test('should create proper hooks with provided instance', async () => {
+            const r = await exec(`node --loader ./loader.mjs index.ts`, {
+                cwd: (0, path_1.join)(helpers_1.TEST_DIR, './esm-custom-loader'),
+            });
+            if (r.err === null) {
+                throw new Error('Command was expected to fail, but it succeeded.');
+            }
+            expect(r.err.message).toMatch(/TS6133:\s+'unusedVar'/);
+        });
+    });
+    test.suite('unit test hooks', ({ contextEach }) => {
+        const test = contextEach(async (t) => {
+            const service = t.context.tsNodeUnderTest.create({
+                cwd: helpers_1.TEST_DIR,
+            });
+            t.teardown(() => {
+                (0, helpers_1.resetNodeEnvironment)();
+            });
+            return {
+                service,
+                hooks: t.context.tsNodeUnderTest.createEsmHooks(service),
+            };
+        });
+        test.suite('data URIs', (test) => {
+            test.if(helpers_1.nodeUsesNewHooksApi);
+            test('Correctly determines format of data URIs', async (t) => {
+                const { hooks } = t.context;
+                const url = 'data:text/javascript,console.log("hello world");';
+                const result = await hooks.load(url, { format: undefined }, async (url, context, _ignored) => {
+                    return { format: context.format, source: '' };
+                });
+                expect(result.format).toBe('module');
+            });
+        });
+    });
+    test.suite('supports import assertions', (test) => {
+        test.if(helpers_1.nodeSupportsImportAssertions && helpers_1.tsSupportsImportAssertions);
+        const macro = test.macro((flags) => async (t) => {
+            const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} ${flags} ./importJson.ts`, {
+                cwd: (0, path_1.resolve)(helpers_1.TEST_DIR, 'esm-import-assertions'),
+            });
+            expect(r.err).toBe(null);
+            expect(r.stdout.trim()).toBe('A fuchsia car has 2 seats and the doors are open.\nDone!');
+        });
+        test.suite('when node does not require --experimental-json-modules', (test) => {
+            test.if(helpers_1.nodeSupportsUnflaggedJsonImports);
+            test('Can import JSON modules with appropriate assertion', macro, '');
+        });
+        test.suite('when node requires --experimental-json-modules', (test) => {
+            test.if(!helpers_1.nodeSupportsUnflaggedJsonImports);
+            test('Can import JSON using the appropriate flag and assertion', macro, '--experimental-json-modules');
+        });
+    });
+    test.suite('Entrypoint resolution falls back to CommonJS resolver and format', (test) => {
+        test('extensionless entrypoint', async (t) => {
+            const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} ./esm-loader-entrypoint-cjs-fallback/extensionless-entrypoint`);
+            expect(r.err).toBe(null);
+            expect(r.stdout.trim()).toBe('Hello world!');
+        });
+        test('relies upon CommonJS resolution', async (t) => {
+            const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} ./esm-loader-entrypoint-cjs-fallback/relies-upon-cjs-resolution`);
+            expect(r.err).toBe(null);
+            expect(r.stdout.trim()).toBe('Hello world!');
+        });
+        test('fails as expected when entrypoint does not exist at all', async (t) => {
+            const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} ./esm-loader-entrypoint-cjs-fallback/does-not-exist`);
+            expect(r.err).toBeDefined();
+            expect(r.stderr).toContain(`Cannot find module `);
+        });
+    });
+    test.suite('spawns child process', async (test) => {
+        basic('ts-node-esm executable', () => exec(`${helpers_1.BIN_ESM_PATH} ./esm-child-process/via-flag/index.ts foo bar`));
+        basic('ts-node --esm flag', () => exec(`${helpers_1.BIN_PATH} --esm ./esm-child-process/via-flag/index.ts foo bar`));
+        basic('ts-node w/tsconfig esm:true', () => exec(`${helpers_1.BIN_PATH} --esm ./esm-child-process/via-tsconfig/index.ts foo bar`));
+        function basic(title, cb) {
+            test(title, async (t) => {
+                const r = await cb();
+                expect(r.err).toBe(null);
+                expect(r.stdout.trim()).toBe('CLI args: foo bar');
+                expect(r.stderr).toBe('');
+            });
+        }
+        test('extensionless entrypoint, regression test for #1943', async (t) => {
+            const r = await exec(`${helpers_1.BIN_ESM_PATH} ./esm-loader-entrypoint-cjs-fallback/extensionless-entrypoint`);
+            expect(r.err).toBe(null);
+            expect(r.stdout.trim()).toBe('Hello world!');
+        });
+        test.suite('parent passes signals to child', (test) => {
+            signalTest('SIGINT');
+            signalTest('SIGTERM');
+            function signalTest(signal) {
+                test(signal, async (t) => {
+                    const childP = spawn([
+                        // exec lets us run the shims on windows; spawn does not
+                        process.execPath,
+                        helpers_1.BIN_PATH_JS,
+                        `./esm-child-process/via-tsconfig/sleep.ts`,
+                    ]);
+                    try {
+                        await childP.stdout.wait('child registered signal handlers');
+                        process.kill(childP.child.pid, signal);
+                        await childP;
+                        const stdout = await childP.stdout;
+                        const stderr = await childP.stderr;
+                        if (process.platform === 'win32') {
+                            // Windows doesn't have signals, and node attempts an imperfect facsimile.
+                            // In Windows, SIGINT and SIGTERM kill the process immediately with exit
+                            // code 1, and the process can't catch or prevent this.
+                            expect(childP.code).toBe(1);
+                            expect(stdout.trim()).toBe(`child registered signal handlers`);
+                        }
+                        else {
+                            expect(childP.code).toBe(123);
+                            expect(stdout.trim()).toBe(`child registered signal handlers\nchild received signal: ${signal}\nchild exiting`);
+                        }
+                        expect(stderr).toBe('');
+                    }
+                    finally {
+                        t.log({
+                            stdout: await childP.stdout,
+                            stderr: await childP.stderr,
+                            code: childP.code,
+                        });
+                    }
+                });
+            }
+        });
+        test.suite('esm child process working directory', (test) => {
+            test('should have the correct working directory in the user entry-point', async () => {
+                const r = await exec(`${helpers_1.BIN_PATH} --esm --cwd ./esm/ index.ts`, {
+                    cwd: (0, path_1.resolve)(helpers_1.TEST_DIR, 'working-dir'),
+                });
+                expect(r.err).toBe(null);
+                expect(r.stdout.trim()).toBe('Passing');
+                expect(r.stderr).toBe('');
+            });
+        });
+        test.suite('esm child process and forking', (test) => {
+            const macro = test.macro((command) => async (t) => {
+                const r = await exec(command);
+                expect(r.err).toBe(null);
+                expect(r.stdout.trim()).toBe('Passing: from main');
+                expect(r.stderr).toBe('');
+            });
+            test('should be able to fork vanilla NodeJS script', macro, `${helpers_1.BIN_PATH} --esm --cwd ./esm-child-process/ ./process-forking-js/index.ts`);
+            test('should be able to fork TypeScript script', macro, `${helpers_1.BIN_PATH} --esm --cwd ./esm-child-process/ ./process-forking-ts/index.ts`);
+            test('should be able to fork TypeScript script by absolute path', macro, `${helpers_1.BIN_PATH} --esm --cwd ./esm-child-process/ ./process-forking-ts-abs/index.ts`);
+        });
+    });
+    test('throws ERR_REQUIRE_ESM when attempting to require() an ESM script when ESM loader is *not* enabled', async () => {
+        // Node versions >= 12 support package.json "type" field and so will throw an error when attempting to load ESM as CJS
+        const r = await exec(`${helpers_1.BIN_PATH} ./index.js`, {
+            cwd: (0, path_1.join)(helpers_1.TEST_DIR, './esm-err-require-esm'),
+        });
+        expect(r.err).not.toBe(null);
+        expect(r.stderr).toMatch('Error [ERR_REQUIRE_ESM]: Must use import to load ES Module:');
+    });
+});
+test.suite("Catch unexpected changes to node's loader context", (test) => {
+    // loader context includes import assertions, therefore this test requires support for import assertions
+    test.if(helpers_1.nodeSupportsImportAssertions);
+    /*
+     * This does not test ts-node.
+     * Rather, it is meant to alert us to potentially breaking changes in node's
+     * loader API.  If node starts returning more or less properties on `context`
+     * objects, we want to know, because it may indicate that our loader code
+     * should be updated to accomodate the new properties, either by proxying them,
+     * modifying them, or suppressing them.
+     */
+    test('Ensure context passed to loader by node has only expected properties', async (t) => {
+        const r = await exec(`node --loader ./esm-loader-context/loader.mjs --experimental-json-modules ./esm-loader-context/index.mjs`);
+        const rows = r.stdout.split('\n').filter((v) => v[0] === '{');
+        expect(rows.length).toBe(14);
+        rows.forEach((row) => {
+            const json = JSON.parse(row);
+            if (json.resolveContextKeys) {
+                expect(json.resolveContextKeys).toEqual(['conditions', 'importAssertions', 'parentURL']);
+            }
+            else if (json.loadContextKeys) {
+                expect(json.loadContextKeys).toEqual(['format', 'importAssertions']);
+            }
+            else {
+                throw new Error('Unexpected stdout in test.');
+            }
+        });
+    });
+});
+//# sourceMappingURL=esm-loader.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/esm-loader.spec.js.map b/node_modules/ts-node/dist/test/esm-loader.spec.js.map
new file mode 100644
index 0000000..5ee4233
--- /dev/null
+++ b/node_modules/ts-node/dist/test/esm-loader.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"esm-loader.spec.js","sourceRoot":"","sources":["../../src/test/esm-loader.spec.ts"],"names":[],"mappings":"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","sourcesContent":["// ESM loader hook tests\n// TODO: at the time of writing, other ESM loader hook tests have not been moved into this file.\n// Should consolidate them here.\n\nimport { context } from './testlib';\nimport semver = require('semver');\nimport {\n  BIN_ESM_PATH,\n  BIN_PATH,\n  BIN_PATH_JS,\n  CMD_ESM_LOADER_WITHOUT_PROJECT,\n  CMD_TS_NODE_WITHOUT_PROJECT_FLAG,\n  ctxTsNode,\n  nodeSupportsImportAssertions,\n  nodeSupportsUnflaggedJsonImports,\n  nodeUsesNewHooksApi,\n  resetNodeEnvironment,\n  TEST_DIR,\n  tsSupportsImportAssertions,\n  createExec,\n  createSpawn,\n  ExecReturn,\n} from './helpers';\nimport { join, resolve } from 'path';\nimport * as expect from 'expect';\nimport type { NodeLoaderHooksAPI2 } from '../';\nimport { pathToFileURL } from 'url';\n\nconst test = context(ctxTsNode);\n\nconst exec = createExec({\n  cwd: TEST_DIR,\n});\nconst spawn = createSpawn({\n  cwd: TEST_DIR,\n});\n\ntest.suite('esm', (test) => {\n  test('should compile and execute as ESM', async () => {\n    const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} index.ts`, {\n      cwd: join(TEST_DIR, './esm'),\n    });\n    expect(r.err).toBe(null);\n    expect(r.stdout).toBe('foo bar baz biff libfoo\\n');\n  });\n  test('should use source maps', async (t) => {\n    const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} \"throw error.ts\"`, {\n      cwd: join(TEST_DIR, './esm'),\n    });\n    expect(r.err).not.toBe(null);\n    const expectedModuleUrl = pathToFileURL(join(TEST_DIR, './esm/throw error.ts')).toString();\n    expect(r.err!.message).toMatch(\n      [\n        `${expectedModuleUrl}:100`,\n        \"  bar() { throw new Error('this is a demo'); }\",\n        '                ^',\n        'Error: this is a demo',\n        `    at Foo.bar (${expectedModuleUrl}:100:17)`,\n      ].join('\\n')\n    );\n  });\n\n  test.suite('supports experimental-specifier-resolution=node', (test) => {\n    test('via --experimental-specifier-resolution', async () => {\n      const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} --experimental-specifier-resolution=node index.ts`, {\n        cwd: join(TEST_DIR, './esm-node-resolver'),\n      });\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('foo bar baz biff libfoo\\n');\n    });\n    test('via NODE_OPTIONS', async () => {\n      const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} index.ts`, {\n        cwd: join(TEST_DIR, './esm-node-resolver'),\n        env: {\n          ...process.env,\n          NODE_OPTIONS: `--experimental-specifier-resolution=node`,\n        },\n      });\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('foo bar baz biff libfoo\\n');\n    });\n  });\n\n  test('throws ERR_REQUIRE_ESM when attempting to require() an ESM script when ESM loader is enabled', async () => {\n    const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} ./index.js`, {\n      cwd: join(TEST_DIR, './esm-err-require-esm'),\n    });\n    expect(r.err).not.toBe(null);\n    expect(r.stderr).toMatch('Error [ERR_REQUIRE_ESM]: Must use import to load ES Module:');\n  });\n\n  test('defers to fallback loaders when URL should not be handled by ts-node', async () => {\n    const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} index.mjs`, {\n      cwd: join(TEST_DIR, './esm-import-http-url'),\n    });\n    expect(r.err).not.toBe(null);\n    // expect error from node's default resolver\n    expect(r.stderr).toMatch(/Error \\[ERR_UNSUPPORTED_ESM_URL_SCHEME\\]:.*(?:\\n.*){0,2}\\n *at defaultResolve/);\n  });\n\n  test('should bypass import cache when changing search params', async () => {\n    const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} index.ts`, {\n      cwd: join(TEST_DIR, './esm-import-cache'),\n    });\n    expect(r.err).toBe(null);\n    expect(r.stdout).toBe('log1\\nlog2\\nlog2\\n');\n  });\n\n  test('should support transpile only mode via dedicated loader entrypoint', async () => {\n    const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT}/transpile-only index.ts`, {\n      cwd: join(TEST_DIR, './esm-transpile-only'),\n    });\n    expect(r.err).toBe(null);\n    expect(r.stdout).toBe('');\n  });\n  test('should throw type errors without transpile-only enabled', async () => {\n    const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} index.ts`, {\n      cwd: join(TEST_DIR, './esm-transpile-only'),\n    });\n    if (r.err === null) {\n      throw new Error('Command was expected to fail, but it succeeded.');\n    }\n\n    expect(r.err.message).toMatch('Unable to compile TypeScript');\n    expect(r.err.message).toMatch(\n      new RegExp(\"TS2345: Argument of type '(?:number|1101)' is not assignable to parameter of type 'string'\\\\.\")\n    );\n    expect(r.err.message).toMatch(\n      new RegExp(\"TS2322: Type '(?:\\\"hello world\\\"|string)' is not assignable to type 'number'\\\\.\")\n    );\n    expect(r.stdout).toBe('');\n  });\n\n  test.suite('moduleTypes', (test) => {\n    suite('with vanilla ts transpilation', 'tsconfig.json');\n    suite('with third-party-transpiler', 'tsconfig-swc.json');\n    function suite(name: string, tsconfig: string) {\n      test.suite(name, (test) => {\n        test('supports CJS webpack.config.ts in an otherwise ESM project', async (t) => {\n          // A notable case where you can use ts-node's CommonJS loader, not the ESM loader, in an ESM project:\n          // when loading a webpack.config.ts or similar config\n          const r = await exec(\n            `${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --project ./module-types/override-to-cjs/${tsconfig} ./module-types/override-to-cjs/test-webpack-config.cjs`\n          );\n          expect(r.err).toBe(null);\n          expect(r.stdout).toBe(``);\n        });\n        test('should allow importing CJS in an otherwise ESM project', async (t) => {\n          await run('override-to-cjs', tsconfig, 'cjs');\n          if (semver.gte(process.version, '14.13.1')) await run('override-to-cjs', tsconfig, 'mjs');\n        });\n        test('should allow importing ESM in an otherwise CJS project', async (t) => {\n          await run('override-to-esm', tsconfig, 'cjs');\n          // Node 14.13.0 has a bug(?) where it checks for ESM-only syntax *before* we transform the code.\n          if (semver.gte(process.version, '14.13.1')) await run('override-to-esm', tsconfig, 'mjs');\n        });\n      });\n    }\n    async function run(project: string, config: string, ext: string) {\n      const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} ./module-types/${project}/test.${ext}`, {\n        env: {\n          ...process.env,\n          TS_NODE_PROJECT: `./module-types/${project}/${config}`,\n        },\n      });\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe(`Failures: 0\\n`);\n    }\n  });\n\n  test.suite('createEsmHooks()', (test) => {\n    test('should create proper hooks with provided instance', async () => {\n      const r = await exec(`node --loader ./loader.mjs index.ts`, {\n        cwd: join(TEST_DIR, './esm-custom-loader'),\n      });\n\n      if (r.err === null) {\n        throw new Error('Command was expected to fail, but it succeeded.');\n      }\n\n      expect(r.err.message).toMatch(/TS6133:\\s+'unusedVar'/);\n    });\n  });\n\n  test.suite('unit test hooks', ({ contextEach }) => {\n    const test = contextEach(async (t) => {\n      const service = t.context.tsNodeUnderTest.create({\n        cwd: TEST_DIR,\n      });\n      t.teardown(() => {\n        resetNodeEnvironment();\n      });\n      return {\n        service,\n        hooks: t.context.tsNodeUnderTest.createEsmHooks(service),\n      };\n    });\n\n    test.suite('data URIs', (test) => {\n      test.if(nodeUsesNewHooksApi);\n\n      test('Correctly determines format of data URIs', async (t) => {\n        const { hooks } = t.context;\n        const url = 'data:text/javascript,console.log(\"hello world\");';\n        const result = await (hooks as NodeLoaderHooksAPI2).load(\n          url,\n          { format: undefined },\n          async (url, context, _ignored) => {\n            return { format: context.format!, source: '' };\n          }\n        );\n        expect(result.format).toBe('module');\n      });\n    });\n  });\n\n  test.suite('supports import assertions', (test) => {\n    test.if(nodeSupportsImportAssertions && tsSupportsImportAssertions);\n\n    const macro = test.macro((flags: string) => async (t) => {\n      const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} ${flags} ./importJson.ts`, {\n        cwd: resolve(TEST_DIR, 'esm-import-assertions'),\n      });\n      expect(r.err).toBe(null);\n      expect(r.stdout.trim()).toBe('A fuchsia car has 2 seats and the doors are open.\\nDone!');\n    });\n\n    test.suite('when node does not require --experimental-json-modules', (test) => {\n      test.if(nodeSupportsUnflaggedJsonImports);\n      test('Can import JSON modules with appropriate assertion', macro, '');\n    });\n    test.suite('when node requires --experimental-json-modules', (test) => {\n      test.if(!nodeSupportsUnflaggedJsonImports);\n      test('Can import JSON using the appropriate flag and assertion', macro, '--experimental-json-modules');\n    });\n  });\n\n  test.suite('Entrypoint resolution falls back to CommonJS resolver and format', (test) => {\n    test('extensionless entrypoint', async (t) => {\n      const r = await exec(\n        `${CMD_ESM_LOADER_WITHOUT_PROJECT} ./esm-loader-entrypoint-cjs-fallback/extensionless-entrypoint`\n      );\n      expect(r.err).toBe(null);\n      expect(r.stdout.trim()).toBe('Hello world!');\n    });\n    test('relies upon CommonJS resolution', async (t) => {\n      const r = await exec(\n        `${CMD_ESM_LOADER_WITHOUT_PROJECT} ./esm-loader-entrypoint-cjs-fallback/relies-upon-cjs-resolution`\n      );\n      expect(r.err).toBe(null);\n      expect(r.stdout.trim()).toBe('Hello world!');\n    });\n    test('fails as expected when entrypoint does not exist at all', async (t) => {\n      const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} ./esm-loader-entrypoint-cjs-fallback/does-not-exist`);\n      expect(r.err).toBeDefined();\n      expect(r.stderr).toContain(`Cannot find module `);\n    });\n  });\n\n  test.suite('spawns child process', async (test) => {\n    basic('ts-node-esm executable', () => exec(`${BIN_ESM_PATH} ./esm-child-process/via-flag/index.ts foo bar`));\n    basic('ts-node --esm flag', () => exec(`${BIN_PATH} --esm ./esm-child-process/via-flag/index.ts foo bar`));\n    basic('ts-node w/tsconfig esm:true', () =>\n      exec(`${BIN_PATH} --esm ./esm-child-process/via-tsconfig/index.ts foo bar`)\n    );\n\n    function basic(title: string, cb: () => ExecReturn) {\n      test(title, async (t) => {\n        const r = await cb();\n        expect(r.err).toBe(null);\n        expect(r.stdout.trim()).toBe('CLI args: foo bar');\n        expect(r.stderr).toBe('');\n      });\n    }\n\n    test('extensionless entrypoint, regression test for #1943', async (t) => {\n      const r = await exec(`${BIN_ESM_PATH} ./esm-loader-entrypoint-cjs-fallback/extensionless-entrypoint`);\n      expect(r.err).toBe(null);\n      expect(r.stdout.trim()).toBe('Hello world!');\n    });\n\n    test.suite('parent passes signals to child', (test) => {\n      signalTest('SIGINT');\n      signalTest('SIGTERM');\n\n      function signalTest(signal: string) {\n        test(signal, async (t) => {\n          const childP = spawn([\n            // exec lets us run the shims on windows; spawn does not\n            process.execPath,\n            BIN_PATH_JS,\n            `./esm-child-process/via-tsconfig/sleep.ts`,\n          ]);\n          try {\n            await childP.stdout.wait('child registered signal handlers');\n            process.kill(childP.child.pid, signal);\n            await childP;\n            const stdout = await childP.stdout;\n            const stderr = await childP.stderr;\n            if (process.platform === 'win32') {\n              // Windows doesn't have signals, and node attempts an imperfect facsimile.\n              // In Windows, SIGINT and SIGTERM kill the process immediately with exit\n              // code 1, and the process can't catch or prevent this.\n              expect(childP.code).toBe(1);\n              expect(stdout.trim()).toBe(`child registered signal handlers`);\n            } else {\n              expect(childP.code).toBe(123);\n              expect(stdout.trim()).toBe(\n                `child registered signal handlers\\nchild received signal: ${signal}\\nchild exiting`\n              );\n            }\n            expect(stderr).toBe('');\n          } finally {\n            t.log({\n              stdout: await childP.stdout,\n              stderr: await childP.stderr,\n              code: childP.code,\n            });\n          }\n        });\n      }\n    });\n\n    test.suite('esm child process working directory', (test) => {\n      test('should have the correct working directory in the user entry-point', async () => {\n        const r = await exec(`${BIN_PATH} --esm --cwd ./esm/ index.ts`, {\n          cwd: resolve(TEST_DIR, 'working-dir'),\n        });\n\n        expect(r.err).toBe(null);\n        expect(r.stdout.trim()).toBe('Passing');\n        expect(r.stderr).toBe('');\n      });\n    });\n\n    test.suite('esm child process and forking', (test) => {\n      const macro = test.macro((command: string) => async (t) => {\n        const r = await exec(command);\n\n        expect(r.err).toBe(null);\n        expect(r.stdout.trim()).toBe('Passing: from main');\n        expect(r.stderr).toBe('');\n      });\n\n      test(\n        'should be able to fork vanilla NodeJS script',\n        macro,\n        `${BIN_PATH} --esm --cwd ./esm-child-process/ ./process-forking-js/index.ts`\n      );\n      test(\n        'should be able to fork TypeScript script',\n        macro,\n        `${BIN_PATH} --esm --cwd ./esm-child-process/ ./process-forking-ts/index.ts`\n      );\n      test(\n        'should be able to fork TypeScript script by absolute path',\n        macro,\n        `${BIN_PATH} --esm --cwd ./esm-child-process/ ./process-forking-ts-abs/index.ts`\n      );\n    });\n  });\n\n  test('throws ERR_REQUIRE_ESM when attempting to require() an ESM script when ESM loader is *not* enabled', async () => {\n    // Node versions >= 12 support package.json \"type\" field and so will throw an error when attempting to load ESM as CJS\n    const r = await exec(`${BIN_PATH} ./index.js`, {\n      cwd: join(TEST_DIR, './esm-err-require-esm'),\n    });\n    expect(r.err).not.toBe(null);\n    expect(r.stderr).toMatch('Error [ERR_REQUIRE_ESM]: Must use import to load ES Module:');\n  });\n});\n\ntest.suite(\"Catch unexpected changes to node's loader context\", (test) => {\n  // loader context includes import assertions, therefore this test requires support for import assertions\n  test.if(nodeSupportsImportAssertions);\n\n  /*\n   * This does not test ts-node.\n   * Rather, it is meant to alert us to potentially breaking changes in node's\n   * loader API.  If node starts returning more or less properties on `context`\n   * objects, we want to know, because it may indicate that our loader code\n   * should be updated to accomodate the new properties, either by proxying them,\n   * modifying them, or suppressing them.\n   */\n  test('Ensure context passed to loader by node has only expected properties', async (t) => {\n    const r = await exec(\n      `node --loader ./esm-loader-context/loader.mjs --experimental-json-modules ./esm-loader-context/index.mjs`\n    );\n    const rows = r.stdout.split('\\n').filter((v) => v[0] === '{');\n    expect(rows.length).toBe(14);\n    rows.forEach((row) => {\n      const json = JSON.parse(row) as {\n        resolveContextKeys?: string[];\n        loadContextKeys?: string[];\n      };\n      if (json.resolveContextKeys) {\n        expect(json.resolveContextKeys).toEqual(['conditions', 'importAssertions', 'parentURL']);\n      } else if (json.loadContextKeys) {\n        expect(json.loadContextKeys).toEqual(['format', 'importAssertions']);\n      } else {\n        throw new Error('Unexpected stdout in test.');\n      }\n    });\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/command-lines.d.ts b/node_modules/ts-node/dist/test/helpers/command-lines.d.ts
new file mode 100644
index 0000000..ee3eae2
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/command-lines.d.ts
@@ -0,0 +1,7 @@
+/** Default `ts-node --project` invocation */
+export declare const CMD_TS_NODE_WITH_PROJECT_FLAG: string;
+/** Default `ts-node --project` invocation with transpile-only */
+export declare const CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG: string;
+/** Default `ts-node` invocation without `--project` */
+export declare const CMD_TS_NODE_WITHOUT_PROJECT_FLAG: string;
+export declare const CMD_ESM_LOADER_WITHOUT_PROJECT = "node --loader ts-node/esm";
diff --git a/node_modules/ts-node/dist/test/helpers/command-lines.js b/node_modules/ts-node/dist/test/helpers/command-lines.js
new file mode 100644
index 0000000..c351723
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/command-lines.js
@@ -0,0 +1,14 @@
+"use strict";
+// Command lines
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.CMD_ESM_LOADER_WITHOUT_PROJECT = exports.CMD_TS_NODE_WITHOUT_PROJECT_FLAG = exports.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG = exports.CMD_TS_NODE_WITH_PROJECT_FLAG = void 0;
+const paths_1 = require("./paths");
+/** Default `ts-node --project` invocation */
+exports.CMD_TS_NODE_WITH_PROJECT_FLAG = `"${paths_1.BIN_PATH}" --project "${paths_1.PROJECT}"`;
+/** Default `ts-node --project` invocation with transpile-only */
+exports.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG = `"${paths_1.BIN_PATH}" --project "${paths_1.PROJECT_TRANSPILE_ONLY}"`;
+/** Default `ts-node` invocation without `--project` */
+exports.CMD_TS_NODE_WITHOUT_PROJECT_FLAG = `"${paths_1.BIN_PATH}"`;
+exports.CMD_ESM_LOADER_WITHOUT_PROJECT = `node --loader ts-node/esm`;
+//#endregion
+//# sourceMappingURL=command-lines.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/command-lines.js.map b/node_modules/ts-node/dist/test/helpers/command-lines.js.map
new file mode 100644
index 0000000..65a6218
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/command-lines.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"command-lines.js","sourceRoot":"","sources":["../../../src/test/helpers/command-lines.ts"],"names":[],"mappings":";AAAA,gBAAgB;;;AAEhB,mCAAoE;AAEpE,6CAA6C;AAChC,QAAA,6BAA6B,GAAG,IAAI,gBAAQ,gBAAgB,eAAO,GAAG,CAAC;AACpF,iEAAiE;AACpD,QAAA,4CAA4C,GAAG,IAAI,gBAAQ,gBAAgB,8BAAsB,GAAG,CAAC;AAClH,uDAAuD;AAC1C,QAAA,gCAAgC,GAAG,IAAI,gBAAQ,GAAG,CAAC;AACnD,QAAA,8BAA8B,GAAG,2BAA2B,CAAC;AAC1E,YAAY","sourcesContent":["// Command lines\n\nimport { BIN_PATH, PROJECT, PROJECT_TRANSPILE_ONLY } from './paths';\n\n/** Default `ts-node --project` invocation */\nexport const CMD_TS_NODE_WITH_PROJECT_FLAG = `\"${BIN_PATH}\" --project \"${PROJECT}\"`;\n/** Default `ts-node --project` invocation with transpile-only */\nexport const CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG = `\"${BIN_PATH}\" --project \"${PROJECT_TRANSPILE_ONLY}\"`;\n/** Default `ts-node` invocation without `--project` */\nexport const CMD_TS_NODE_WITHOUT_PROJECT_FLAG = `\"${BIN_PATH}\"`;\nexport const CMD_ESM_LOADER_WITHOUT_PROJECT = `node --loader ts-node/esm`;\n//#endregion\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/ctx-tmp-dir.d.ts b/node_modules/ts-node/dist/test/helpers/ctx-tmp-dir.d.ts
new file mode 100644
index 0000000..b8b9e71
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/ctx-tmp-dir.d.ts
@@ -0,0 +1,54 @@
+import type { ExecutionContext } from '../testlib';
+/**
+ * This helpers gives you an empty directory in the OS temp directory, *outside*
+ * of the git clone.
+ *
+ * Some tests must run in a directory that is *outside* of the git clone.
+ * When TS and ts-node search for a tsconfig, they traverse up the filesystem.
+ * If they run inside our git clone, they will find the root tsconfig.json, and
+ * we do not always want that.
+ */
+export declare function ctxTmpDirOutsideCheckout(t: ExecutionContext): Promise<{
+    tmpDir: string;
+    fixture: {
+        cwd: string;
+        files: import("@TypeStrong/fs-fixture-builder").File[];
+        dir: (dirPath: string, cb?: ((dir: import("@TypeStrong/fs-fixture-builder").DirectoryApi) => void) | undefined) => import("@TypeStrong/fs-fixture-builder").DirectoryApi;
+        readFrom: (realFsDirPath: string, targetPath?: string | undefined, ignoredPaths?: string[] | undefined) => void;
+        getFile: (path: string) => import("@TypeStrong/fs-fixture-builder").File | undefined;
+        getJsonFile: (path: string) => import("@TypeStrong/fs-fixture-builder").JsonFile<any> | undefined;
+        add: <T extends import("@TypeStrong/fs-fixture-builder").File>(file: T) => T;
+        addFile: (path: string, content?: string | undefined) => import("@TypeStrong/fs-fixture-builder").StringFile;
+        addFiles: (files: Record<string, string | object | null | undefined>) => import("@TypeStrong/fs-fixture-builder").File[];
+        addJsonFile: (path: string, obj: unknown) => import("@TypeStrong/fs-fixture-builder").JsonFile<any>;
+        write: () => void;
+        rm: () => void;
+        copyFilesFrom: (other: any) => any;
+    };
+}>;
+export declare namespace ctxTmpDirOutsideCheckout {
+    type Ctx = Awaited<ReturnType<typeof ctxTmpDirOutsideCheckout>>;
+    type T = ExecutionContext<Ctx>;
+}
+export declare function ctxTmpDir(t: ExecutionContext): Promise<{
+    fixture: {
+        cwd: string;
+        files: import("@TypeStrong/fs-fixture-builder").File[];
+        dir: (dirPath: string, cb?: ((dir: import("@TypeStrong/fs-fixture-builder").DirectoryApi) => void) | undefined) => import("@TypeStrong/fs-fixture-builder").DirectoryApi;
+        readFrom: (realFsDirPath: string, targetPath?: string | undefined, ignoredPaths?: string[] | undefined) => void;
+        getFile: (path: string) => import("@TypeStrong/fs-fixture-builder").File | undefined;
+        getJsonFile: (path: string) => import("@TypeStrong/fs-fixture-builder").JsonFile<any> | undefined;
+        add: <T extends import("@TypeStrong/fs-fixture-builder").File>(file: T) => T;
+        addFile: (path: string, content?: string | undefined) => import("@TypeStrong/fs-fixture-builder").StringFile;
+        addFiles: (files: Record<string, string | object | null | undefined>) => import("@TypeStrong/fs-fixture-builder").File[];
+        addJsonFile: (path: string, obj: unknown) => import("@TypeStrong/fs-fixture-builder").JsonFile<any>;
+        write: () => void;
+        rm: () => void;
+        copyFilesFrom: (other: any) => any;
+    };
+    tmpDir: string;
+}>;
+export declare namespace ctxTmpDir {
+    type Ctx = Awaited<ReturnType<typeof ctxTmpDirOutsideCheckout>>;
+    type T = ExecutionContext<Ctx>;
+}
diff --git a/node_modules/ts-node/dist/test/helpers/ctx-tmp-dir.js b/node_modules/ts-node/dist/test/helpers/ctx-tmp-dir.js
new file mode 100644
index 0000000..f1522ab
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/ctx-tmp-dir.js
@@ -0,0 +1,34 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.ctxTmpDir = exports.ctxTmpDirOutsideCheckout = void 0;
+const os_1 = require("os");
+const fs_fixture_builder_1 = require("@TypeStrong/fs-fixture-builder");
+/**
+ * This helpers gives you an empty directory in the OS temp directory, *outside*
+ * of the git clone.
+ *
+ * Some tests must run in a directory that is *outside* of the git clone.
+ * When TS and ts-node search for a tsconfig, they traverse up the filesystem.
+ * If they run inside our git clone, they will find the root tsconfig.json, and
+ * we do not always want that.
+ */
+async function ctxTmpDirOutsideCheckout(t) {
+    const fixture = (0, fs_fixture_builder_1.tempdirProject)({
+        name: 'ts-node-spec',
+        rootDir: (0, os_1.tmpdir)(),
+    });
+    return {
+        tmpDir: fixture.cwd,
+        fixture,
+    };
+}
+exports.ctxTmpDirOutsideCheckout = ctxTmpDirOutsideCheckout;
+async function ctxTmpDir(t) {
+    const fixture = (0, fs_fixture_builder_1.tempdirProject)('ts-node-spec');
+    return {
+        fixture,
+        tmpDir: fixture.cwd,
+    };
+}
+exports.ctxTmpDir = ctxTmpDir;
+//# sourceMappingURL=ctx-tmp-dir.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/ctx-tmp-dir.js.map b/node_modules/ts-node/dist/test/helpers/ctx-tmp-dir.js.map
new file mode 100644
index 0000000..3145e83
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/ctx-tmp-dir.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ctx-tmp-dir.js","sourceRoot":"","sources":["../../../src/test/helpers/ctx-tmp-dir.ts"],"names":[],"mappings":";;;AAAA,2BAA4B;AAE5B,uEAAgE;AAEhE;;;;;;;;GAQG;AACI,KAAK,UAAU,wBAAwB,CAAC,CAAmB;IAChE,MAAM,OAAO,GAAG,IAAA,mCAAc,EAAC;QAC7B,IAAI,EAAE,cAAc;QACpB,OAAO,EAAE,IAAA,WAAM,GAAE;KAClB,CAAC,CAAC;IACH,OAAO;QACL,MAAM,EAAE,OAAO,CAAC,GAAG;QACnB,OAAO;KACR,CAAC;AACJ,CAAC;AATD,4DASC;AAMM,KAAK,UAAU,SAAS,CAAC,CAAmB;IACjD,MAAM,OAAO,GAAG,IAAA,mCAAc,EAAC,cAAc,CAAC,CAAC;IAC/C,OAAO;QACL,OAAO;QACP,MAAM,EAAE,OAAO,CAAC,GAAG;KACpB,CAAC;AACJ,CAAC;AAND,8BAMC","sourcesContent":["import { tmpdir } from 'os';\nimport type { ExecutionContext } from '../testlib';\nimport { tempdirProject } from '@TypeStrong/fs-fixture-builder';\n\n/**\n * This helpers gives you an empty directory in the OS temp directory, *outside*\n * of the git clone.\n *\n * Some tests must run in a directory that is *outside* of the git clone.\n * When TS and ts-node search for a tsconfig, they traverse up the filesystem.\n * If they run inside our git clone, they will find the root tsconfig.json, and\n * we do not always want that.\n */\nexport async function ctxTmpDirOutsideCheckout(t: ExecutionContext) {\n  const fixture = tempdirProject({\n    name: 'ts-node-spec',\n    rootDir: tmpdir(),\n  });\n  return {\n    tmpDir: fixture.cwd,\n    fixture,\n  };\n}\nexport namespace ctxTmpDirOutsideCheckout {\n  export type Ctx = Awaited<ReturnType<typeof ctxTmpDirOutsideCheckout>>;\n  export type T = ExecutionContext<Ctx>;\n}\n\nexport async function ctxTmpDir(t: ExecutionContext) {\n  const fixture = tempdirProject('ts-node-spec');\n  return {\n    fixture,\n    tmpDir: fixture.cwd,\n  };\n}\nexport namespace ctxTmpDir {\n  export type Ctx = Awaited<ReturnType<typeof ctxTmpDirOutsideCheckout>>;\n  export type T = ExecutionContext<Ctx>;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/ctx-ts-node.d.ts b/node_modules/ts-node/dist/test/helpers/ctx-ts-node.d.ts
new file mode 100644
index 0000000..fc1ae55
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/ctx-ts-node.d.ts
@@ -0,0 +1,15 @@
+import type { ExecutionContext } from '../testlib';
+import { tsNodeTypes } from './misc';
+/** Pass to `test.context()` to get access to the ts-node API under test */
+export declare function ctxTsNode(): Promise<{
+    tsNodeUnderTest: typeof tsNodeTypes;
+}>;
+export declare namespace ctxTsNode {
+    type Ctx = Awaited<ReturnType<typeof ctxTsNode>>;
+    type T = ExecutionContext<Ctx>;
+}
+/**
+ * Pack and install ts-node locally, necessary to test package "exports"
+ * FS locking b/c tests run in separate processes
+ */
+export declare function installTsNode(): Promise<void>;
diff --git a/node_modules/ts-node/dist/test/helpers/ctx-ts-node.js b/node_modules/ts-node/dist/test/helpers/ctx-ts-node.js
new file mode 100644
index 0000000..74d1d1e
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/ctx-ts-node.js
@@ -0,0 +1,91 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.installTsNode = exports.ctxTsNode = void 0;
+const child_process_1 = require("child_process");
+const proper_lockfile_1 = require("proper-lockfile");
+const util_1 = require("util");
+const fs_1 = require("fs");
+const path_1 = require("path");
+const rimraf_1 = require("rimraf");
+const paths_1 = require("./paths");
+const misc_1 = require("./misc");
+/** Pass to `test.context()` to get access to the ts-node API under test */
+async function ctxTsNode() {
+    await installTsNode();
+    const tsNodeUnderTest = (0, misc_1.testsDirRequire)('ts-node');
+    return {
+        tsNodeUnderTest,
+    };
+}
+exports.ctxTsNode = ctxTsNode;
+const ts_node_install_lock = process.env.ts_node_install_lock;
+const lockPath = (0, path_1.join)(__dirname, ts_node_install_lock);
+/**
+ * Pack and install ts-node locally, necessary to test package "exports"
+ * FS locking b/c tests run in separate processes
+ */
+async function installTsNode() {
+    await lockedMemoizedOperation(lockPath, async () => {
+        const totalTries = process.platform === 'win32' ? 5 : 1;
+        let tries = 0;
+        while (true) {
+            try {
+                (0, rimraf_1.sync)((0, path_1.join)(paths_1.TEST_DIR, '.yarn/cache/ts-node-file-*'));
+                (0, fs_1.writeFileSync)((0, path_1.join)(paths_1.TEST_DIR, 'yarn.lock'), '');
+                const result = await (0, util_1.promisify)(child_process_1.exec)(`yarn --no-immutable`, {
+                    cwd: paths_1.TEST_DIR,
+                });
+                // You can uncomment this to aid debugging
+                // console.log(result.stdout, result.stderr);
+                (0, rimraf_1.sync)((0, path_1.join)(paths_1.TEST_DIR, '.yarn/cache/ts-node-file-*'));
+                (0, fs_1.writeFileSync)((0, path_1.join)(paths_1.TEST_DIR, 'yarn.lock'), '');
+                break;
+            }
+            catch (e) {
+                tries++;
+                if (tries >= totalTries)
+                    throw e;
+            }
+        }
+    });
+}
+exports.installTsNode = installTsNode;
+/**
+ * Attempt an operation once across multiple processes, using filesystem locking.
+ * If it was executed already by another process, and it errored, throw the same error message.
+ */
+async function lockedMemoizedOperation(lockPath, operation) {
+    const releaseLock = await (0, proper_lockfile_1.lock)(lockPath, {
+        realpath: false,
+        stale: 120e3,
+        retries: {
+            retries: 120,
+            maxTimeout: 1000,
+        },
+    });
+    try {
+        const operationHappened = (0, fs_1.existsSync)(lockPath);
+        if (operationHappened) {
+            const result = JSON.parse((0, fs_1.readFileSync)(lockPath, 'utf8'));
+            if (result.error)
+                throw result.error;
+        }
+        else {
+            const result = { error: null };
+            try {
+                await operation();
+            }
+            catch (e) {
+                result.error = `${e}`;
+                throw e;
+            }
+            finally {
+                (0, fs_1.writeFileSync)(lockPath, JSON.stringify(result));
+            }
+        }
+    }
+    finally {
+        releaseLock();
+    }
+}
+//# sourceMappingURL=ctx-ts-node.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/ctx-ts-node.js.map b/node_modules/ts-node/dist/test/helpers/ctx-ts-node.js.map
new file mode 100644
index 0000000..83f9887
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/ctx-ts-node.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ctx-ts-node.js","sourceRoot":"","sources":["../../../src/test/helpers/ctx-ts-node.ts"],"names":[],"mappings":"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","sourcesContent":["import { exec as childProcessExec } from 'child_process';\nimport { lock } from 'proper-lockfile';\nimport { promisify } from 'util';\nimport { existsSync, readFileSync, writeFileSync } from 'fs';\nimport { join } from 'path';\nimport type { ExecutionContext } from '../testlib';\nimport { sync as rimrafSync } from 'rimraf';\nimport { TEST_DIR } from './paths';\nimport { testsDirRequire, tsNodeTypes } from './misc';\n\n/** Pass to `test.context()` to get access to the ts-node API under test */\nexport async function ctxTsNode() {\n  await installTsNode();\n  const tsNodeUnderTest: typeof tsNodeTypes = testsDirRequire('ts-node');\n  return {\n    tsNodeUnderTest,\n  };\n}\nexport namespace ctxTsNode {\n  export type Ctx = Awaited<ReturnType<typeof ctxTsNode>>;\n  export type T = ExecutionContext<Ctx>;\n}\n\nconst ts_node_install_lock = process.env.ts_node_install_lock as string;\nconst lockPath = join(__dirname, ts_node_install_lock);\n\ninterface InstallationResult {\n  error: string | null;\n}\n\n/**\n * Pack and install ts-node locally, necessary to test package \"exports\"\n * FS locking b/c tests run in separate processes\n */\nexport async function installTsNode() {\n  await lockedMemoizedOperation(lockPath, async () => {\n    const totalTries = process.platform === 'win32' ? 5 : 1;\n    let tries = 0;\n    while (true) {\n      try {\n        rimrafSync(join(TEST_DIR, '.yarn/cache/ts-node-file-*'));\n        writeFileSync(join(TEST_DIR, 'yarn.lock'), '');\n        const result = await promisify(childProcessExec)(`yarn --no-immutable`, {\n          cwd: TEST_DIR,\n        });\n        // You can uncomment this to aid debugging\n        // console.log(result.stdout, result.stderr);\n        rimrafSync(join(TEST_DIR, '.yarn/cache/ts-node-file-*'));\n        writeFileSync(join(TEST_DIR, 'yarn.lock'), '');\n        break;\n      } catch (e) {\n        tries++;\n        if (tries >= totalTries) throw e;\n      }\n    }\n  });\n}\n\n/**\n * Attempt an operation once across multiple processes, using filesystem locking.\n * If it was executed already by another process, and it errored, throw the same error message.\n */\nasync function lockedMemoizedOperation(lockPath: string, operation: () => Promise<void>) {\n  const releaseLock = await lock(lockPath, {\n    realpath: false,\n    stale: 120e3,\n    retries: {\n      retries: 120,\n      maxTimeout: 1000,\n    },\n  });\n  try {\n    const operationHappened = existsSync(lockPath);\n    if (operationHappened) {\n      const result: InstallationResult = JSON.parse(readFileSync(lockPath, 'utf8'));\n      if (result.error) throw result.error;\n    } else {\n      const result: InstallationResult = { error: null };\n      try {\n        await operation();\n      } catch (e) {\n        result.error = `${e}`;\n        throw e;\n      } finally {\n        writeFileSync(lockPath, JSON.stringify(result));\n      }\n    }\n  } finally {\n    releaseLock();\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/exec.d.ts b/node_modules/ts-node/dist/test/helpers/exec.d.ts
new file mode 100644
index 0000000..7f6ce20
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/exec.d.ts
@@ -0,0 +1,36 @@
+/// <reference types="node" />
+import type { ChildProcess, ExecException, ExecOptions, SpawnOptions } from 'child_process';
+import { ExpectStream } from '@cspotcode/expect-stream';
+export declare type ExecReturn = Promise<ExecResult> & {
+    child: ChildProcess;
+};
+export interface ExecResult {
+    stdout: string;
+    stderr: string;
+    err: null | ExecException;
+    child: ChildProcess;
+}
+export declare function createExec<T extends Partial<ExecOptions>>(preBoundOptions?: T): (cmd: string, opts?: Pick<ExecOptions, Exclude<keyof ExecOptions, keyof T>> & Partial<Pick<ExecOptions, keyof T & keyof ExecOptions>>) => ExecReturn;
+export declare type SpawnReturn = Promise<SpawnResult> & SpawnResult;
+export interface SpawnResult {
+    stdout: ExpectStream;
+    stderr: ExpectStream;
+    code: number | null;
+    child: ChildProcess;
+}
+export declare function createSpawn<T extends Partial<SpawnOptions>>(preBoundOptions?: T): (cmd: string[], opts?: Pick<SpawnOptions, Exclude<keyof SpawnOptions, keyof T>> & Partial<Pick<SpawnOptions, keyof T & keyof SpawnOptions>>) => SpawnReturn;
+declare const defaultExec: (cmd: string, opts?: (Pick<ExecOptions, never> & Partial<Pick<ExecOptions, keyof ExecOptions>>) | undefined) => ExecReturn;
+export { defaultExec as exec };
+export interface ExecTesterOptions {
+    cmd: string;
+    flags?: string;
+    env?: Record<string, string>;
+    stdin?: string;
+    expectError?: boolean;
+    exec?: typeof defaultExec;
+}
+/**
+ * Create a function that launches a CLI command, optionally pipes stdin, optionally sets env vars,
+ * optionally runs a couple baked-in assertions, and returns the results for additional assertions.
+ */
+export declare function createExecTester<T extends Partial<ExecTesterOptions>>(preBoundOptions: T): (options: Pick<ExecTesterOptions, Exclude<keyof ExecTesterOptions, keyof T>> & Partial<Pick<ExecTesterOptions, keyof T & keyof ExecTesterOptions>>) => Promise<ExecResult>;
diff --git a/node_modules/ts-node/dist/test/helpers/exec.js b/node_modules/ts-node/dist/test/helpers/exec.js
new file mode 100644
index 0000000..88d674c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/exec.js
@@ -0,0 +1,93 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.createExecTester = exports.exec = exports.createSpawn = exports.createExec = void 0;
+const child_process_1 = require("child_process");
+const expect_stream_1 = require("@cspotcode/expect-stream");
+const testlib_1 = require("../testlib");
+function createExec(preBoundOptions) {
+    /**
+     * Helper to exec a child process.
+     * Returns a Promise and a reference to the child process to suite multiple situations.
+     * Promise resolves with the process's stdout, stderr, and error.
+     */
+    return function exec(cmd, opts) {
+        let child;
+        return Object.assign(new Promise((resolve, reject) => {
+            child = (0, child_process_1.exec)(cmd, {
+                ...preBoundOptions,
+                ...opts,
+            }, (err, stdout, stderr) => {
+                resolve({ err, stdout, stderr, child });
+            });
+        }), {
+            child,
+        });
+    };
+}
+exports.createExec = createExec;
+function createSpawn(preBoundOptions) {
+    /**
+     * Helper to spawn a child process.
+     * Returns a Promise and a reference to the child process to suite multiple situations.
+     *
+     * Should almost always avoid this helper, and instead use `createExec` / `exec`.  `spawn`
+     * may be necessary if you need to avoid `exec`'s intermediate shell.
+     */
+    return function spawn(cmd, opts) {
+        let child;
+        let stdout;
+        let stderr;
+        const promise = Object.assign(new Promise((resolve, reject) => {
+            child = (0, child_process_1.spawn)(cmd[0], cmd.slice(1), {
+                ...preBoundOptions,
+                ...opts,
+            });
+            stdout = (0, expect_stream_1.expectStream)(child.stdout);
+            stderr = (0, expect_stream_1.expectStream)(child.stderr);
+            child.on('exit', (code) => {
+                promise.code = code;
+                resolve({ stdout, stderr, code, child });
+            });
+            child.on('error', (error) => {
+                reject(error);
+            });
+        }), {
+            child,
+            stdout,
+            stderr,
+            code: null,
+        });
+        return promise;
+    };
+}
+exports.createSpawn = createSpawn;
+const defaultExec = createExec();
+exports.exec = defaultExec;
+/**
+ * Create a function that launches a CLI command, optionally pipes stdin, optionally sets env vars,
+ * optionally runs a couple baked-in assertions, and returns the results for additional assertions.
+ */
+function createExecTester(preBoundOptions) {
+    return async function (options) {
+        const { cmd, flags = '', stdin, expectError = false, env, exec = defaultExec, } = {
+            ...preBoundOptions,
+            ...options,
+        };
+        const p = exec(`${cmd} ${flags}`, {
+            env: { ...process.env, ...env },
+        });
+        if (stdin !== undefined) {
+            p.child.stdin.end(stdin);
+        }
+        const r = await p;
+        if (expectError) {
+            (0, testlib_1.expect)(r.err).toBeDefined();
+        }
+        else {
+            (0, testlib_1.expect)(r.err).toBeNull();
+        }
+        return r;
+    };
+}
+exports.createExecTester = createExecTester;
+//# sourceMappingURL=exec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/exec.js.map b/node_modules/ts-node/dist/test/helpers/exec.js.map
new file mode 100644
index 0000000..d516005
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/exec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"exec.js","sourceRoot":"","sources":["../../../src/test/helpers/exec.ts"],"names":[],"mappings":";;;AACA,iDAAqF;AACrF,4DAAsE;AACtE,wCAAoC;AAUpC,SAAgB,UAAU,CAAiC,eAAmB;IAC5E;;;;OAIG;IACH,OAAO,SAAS,IAAI,CAClB,GAAW,EACX,IACyD;QAEzD,IAAI,KAAoB,CAAC;QACzB,OAAO,MAAM,CAAC,MAAM,CAClB,IAAI,OAAO,CAAa,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAC1C,KAAK,GAAG,IAAA,oBAAgB,EACtB,GAAG,EACH;gBACE,GAAG,eAAe;gBAClB,GAAG,IAAI;aACR,EACD,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,EAAE;gBACtB,OAAO,CAAC,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;YAC1C,CAAC,CACF,CAAC;QACJ,CAAC,CAAC,EACF;YACE,KAAK;SACN,CACF,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC;AA9BD,gCA8BC;AAUD,SAAgB,WAAW,CAAkC,eAAmB;IAC9E;;;;;;OAMG;IACH,OAAO,SAAS,KAAK,CACnB,GAAa,EACb,IAC2D;QAE3D,IAAI,KAAoB,CAAC;QACzB,IAAI,MAAqB,CAAC;QAC1B,IAAI,MAAqB,CAAC;QAC1B,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAC3B,IAAI,OAAO,CAAc,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAC3C,KAAK,GAAG,IAAA,qBAAiB,EAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;gBAC9C,GAAG,eAAe;gBAClB,GAAG,IAAI;aACR,CAAC,CAAC;YACH,MAAM,GAAG,IAAA,4BAAY,EAAC,KAAK,CAAC,MAAO,CAAC,CAAC;YACrC,MAAM,GAAG,IAAA,4BAAY,EAAC,KAAK,CAAC,MAAO,CAAC,CAAC;YACrC,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE;gBACxB,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC;gBACpB,OAAO,CAAC,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;YAC3C,CAAC,CAAC,CAAC;YACH,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAK,EAAE,EAAE;gBAC1B,MAAM,CAAC,KAAK,CAAC,CAAC;YAChB,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,EACF;YACE,KAAK;YACL,MAAM;YACN,MAAM;YACN,IAAI,EAAE,IAAqB;SAC5B,CACF,CAAC;QACF,OAAO,OAAO,CAAC;IACjB,CAAC,CAAC;AACJ,CAAC;AAzCD,kCAyCC;AAED,MAAM,WAAW,GAAG,UAAU,EAAE,CAAC;AACT,2BAAI;AAW5B;;;GAGG;AACH,SAAgB,gBAAgB,CAAuC,eAAkB;IACvF,OAAO,KAAK,WACV,OACqE;QAErE,MAAM,EACJ,GAAG,EACH,KAAK,GAAG,EAAE,EACV,KAAK,EACL,WAAW,GAAG,KAAK,EACnB,GAAG,EACH,IAAI,GAAG,WAAW,GACnB,GAAG;YACF,GAAG,eAAe;YAClB,GAAG,OAAO;SACX,CAAC;QACF,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,KAAK,EAAE,EAAE;YAChC,GAAG,EAAE,EAAE,GAAG,OAAO,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE;SAChC,CAAC,CAAC;QACH,IAAI,KAAK,KAAK,SAAS,EAAE;YACvB,CAAC,CAAC,KAAK,CAAC,KAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;SAC3B;QACD,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;QAClB,IAAI,WAAW,EAAE;YACf,IAAA,gBAAM,EAAC,CAAC,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC;SAC7B;aAAM;YACL,IAAA,gBAAM,EAAC,CAAC,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC;SAC1B;QACD,OAAO,CAAC,CAAC;IACX,CAAC,CAAC;AACJ,CAAC;AA9BD,4CA8BC","sourcesContent":["import type { ChildProcess, ExecException, ExecOptions, SpawnOptions } from 'child_process';\nimport { exec as childProcessExec, spawn as childProcessSpawn } from 'child_process';\nimport { ExpectStream, expectStream } from '@cspotcode/expect-stream';\nimport { expect } from '../testlib';\n\nexport type ExecReturn = Promise<ExecResult> & { child: ChildProcess };\nexport interface ExecResult {\n  stdout: string;\n  stderr: string;\n  err: null | ExecException;\n  child: ChildProcess;\n}\n\nexport function createExec<T extends Partial<ExecOptions>>(preBoundOptions?: T) {\n  /**\n   * Helper to exec a child process.\n   * Returns a Promise and a reference to the child process to suite multiple situations.\n   * Promise resolves with the process's stdout, stderr, and error.\n   */\n  return function exec(\n    cmd: string,\n    opts?: Pick<ExecOptions, Exclude<keyof ExecOptions, keyof T>> &\n      Partial<Pick<ExecOptions, keyof T & keyof ExecOptions>>\n  ): ExecReturn {\n    let child!: ChildProcess;\n    return Object.assign(\n      new Promise<ExecResult>((resolve, reject) => {\n        child = childProcessExec(\n          cmd,\n          {\n            ...preBoundOptions,\n            ...opts,\n          },\n          (err, stdout, stderr) => {\n            resolve({ err, stdout, stderr, child });\n          }\n        );\n      }),\n      {\n        child,\n      }\n    );\n  };\n}\n\nexport type SpawnReturn = Promise<SpawnResult> & SpawnResult;\nexport interface SpawnResult {\n  stdout: ExpectStream;\n  stderr: ExpectStream;\n  code: number | null;\n  child: ChildProcess;\n}\n\nexport function createSpawn<T extends Partial<SpawnOptions>>(preBoundOptions?: T) {\n  /**\n   * Helper to spawn a child process.\n   * Returns a Promise and a reference to the child process to suite multiple situations.\n   *\n   * Should almost always avoid this helper, and instead use `createExec` / `exec`.  `spawn`\n   * may be necessary if you need to avoid `exec`'s intermediate shell.\n   */\n  return function spawn(\n    cmd: string[],\n    opts?: Pick<SpawnOptions, Exclude<keyof SpawnOptions, keyof T>> &\n      Partial<Pick<SpawnOptions, keyof T & keyof SpawnOptions>>\n  ): SpawnReturn {\n    let child!: ChildProcess;\n    let stdout!: ExpectStream;\n    let stderr!: ExpectStream;\n    const promise = Object.assign(\n      new Promise<SpawnResult>((resolve, reject) => {\n        child = childProcessSpawn(cmd[0], cmd.slice(1), {\n          ...preBoundOptions,\n          ...opts,\n        });\n        stdout = expectStream(child.stdout!);\n        stderr = expectStream(child.stderr!);\n        child.on('exit', (code) => {\n          promise.code = code;\n          resolve({ stdout, stderr, code, child });\n        });\n        child.on('error', (error) => {\n          reject(error);\n        });\n      }),\n      {\n        child,\n        stdout,\n        stderr,\n        code: null as number | null,\n      }\n    );\n    return promise;\n  };\n}\n\nconst defaultExec = createExec();\nexport { defaultExec as exec };\n\nexport interface ExecTesterOptions {\n  cmd: string;\n  flags?: string;\n  env?: Record<string, string>;\n  stdin?: string;\n  expectError?: boolean;\n  exec?: typeof defaultExec;\n}\n\n/**\n * Create a function that launches a CLI command, optionally pipes stdin, optionally sets env vars,\n * optionally runs a couple baked-in assertions, and returns the results for additional assertions.\n */\nexport function createExecTester<T extends Partial<ExecTesterOptions>>(preBoundOptions: T) {\n  return async function (\n    options: Pick<ExecTesterOptions, Exclude<keyof ExecTesterOptions, keyof T>> &\n      Partial<Pick<ExecTesterOptions, keyof T & keyof ExecTesterOptions>>\n  ) {\n    const {\n      cmd,\n      flags = '',\n      stdin,\n      expectError = false,\n      env,\n      exec = defaultExec,\n    } = {\n      ...preBoundOptions,\n      ...options,\n    };\n    const p = exec(`${cmd} ${flags}`, {\n      env: { ...process.env, ...env },\n    });\n    if (stdin !== undefined) {\n      p.child.stdin!.end(stdin);\n    }\n    const r = await p;\n    if (expectError) {\n      expect(r.err).toBeDefined();\n    } else {\n      expect(r.err).toBeNull();\n    }\n    return r;\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/index.d.ts b/node_modules/ts-node/dist/test/helpers/index.d.ts
new file mode 100644
index 0000000..c34a5cf
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/index.d.ts
@@ -0,0 +1,8 @@
+export * from './misc';
+export * from './ctx-tmp-dir';
+export * from './ctx-ts-node';
+export * from './paths';
+export * from './command-lines';
+export * from './reset-node-environment';
+export * from './version-checks';
+export * from './exec';
diff --git a/node_modules/ts-node/dist/test/helpers/index.js b/node_modules/ts-node/dist/test/helpers/index.js
new file mode 100644
index 0000000..6644375
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/index.js
@@ -0,0 +1,25 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __exportStar = (this && this.__exportStar) || function(m, exports) {
+    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+__exportStar(require("./misc"), exports);
+__exportStar(require("./ctx-tmp-dir"), exports);
+__exportStar(require("./ctx-ts-node"), exports);
+__exportStar(require("./paths"), exports);
+__exportStar(require("./command-lines"), exports);
+__exportStar(require("./reset-node-environment"), exports);
+__exportStar(require("./version-checks"), exports);
+__exportStar(require("./exec"), exports);
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/index.js.map b/node_modules/ts-node/dist/test/helpers/index.js.map
new file mode 100644
index 0000000..93fa58c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/test/helpers/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,yCAAuB;AACvB,gDAA8B;AAC9B,gDAA8B;AAC9B,0CAAwB;AACxB,kDAAgC;AAChC,2DAAyC;AACzC,mDAAiC;AACjC,yCAAuB","sourcesContent":["export * from './misc';\nexport * from './ctx-tmp-dir';\nexport * from './ctx-ts-node';\nexport * from './paths';\nexport * from './command-lines';\nexport * from './reset-node-environment';\nexport * from './version-checks';\nexport * from './exec';\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/misc.d.ts b/node_modules/ts-node/dist/test/helpers/misc.d.ts
new file mode 100644
index 0000000..b0f481b
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/misc.d.ts
@@ -0,0 +1,9 @@
+/// <reference types="node" />
+/** types from ts-node under test */
+import type * as tsNodeTypes from '../../index';
+export { tsNodeTypes };
+export declare const testsDirRequire: NodeRequire;
+export declare const ts: typeof import("typescript");
+export declare const delay: typeof setTimeout.__promisify__;
+/** Essentially Array:includes, but with tweaked types for checks on enums */
+export declare function isOneOf<V>(value: V, arrayOfPossibilities: ReadonlyArray<V>): boolean;
diff --git a/node_modules/ts-node/dist/test/helpers/misc.js b/node_modules/ts-node/dist/test/helpers/misc.js
new file mode 100644
index 0000000..7525859
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/misc.js
@@ -0,0 +1,16 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.isOneOf = exports.delay = exports.ts = exports.testsDirRequire = void 0;
+const paths_1 = require("./paths");
+const path_1 = require("path");
+const util_1 = require("util");
+const module_1 = require("module");
+exports.testsDirRequire = (0, module_1.createRequire)((0, path_1.join)(paths_1.TEST_DIR, 'index.js'));
+exports.ts = (0, exports.testsDirRequire)('typescript');
+exports.delay = (0, util_1.promisify)(setTimeout);
+/** Essentially Array:includes, but with tweaked types for checks on enums */
+function isOneOf(value, arrayOfPossibilities) {
+    return arrayOfPossibilities.includes(value);
+}
+exports.isOneOf = isOneOf;
+//# sourceMappingURL=misc.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/misc.js.map b/node_modules/ts-node/dist/test/helpers/misc.js.map
new file mode 100644
index 0000000..f810b58
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/misc.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"misc.js","sourceRoot":"","sources":["../../../src/test/helpers/misc.ts"],"names":[],"mappings":";;;AAEA,mCAAmC;AACnC,+BAA4B;AAC5B,+BAAiC;AACjC,mCAAuC;AAG1B,QAAA,eAAe,GAAG,IAAA,sBAAa,EAAC,IAAA,WAAI,EAAC,gBAAQ,EAAE,UAAU,CAAC,CAAC,CAAC;AAE5D,QAAA,EAAE,GAAG,IAAA,uBAAe,EAAC,YAAY,CAAgC,CAAC;AAElE,QAAA,KAAK,GAAG,IAAA,gBAAS,EAAC,UAAU,CAAC,CAAC;AAE3C,6EAA6E;AAC7E,SAAgB,OAAO,CAAI,KAAQ,EAAE,oBAAsC;IACzE,OAAO,oBAAoB,CAAC,QAAQ,CAAC,KAAY,CAAC,CAAC;AACrD,CAAC;AAFD,0BAEC","sourcesContent":["/** types from ts-node under test */\nimport type * as tsNodeTypes from '../../index';\nimport { TEST_DIR } from './paths';\nimport { join } from 'path';\nimport { promisify } from 'util';\nimport { createRequire } from 'module';\nexport { tsNodeTypes };\n\nexport const testsDirRequire = createRequire(join(TEST_DIR, 'index.js'));\n\nexport const ts = testsDirRequire('typescript') as typeof import('typescript');\n\nexport const delay = promisify(setTimeout);\n\n/** Essentially Array:includes, but with tweaked types for checks on enums */\nexport function isOneOf<V>(value: V, arrayOfPossibilities: ReadonlyArray<V>) {\n  return arrayOfPossibilities.includes(value as any);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/paths.d.ts b/node_modules/ts-node/dist/test/helpers/paths.d.ts
new file mode 100644
index 0000000..7218dd1
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/paths.d.ts
@@ -0,0 +1,10 @@
+export declare const ROOT_DIR: string;
+export declare const DIST_DIR: string;
+export declare const TEST_DIR: string;
+export declare const PROJECT: string;
+export declare const PROJECT_TRANSPILE_ONLY: string;
+export declare const BIN_PATH: string;
+export declare const BIN_PATH_JS: string;
+export declare const BIN_SCRIPT_PATH: string;
+export declare const BIN_CWD_PATH: string;
+export declare const BIN_ESM_PATH: string;
diff --git a/node_modules/ts-node/dist/test/helpers/paths.js b/node_modules/ts-node/dist/test/helpers/paths.js
new file mode 100644
index 0000000..5e5fe96
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/paths.js
@@ -0,0 +1,20 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.BIN_ESM_PATH = exports.BIN_CWD_PATH = exports.BIN_SCRIPT_PATH = exports.BIN_PATH_JS = exports.BIN_PATH = exports.PROJECT_TRANSPILE_ONLY = exports.PROJECT = exports.TEST_DIR = exports.DIST_DIR = exports.ROOT_DIR = void 0;
+const fs_fixture_builder_1 = require("@TypeStrong/fs-fixture-builder");
+const path_1 = require("path");
+//#region Paths
+exports.ROOT_DIR = (0, path_1.resolve)(__dirname, '../../..');
+exports.DIST_DIR = (0, path_1.resolve)(__dirname, '../..');
+exports.TEST_DIR = (0, path_1.join)(__dirname, '../../../tests');
+exports.PROJECT = (0, path_1.join)(exports.TEST_DIR, 'tsconfig.json');
+exports.PROJECT_TRANSPILE_ONLY = (0, path_1.join)(exports.TEST_DIR, 'tsconfig-transpile-only.json');
+exports.BIN_PATH = (0, path_1.join)(exports.TEST_DIR, 'node_modules/.bin/ts-node');
+exports.BIN_PATH_JS = (0, path_1.join)(exports.TEST_DIR, 'node_modules/ts-node/dist/bin.js');
+exports.BIN_SCRIPT_PATH = (0, path_1.join)(exports.TEST_DIR, 'node_modules/.bin/ts-node-script');
+exports.BIN_CWD_PATH = (0, path_1.join)(exports.TEST_DIR, 'node_modules/.bin/ts-node-cwd');
+exports.BIN_ESM_PATH = (0, path_1.join)(exports.TEST_DIR, 'node_modules/.bin/ts-node-esm');
+process.chdir(exports.TEST_DIR);
+(0, fs_fixture_builder_1.setFixturesRootDir)(exports.TEST_DIR);
+//#endregion
+//# sourceMappingURL=paths.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/paths.js.map b/node_modules/ts-node/dist/test/helpers/paths.js.map
new file mode 100644
index 0000000..1b760b1
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/paths.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"paths.js","sourceRoot":"","sources":["../../../src/test/helpers/paths.ts"],"names":[],"mappings":";;;AAAA,uEAAoE;AACpE,+BAAqC;AAErC,eAAe;AACF,QAAA,QAAQ,GAAG,IAAA,cAAO,EAAC,SAAS,EAAE,UAAU,CAAC,CAAC;AAC1C,QAAA,QAAQ,GAAG,IAAA,cAAO,EAAC,SAAS,EAAE,OAAO,CAAC,CAAC;AACvC,QAAA,QAAQ,GAAG,IAAA,WAAI,EAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;AAC7C,QAAA,OAAO,GAAG,IAAA,WAAI,EAAC,gBAAQ,EAAE,eAAe,CAAC,CAAC;AAC1C,QAAA,sBAAsB,GAAG,IAAA,WAAI,EAAC,gBAAQ,EAAE,8BAA8B,CAAC,CAAC;AACxE,QAAA,QAAQ,GAAG,IAAA,WAAI,EAAC,gBAAQ,EAAE,2BAA2B,CAAC,CAAC;AACvD,QAAA,WAAW,GAAG,IAAA,WAAI,EAAC,gBAAQ,EAAE,kCAAkC,CAAC,CAAC;AACjE,QAAA,eAAe,GAAG,IAAA,WAAI,EAAC,gBAAQ,EAAE,kCAAkC,CAAC,CAAC;AACrE,QAAA,YAAY,GAAG,IAAA,WAAI,EAAC,gBAAQ,EAAE,+BAA+B,CAAC,CAAC;AAC/D,QAAA,YAAY,GAAG,IAAA,WAAI,EAAC,gBAAQ,EAAE,+BAA+B,CAAC,CAAC;AAE5E,OAAO,CAAC,KAAK,CAAC,gBAAQ,CAAC,CAAC;AACxB,IAAA,uCAAkB,EAAC,gBAAQ,CAAC,CAAC;AAC7B,YAAY","sourcesContent":["import { setFixturesRootDir } from '@TypeStrong/fs-fixture-builder';\nimport { join, resolve } from 'path';\n\n//#region Paths\nexport const ROOT_DIR = resolve(__dirname, '../../..');\nexport const DIST_DIR = resolve(__dirname, '../..');\nexport const TEST_DIR = join(__dirname, '../../../tests');\nexport const PROJECT = join(TEST_DIR, 'tsconfig.json');\nexport const PROJECT_TRANSPILE_ONLY = join(TEST_DIR, 'tsconfig-transpile-only.json');\nexport const BIN_PATH = join(TEST_DIR, 'node_modules/.bin/ts-node');\nexport const BIN_PATH_JS = join(TEST_DIR, 'node_modules/ts-node/dist/bin.js');\nexport const BIN_SCRIPT_PATH = join(TEST_DIR, 'node_modules/.bin/ts-node-script');\nexport const BIN_CWD_PATH = join(TEST_DIR, 'node_modules/.bin/ts-node-cwd');\nexport const BIN_ESM_PATH = join(TEST_DIR, 'node_modules/.bin/ts-node-esm');\n\nprocess.chdir(TEST_DIR);\nsetFixturesRootDir(TEST_DIR);\n//#endregion\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/reset-node-environment.d.ts b/node_modules/ts-node/dist/test/helpers/reset-node-environment.d.ts
new file mode 100644
index 0000000..8b7bb79
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/reset-node-environment.d.ts
@@ -0,0 +1,7 @@
+/**
+ * Undo all of ts-node & co's installed hooks, resetting the node environment to default
+ * so we can run multiple test cases which `.register()` ts-node.
+ *
+ * Must also play nice with `nyc`'s environmental mutations.
+ */
+export declare function resetNodeEnvironment(): void;
diff --git a/node_modules/ts-node/dist/test/helpers/reset-node-environment.js b/node_modules/ts-node/dist/test/helpers/reset-node-environment.js
new file mode 100644
index 0000000..99f4849
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/reset-node-environment.js
@@ -0,0 +1,90 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.resetNodeEnvironment = void 0;
+const lodash_1 = require("lodash");
+// Reset node environment
+// Useful because ts-node installation necessarily must mutate the node environment.
+// Yet we want to run tests in-process for speed.
+// So we need to reliably reset everything changed by ts-node installation.
+const defaultRequireExtensions = captureObjectState(require.extensions);
+// Avoid node deprecation warning for accessing _channel
+const defaultProcess = captureObjectState(process, ['_channel']);
+const defaultModule = captureObjectState(require('module'));
+const defaultError = captureObjectState(Error);
+const defaultGlobal = captureObjectState(global);
+/**
+ * Undo all of ts-node & co's installed hooks, resetting the node environment to default
+ * so we can run multiple test cases which `.register()` ts-node.
+ *
+ * Must also play nice with `nyc`'s environmental mutations.
+ */
+function resetNodeEnvironment() {
+    const sms = require('@cspotcode/source-map-support');
+    // We must uninstall so that it resets its internal state; otherwise it won't know it needs to reinstall in the next test.
+    sms.uninstall();
+    // Must remove handlers to avoid a memory leak
+    sms.resetRetrieveHandlers();
+    // Modified by ts-node hooks
+    resetObject(require.extensions, defaultRequireExtensions, undefined, undefined, undefined, true);
+    // ts-node attaches a property when it registers an instance
+    // source-map-support monkey-patches the emit function
+    // Avoid node deprecation warnings for setting process.config or accessing _channel
+    resetObject(process, defaultProcess, undefined, ['_channel'], ['config']);
+    // source-map-support swaps out the prepareStackTrace function
+    resetObject(Error, defaultError);
+    // _resolveFilename et.al. are modified by ts-node, tsconfig-paths, source-map-support, yarn, maybe other things?
+    resetObject(require('module'), defaultModule, undefined, ['wrap', 'wrapper']);
+    // May be modified by REPL tests, since the REPL sets globals.
+    // Avoid deleting nyc's coverage data.
+    resetObject(global, defaultGlobal, ['__coverage__']);
+    // Reset our ESM hooks
+    process.__test_setloader__?.(undefined);
+}
+exports.resetNodeEnvironment = resetNodeEnvironment;
+function captureObjectState(object, avoidGetters = []) {
+    const descriptors = Object.getOwnPropertyDescriptors(object);
+    const values = (0, lodash_1.mapValues)(descriptors, (_d, key) => {
+        if (avoidGetters.includes(key))
+            return descriptors[key].value;
+        return object[key];
+    });
+    return {
+        descriptors,
+        values,
+    };
+}
+// Redefine all property descriptors and delete any new properties
+function resetObject(object, state, doNotDeleteTheseKeys = [], doNotSetTheseKeys = [], avoidSetterIfUnchanged = [], reorderProperties = false) {
+    const currentDescriptors = Object.getOwnPropertyDescriptors(object);
+    for (const key of Object.keys(currentDescriptors)) {
+        if (doNotDeleteTheseKeys.includes(key))
+            continue;
+        if ((0, lodash_1.has)(state.descriptors, key))
+            continue;
+        delete object[key];
+    }
+    // Trigger nyc's setter functions
+    for (const [key, value] of Object.entries(state.values)) {
+        try {
+            if (doNotSetTheseKeys === true || doNotSetTheseKeys.includes(key))
+                continue;
+            if (avoidSetterIfUnchanged.includes(key) && object[key] === value)
+                continue;
+            state.descriptors[key].set?.call(object, value);
+        }
+        catch { }
+    }
+    // Reset descriptors
+    Object.defineProperties(object, state.descriptors);
+    if (reorderProperties) {
+        // Delete and re-define each property so that they are in original order
+        const originalOrder = Object.keys(state.descriptors);
+        const properties = Object.getOwnPropertyDescriptors(object);
+        const sortedKeys = (0, lodash_1.sortBy)(Object.keys(properties), (name) => originalOrder.includes(name) ? originalOrder.indexOf(name) : 999);
+        for (const key of sortedKeys) {
+            delete object[key];
+            Object.defineProperty(object, key, properties[key]);
+        }
+    }
+}
+//# sourceMappingURL=reset-node-environment.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/reset-node-environment.js.map b/node_modules/ts-node/dist/test/helpers/reset-node-environment.js.map
new file mode 100644
index 0000000..5e24491
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/reset-node-environment.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"reset-node-environment.js","sourceRoot":"","sources":["../../../src/test/helpers/reset-node-environment.ts"],"names":[],"mappings":"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","sourcesContent":["import { has, mapValues, sortBy } from 'lodash';\n\n// Reset node environment\n// Useful because ts-node installation necessarily must mutate the node environment.\n// Yet we want to run tests in-process for speed.\n// So we need to reliably reset everything changed by ts-node installation.\n\nconst defaultRequireExtensions = captureObjectState(require.extensions);\n// Avoid node deprecation warning for accessing _channel\nconst defaultProcess = captureObjectState(process, ['_channel']);\nconst defaultModule = captureObjectState(require('module'));\nconst defaultError = captureObjectState(Error);\nconst defaultGlobal = captureObjectState(global);\n\n/**\n * Undo all of ts-node & co's installed hooks, resetting the node environment to default\n * so we can run multiple test cases which `.register()` ts-node.\n *\n * Must also play nice with `nyc`'s environmental mutations.\n */\nexport function resetNodeEnvironment() {\n  const sms = require('@cspotcode/source-map-support') as typeof import('@cspotcode/source-map-support');\n  // We must uninstall so that it resets its internal state; otherwise it won't know it needs to reinstall in the next test.\n  sms.uninstall();\n  // Must remove handlers to avoid a memory leak\n  sms.resetRetrieveHandlers();\n\n  // Modified by ts-node hooks\n  resetObject(require.extensions, defaultRequireExtensions, undefined, undefined, undefined, true);\n\n  // ts-node attaches a property when it registers an instance\n  // source-map-support monkey-patches the emit function\n  // Avoid node deprecation warnings for setting process.config or accessing _channel\n  resetObject(process, defaultProcess, undefined, ['_channel'], ['config']);\n\n  // source-map-support swaps out the prepareStackTrace function\n  resetObject(Error, defaultError);\n\n  // _resolveFilename et.al. are modified by ts-node, tsconfig-paths, source-map-support, yarn, maybe other things?\n  resetObject(require('module'), defaultModule, undefined, ['wrap', 'wrapper']);\n\n  // May be modified by REPL tests, since the REPL sets globals.\n  // Avoid deleting nyc's coverage data.\n  resetObject(global, defaultGlobal, ['__coverage__']);\n\n  // Reset our ESM hooks\n  process.__test_setloader__?.(undefined);\n}\n\nfunction captureObjectState(object: any, avoidGetters: string[] = []) {\n  const descriptors = Object.getOwnPropertyDescriptors(object);\n  const values = mapValues(descriptors, (_d, key) => {\n    if (avoidGetters.includes(key)) return descriptors[key].value;\n    return object[key];\n  });\n  return {\n    descriptors,\n    values,\n  };\n}\n// Redefine all property descriptors and delete any new properties\nfunction resetObject(\n  object: any,\n  state: ReturnType<typeof captureObjectState>,\n  doNotDeleteTheseKeys: string[] = [],\n  doNotSetTheseKeys: true | string[] = [],\n  avoidSetterIfUnchanged: string[] = [],\n  reorderProperties = false\n) {\n  const currentDescriptors = Object.getOwnPropertyDescriptors(object);\n  for (const key of Object.keys(currentDescriptors)) {\n    if (doNotDeleteTheseKeys.includes(key)) continue;\n    if (has(state.descriptors, key)) continue;\n    delete object[key];\n  }\n  // Trigger nyc's setter functions\n  for (const [key, value] of Object.entries(state.values)) {\n    try {\n      if (doNotSetTheseKeys === true || doNotSetTheseKeys.includes(key)) continue;\n      if (avoidSetterIfUnchanged.includes(key) && object[key] === value) continue;\n      state.descriptors[key].set?.call(object, value);\n    } catch {}\n  }\n  // Reset descriptors\n  Object.defineProperties(object, state.descriptors);\n\n  if (reorderProperties) {\n    // Delete and re-define each property so that they are in original order\n    const originalOrder = Object.keys(state.descriptors);\n    const properties = Object.getOwnPropertyDescriptors(object);\n    const sortedKeys = sortBy(Object.keys(properties), (name) =>\n      originalOrder.includes(name) ? originalOrder.indexOf(name) : 999\n    );\n    for (const key of sortedKeys) {\n      delete object[key];\n      Object.defineProperty(object, key, properties[key]);\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/version-checks.d.ts b/node_modules/ts-node/dist/test/helpers/version-checks.d.ts
new file mode 100644
index 0000000..3b2931e
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/version-checks.d.ts
@@ -0,0 +1,15 @@
+export declare const nodeUsesNewHooksApi: boolean;
+export declare const nodeSupportsImportAssertions: boolean;
+export declare const nodeSupportsUnflaggedJsonImports: boolean;
+export declare const nodeSupportsImportingTransformedCjsFromEsm: boolean;
+/** Supports module:nodenext and module:node16 as *stable* features */
+export declare const tsSupportsStableNodeNextNode16: boolean;
+export declare const tsSupportsMtsCtsExtensions: boolean;
+export declare const tsSupportsImportAssertions: boolean;
+export declare const tsSupportsReact17JsxFactories: boolean;
+export declare const tsSupportsAllowImportingTsExtensions: boolean;
+export declare const tsSupportsExtendsArray: boolean;
+export declare const tsSupportsVerbatimModuleSyntax: boolean;
+export declare const tsSupportsEs2021: boolean;
+export declare const tsSupportsEs2022: boolean;
+export declare const tsSupportsLibEs2023: boolean;
diff --git a/node_modules/ts-node/dist/test/helpers/version-checks.js b/node_modules/ts-node/dist/test/helpers/version-checks.js
new file mode 100644
index 0000000..d28e365
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/version-checks.js
@@ -0,0 +1,40 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.tsSupportsLibEs2023 = exports.tsSupportsEs2022 = exports.tsSupportsEs2021 = exports.tsSupportsVerbatimModuleSyntax = exports.tsSupportsExtendsArray = exports.tsSupportsAllowImportingTsExtensions = exports.tsSupportsReact17JsxFactories = exports.tsSupportsImportAssertions = exports.tsSupportsMtsCtsExtensions = exports.tsSupportsStableNodeNextNode16 = exports.nodeSupportsImportingTransformedCjsFromEsm = exports.nodeSupportsUnflaggedJsonImports = exports.nodeSupportsImportAssertions = exports.nodeUsesNewHooksApi = void 0;
+const semver = require("semver");
+const misc_1 = require("./misc");
+// Version checks, used to conditionally enable tests.
+exports.nodeUsesNewHooksApi = semver.gte(process.version, '16.12.0');
+// 16.14.0: https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V16.md#notable-changes-4
+// 17.1.0: https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V17.md#2021-11-09-version-1710-current-targos
+exports.nodeSupportsImportAssertions = (semver.gte(process.version, '16.14.0') && semver.lt(process.version, '17.0.0')) ||
+    semver.gte(process.version, '17.1.0');
+// These versions do not require `--experimental-json-modules`
+// 16.15.0: https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V16.md#2022-04-26-version-16150-gallium-lts-danielleadams
+// 17.5.0: https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V17.md#2022-02-10-version-1750-current-ruyadorno
+exports.nodeSupportsUnflaggedJsonImports = (semver.gte(process.version, '16.15.0') && semver.lt(process.version, '17.0.0')) ||
+    semver.gte(process.version, '17.5.0');
+// Node 14.13.0 has a bug where it tries to lex CJS files to discover named exports *before*
+// we transform the code.
+// In other words, it tries to parse raw TS as CJS and balks at `export const foo =`, expecting to see `exports.foo =`
+// This lexing only happens when CJS TS is imported from the ESM loader.
+exports.nodeSupportsImportingTransformedCjsFromEsm = semver.gte(process.version, '14.13.1');
+/** Supports module:nodenext and module:node16 as *stable* features */
+exports.tsSupportsStableNodeNextNode16 = misc_1.ts.version.startsWith('4.7.') || semver.gte(misc_1.ts.version, '4.7.0');
+// TS 4.5 is first version to understand .cts, .mts, .cjs, and .mjs extensions
+exports.tsSupportsMtsCtsExtensions = semver.gte(misc_1.ts.version, '4.5.0');
+exports.tsSupportsImportAssertions = semver.gte(misc_1.ts.version, '4.5.0');
+// TS 4.1 added jsx=react-jsx and react-jsxdev: https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#react-17-jsx-factories
+exports.tsSupportsReact17JsxFactories = semver.gte(misc_1.ts.version, '4.1.0');
+// TS 5.0 added "allowImportingTsExtensions"
+exports.tsSupportsAllowImportingTsExtensions = semver.gte(misc_1.ts.version, '4.999.999');
+// TS 5.0 adds ability for tsconfig to `"extends": []` an array of configs
+exports.tsSupportsExtendsArray = semver.gte(misc_1.ts.version, '4.999.999');
+// TS 5.0 adds verbatimModuleSyntax
+exports.tsSupportsVerbatimModuleSyntax = semver.gte(misc_1.ts.version, '5.0.0');
+// Relevant when @tsconfig/bases refers to es2021 and we run tests against
+// old TS versions.
+exports.tsSupportsEs2021 = semver.gte(misc_1.ts.version, '4.3.0');
+exports.tsSupportsEs2022 = semver.gte(misc_1.ts.version, '4.6.0');
+exports.tsSupportsLibEs2023 = semver.gte(misc_1.ts.version, '5.0.0');
+//# sourceMappingURL=version-checks.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/helpers/version-checks.js.map b/node_modules/ts-node/dist/test/helpers/version-checks.js.map
new file mode 100644
index 0000000..677c930
--- /dev/null
+++ b/node_modules/ts-node/dist/test/helpers/version-checks.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"version-checks.js","sourceRoot":"","sources":["../../../src/test/helpers/version-checks.ts"],"names":[],"mappings":";;;AAAA,iCAAkC;AAClC,iCAA4B;AAE5B,sDAAsD;AAEzC,QAAA,mBAAmB,GAAG,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;AAC1E,sGAAsG;AACtG,0HAA0H;AAC7G,QAAA,4BAA4B,GACvC,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAChF,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AACxC,8DAA8D;AAC9D,uIAAuI;AACvI,6HAA6H;AAChH,QAAA,gCAAgC,GAC3C,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAChF,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AACxC,4FAA4F;AAC5F,yBAAyB;AACzB,sHAAsH;AACtH,wEAAwE;AAC3D,QAAA,0CAA0C,GAAG,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;AACjG,sEAAsE;AACzD,QAAA,8BAA8B,GAAG,SAAE,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,GAAG,CAAC,SAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AAC/G,8EAA8E;AACjE,QAAA,0BAA0B,GAAG,MAAM,CAAC,GAAG,CAAC,SAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AAC7D,QAAA,0BAA0B,GAAG,MAAM,CAAC,GAAG,CAAC,SAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AAC1E,2IAA2I;AAC9H,QAAA,6BAA6B,GAAG,MAAM,CAAC,GAAG,CAAC,SAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AAC7E,4CAA4C;AAC/B,QAAA,oCAAoC,GAAG,MAAM,CAAC,GAAG,CAAC,SAAE,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AACxF,0EAA0E;AAC7D,QAAA,sBAAsB,GAAG,MAAM,CAAC,GAAG,CAAC,SAAE,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AAC1E,mCAAmC;AACtB,QAAA,8BAA8B,GAAG,MAAM,CAAC,GAAG,CAAC,SAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AAC9E,0EAA0E;AAC1E,mBAAmB;AACN,QAAA,gBAAgB,GAAG,MAAM,CAAC,GAAG,CAAC,SAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AACnD,QAAA,gBAAgB,GAAG,MAAM,CAAC,GAAG,CAAC,SAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AACnD,QAAA,mBAAmB,GAAG,MAAM,CAAC,GAAG,CAAC,SAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC","sourcesContent":["import semver = require('semver');\nimport { ts } from './misc';\n\n// Version checks, used to conditionally enable tests.\n\nexport const nodeUsesNewHooksApi = semver.gte(process.version, '16.12.0');\n// 16.14.0: https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V16.md#notable-changes-4\n// 17.1.0: https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V17.md#2021-11-09-version-1710-current-targos\nexport const nodeSupportsImportAssertions =\n  (semver.gte(process.version, '16.14.0') && semver.lt(process.version, '17.0.0')) ||\n  semver.gte(process.version, '17.1.0');\n// These versions do not require `--experimental-json-modules`\n// 16.15.0: https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V16.md#2022-04-26-version-16150-gallium-lts-danielleadams\n// 17.5.0: https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V17.md#2022-02-10-version-1750-current-ruyadorno\nexport const nodeSupportsUnflaggedJsonImports =\n  (semver.gte(process.version, '16.15.0') && semver.lt(process.version, '17.0.0')) ||\n  semver.gte(process.version, '17.5.0');\n// Node 14.13.0 has a bug where it tries to lex CJS files to discover named exports *before*\n// we transform the code.\n// In other words, it tries to parse raw TS as CJS and balks at `export const foo =`, expecting to see `exports.foo =`\n// This lexing only happens when CJS TS is imported from the ESM loader.\nexport const nodeSupportsImportingTransformedCjsFromEsm = semver.gte(process.version, '14.13.1');\n/** Supports module:nodenext and module:node16 as *stable* features */\nexport const tsSupportsStableNodeNextNode16 = ts.version.startsWith('4.7.') || semver.gte(ts.version, '4.7.0');\n// TS 4.5 is first version to understand .cts, .mts, .cjs, and .mjs extensions\nexport const tsSupportsMtsCtsExtensions = semver.gte(ts.version, '4.5.0');\nexport const tsSupportsImportAssertions = semver.gte(ts.version, '4.5.0');\n// TS 4.1 added jsx=react-jsx and react-jsxdev: https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#react-17-jsx-factories\nexport const tsSupportsReact17JsxFactories = semver.gte(ts.version, '4.1.0');\n// TS 5.0 added \"allowImportingTsExtensions\"\nexport const tsSupportsAllowImportingTsExtensions = semver.gte(ts.version, '4.999.999');\n// TS 5.0 adds ability for tsconfig to `\"extends\": []` an array of configs\nexport const tsSupportsExtendsArray = semver.gte(ts.version, '4.999.999');\n// TS 5.0 adds verbatimModuleSyntax\nexport const tsSupportsVerbatimModuleSyntax = semver.gte(ts.version, '5.0.0');\n// Relevant when @tsconfig/bases refers to es2021 and we run tests against\n// old TS versions.\nexport const tsSupportsEs2021 = semver.gte(ts.version, '4.3.0');\nexport const tsSupportsEs2022 = semver.gte(ts.version, '4.6.0');\nexport const tsSupportsLibEs2023 = semver.gte(ts.version, '5.0.0');\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/index.spec.d.ts b/node_modules/ts-node/dist/test/index.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/index.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/index.spec.js b/node_modules/ts-node/dist/test/index.spec.js
new file mode 100644
index 0000000..63bd11c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/index.spec.js
@@ -0,0 +1,426 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const testlib_1 = require("./testlib");
+const expect = require("expect");
+const path_1 = require("path");
+const helpers_1 = require("./helpers");
+const exec = (0, helpers_1.createExec)({
+    cwd: helpers_1.TEST_DIR,
+});
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+test.suite('ts-node', (test) => {
+    test('should not load typescript outside of loadConfig', async () => {
+        const r = await exec(`node -e "require('ts-node'); console.dir(Object.keys(require.cache).filter(k => k.includes('node_modules/typescript')).length)"`);
+        expect(r.err).toBe(null);
+        expect(r.stdout).toBe('0\n');
+    });
+    test.suite('cli', (test) => {
+        test('should execute cli', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} hello-world`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('Hello, world!\n');
+        });
+        test('shows usage via --help', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --help`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toMatch(/Usage: ts-node /);
+        });
+        test('shows version via -v', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} -v`);
+            expect(r.err).toBe(null);
+            expect(r.stdout.trim()).toBe('v' + (0, helpers_1.testsDirRequire)('ts-node/package').version);
+        });
+        test('shows version of compiler via -vv', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} -vv`);
+            expect(r.err).toBe(null);
+            expect(r.stdout.trim()).toBe(`ts-node v${(0, helpers_1.testsDirRequire)('ts-node/package').version}\n` +
+                `node ${process.version}\n` +
+                `compiler v${(0, helpers_1.testsDirRequire)('typescript/package').version}`);
+        });
+        test('should register via cli', async () => {
+            const r = await exec(`node -r ts-node/register hello-world.ts`, {
+                cwd: helpers_1.TEST_DIR,
+            });
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('Hello, world!\n');
+        });
+        test('should execute cli with absolute path', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} "${(0, path_1.join)(helpers_1.TEST_DIR, 'hello-world')}"`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('Hello, world!\n');
+        });
+        test('should print scripts', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} -pe "import { example } from './complex/index';example()"`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('example\n');
+        });
+        test("should expose ts-node Service as a symbol property on Node's `process` object", async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} env`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('object\n');
+        });
+        test('should allow js', async () => {
+            const r = await exec([
+                helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG,
+                '-O "{\\"allowJs\\":true}"',
+                '-pe "import { main } from \'./allow-js/run\';main()"',
+            ].join(' '));
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('hello world\n');
+        });
+        test('should include jsx when `allow-js` true', async () => {
+            const r = await exec([
+                helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG,
+                '-O "{\\"allowJs\\":true}"',
+                '-pe "import { Foo2 } from \'./allow-js/with-jsx\'; Foo2.sayHi()"',
+            ].join(' '));
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('hello world\n');
+        });
+        test.suite('should support cts when module = CommonJS', (test) => {
+            test.if(helpers_1.tsSupportsMtsCtsExtensions);
+            test('test', async (t) => {
+                const r = await exec([helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG, '-pe "import { main } from \'./index.cjs\';main()"'].join(' '), {
+                    cwd: (0, path_1.join)(helpers_1.TEST_DIR, 'ts45-ext/ext-cts'),
+                });
+                expect(r.err).toBe(null);
+                expect(r.stdout).toBe('hello world\n');
+            });
+        });
+        test.suite('should support mts when module = ESNext', (test) => {
+            test.if(helpers_1.tsSupportsMtsCtsExtensions);
+            test('test', async () => {
+                const r = await exec([helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG, './entrypoint.mjs'].join(' '), {
+                    cwd: (0, path_1.join)(helpers_1.TEST_DIR, 'ts45-ext/ext-mts'),
+                });
+                expect(r.err).toBe(null);
+                expect(r.stdout).toBe('hello world\n');
+            });
+        });
+        test('should eval code', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} -e "import * as m from './module';console.log(m.example('test'))"`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('TEST\n');
+        });
+        test('should import empty files', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} -e "import './empty'"`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('');
+        });
+        test('should throw typechecking errors', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} -e "import * as m from './module';console.log(m.example(123))"`);
+            if (r.err === null) {
+                throw new Error('Command was expected to fail, but it succeeded.');
+            }
+            expect(r.err.message).toMatch(new RegExp("TS2345: Argument of type '(?:number|123)' " + "is not assignable to parameter of type 'string'\\."));
+        });
+        test('should be able to ignore diagnostic', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} --ignore-diagnostics 2345 -e "import * as m from './module';console.log(m.example(123))"`);
+            if (r.err === null) {
+                throw new Error('Command was expected to fail, but it succeeded.');
+            }
+            expect(r.err.message).toMatch(/TypeError: (?:(?:undefined|foo\.toUpperCase) is not a function|.*has no method \'toUpperCase\')/);
+        });
+        test('should work with source maps', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} "throw error"`);
+            if (r.err === null) {
+                throw new Error('Command was expected to fail, but it succeeded.');
+            }
+            expect(r.err.message).toMatch([
+                `${(0, path_1.join)(helpers_1.TEST_DIR, 'throw error.ts')}:100`,
+                "  bar() { throw new Error('this is a demo'); }",
+                '                ^',
+                'Error: this is a demo',
+            ].join('\n'));
+        });
+        test('should work with source maps in --transpile-only mode', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} --transpile-only "throw error"`);
+            if (r.err === null) {
+                throw new Error('Command was expected to fail, but it succeeded.');
+            }
+            expect(r.err.message).toMatch([
+                `${(0, path_1.join)(helpers_1.TEST_DIR, 'throw error.ts')}:100`,
+                "  bar() { throw new Error('this is a demo'); }",
+                '                ^',
+                'Error: this is a demo',
+            ].join('\n'));
+        });
+        test('eval should work with source maps', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} -pe "import './throw error'"`);
+            if (r.err === null) {
+                throw new Error('Command was expected to fail, but it succeeded.');
+            }
+            expect(r.err.message).toMatch([
+                `${(0, path_1.join)(helpers_1.TEST_DIR, 'throw error.ts')}:100`,
+                "  bar() { throw new Error('this is a demo'); }",
+                '                ^',
+            ].join('\n'));
+        });
+        for (const flavor of [
+            '--transpiler ts-node/transpilers/swc transpile-only-swc',
+            '--transpiler ts-node/transpilers/swc-experimental transpile-only-swc',
+            '--swc transpile-only-swc',
+            'transpile-only-swc-via-tsconfig',
+            'transpile-only-swc-shorthand-via-tsconfig',
+        ]) {
+            test(`should support swc and third-party transpilers: ${flavor}`, async () => {
+                const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} ${flavor}`, {
+                    env: {
+                        ...process.env,
+                        NODE_OPTIONS: `${process.env.NODE_OPTIONS || ''} --require ${require.resolve('../../tests/spy-swc-transpiler')}`,
+                    },
+                });
+                expect(r.err).toBe(null);
+                expect(r.stdout).toMatch('Hello World! swc transpiler invocation count: 1\n');
+            });
+        }
+        test.suite('should support `traceResolution` compiler option', (test) => {
+            test('prints traces before running code when enabled', async () => {
+                const r = await exec(`${helpers_1.BIN_PATH} --compiler-options="{ \\"traceResolution\\": true }" -e "console.log('ok')"`);
+                expect(r.err).toBeNull();
+                expect(r.stdout).toContain('======== Resolving module');
+                expect(r.stdout.endsWith('ok\n')).toBe(true);
+            });
+            test('does NOT print traces when not enabled', async () => {
+                const r = await exec(`${helpers_1.BIN_PATH} -e "console.log('ok')"`);
+                expect(r.err).toBeNull();
+                expect(r.stdout).not.toContain('======== Resolving module');
+                expect(r.stdout.endsWith('ok\n')).toBe(true);
+            });
+        });
+        test('swc transpiler supports native ESM emit', async () => {
+            const r = await exec(`${helpers_1.CMD_ESM_LOADER_WITHOUT_PROJECT} ./index.ts`, {
+                cwd: (0, path_1.resolve)(helpers_1.TEST_DIR, 'transpile-only-swc-native-esm'),
+            });
+            expect(r.err).toBe(null);
+            expect(r.stdout).toMatch('Hello file://');
+        });
+        test('should pipe into `ts-node` and evaluate', async () => {
+            const p = exec(helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG);
+            p.child.stdin.end("console.log('hello')");
+            const r = await p;
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('hello\n');
+        });
+        test('should pipe into `ts-node`', async () => {
+            const p = exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} -p`);
+            p.child.stdin.end('true');
+            const r = await p;
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('true\n');
+        });
+        test('should pipe into an eval script', async () => {
+            const p = exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} --transpile-only -pe "process.stdin.isTTY"`);
+            p.child.stdin.end('true');
+            const r = await p;
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('undefined\n');
+        });
+        test('should support require flags', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} -r ./hello-world -pe "console.log('success')"`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('Hello, world!\nsuccess\nundefined\n');
+        });
+        test('should support require from node modules', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} -r typescript -e "console.log('success')"`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('success\n');
+        });
+        test('should use source maps with react tsx', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} "throw error react tsx.tsx"`);
+            expect(r.err).not.toBe(null);
+            expect(r.err.message).toMatch([
+                `${(0, path_1.join)(helpers_1.TEST_DIR, './throw error react tsx.tsx')}:100`,
+                "  bar() { throw new Error('this is a demo'); }",
+                '                ^',
+                'Error: this is a demo',
+            ].join('\n'));
+        });
+        test('should use source maps with react tsx in --transpile-only mode', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} --transpile-only "throw error react tsx.tsx"`);
+            expect(r.err).not.toBe(null);
+            expect(r.err.message).toMatch([
+                `${(0, path_1.join)(helpers_1.TEST_DIR, './throw error react tsx.tsx')}:100`,
+                "  bar() { throw new Error('this is a demo'); }",
+                '                ^',
+                'Error: this is a demo',
+            ].join('\n'));
+        });
+        test('should allow custom typings', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} custom-types`);
+            // This error comes from *node*, meaning TypeScript respected the custom types (good) but *node* could not find the non-existent module (expected)
+            expect(r.err?.message).toMatch(/Error: Cannot find module 'does-not-exist'/);
+        });
+        test('should import js before ts by default', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} import-order/compiled`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('Hello, JavaScript!\n');
+        });
+        test('should import ts before js when --prefer-ts-exts flag is present', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} --prefer-ts-exts import-order/compiled`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('Hello, TypeScript!\n');
+        });
+        test('should import ts before js when TS_NODE_PREFER_TS_EXTS env is present', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} import-order/compiled`, {
+                env: { ...process.env, TS_NODE_PREFER_TS_EXTS: 'true' },
+            });
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('Hello, TypeScript!\n');
+        });
+        test('should ignore .d.ts files', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} import-order/importer`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe('Hello, World!\n');
+        });
+        test.suite('issue #884', (test) => {
+            test('should compile', async (t) => {
+                const r = await exec(`"${helpers_1.BIN_PATH}" --project issue-884/tsconfig.json issue-884`);
+                expect(r.err).toBe(null);
+                expect(r.stdout).toBe('');
+            });
+        });
+        test.suite('issue #986', (test) => {
+            test('should not compile', async () => {
+                const r = await exec(`"${helpers_1.BIN_PATH}" --project issue-986/tsconfig.json issue-986`);
+                expect(r.err).not.toBe(null);
+                expect(r.stderr).toMatch("Cannot find name 'TEST'"); // TypeScript error.
+                expect(r.stdout).toBe('');
+            });
+            test('should compile with `--files`', async () => {
+                const r = await exec(`"${helpers_1.BIN_PATH}" --files --project issue-986/tsconfig.json issue-986`);
+                expect(r.err).not.toBe(null);
+                expect(r.stderr).toMatch('ReferenceError: TEST is not defined'); // Runtime error.
+                expect(r.stdout).toBe('');
+            });
+        });
+        test('should have the correct working directory in the user entry-point', async () => {
+            const r = await exec(`${helpers_1.BIN_PATH} --cwd ./cjs index.ts`, {
+                cwd: (0, path_1.resolve)(helpers_1.TEST_DIR, 'working-dir'),
+            });
+            expect(r.err).toBe(null);
+            expect(r.stdout.trim()).toBe('Passing');
+            expect(r.stderr).toBe('');
+        });
+        // Disabled due to bug:
+        // --cwd is passed to forked children when not using --esm, erroneously affects their entrypoint resolution.
+        // tracked/fixed by either https://github.com/TypeStrong/ts-node/issues/1834
+        // or https://github.com/TypeStrong/ts-node/issues/1831
+        test.skip('should be able to fork into a nested TypeScript script with a modified working directory', async () => {
+            const r = await exec(`${helpers_1.BIN_PATH} --cwd ./working-dir/forking/ index.ts`);
+            expect(r.err).toBe(null);
+            expect(r.stdout.trim()).toBe('Passing: from main');
+            expect(r.stderr).toBe('');
+        });
+        test.suite('compiler host', (test) => {
+            test('should execute cli', async () => {
+                const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} --compiler-host hello-world`);
+                expect(r.err).toBe(null);
+                expect(r.stdout).toBe('Hello, world!\n');
+            });
+        });
+        test('should transpile files inside a node_modules directory when not ignored', async () => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} from-node-modules/from-node-modules`);
+            if (r.err)
+                throw new Error(`Unexpected error: ${r.err}\nstdout:\n${r.stdout}\nstderr:\n${r.stderr}`);
+            expect(JSON.parse(r.stdout)).toEqual({
+                external: {
+                    tsmri: { name: 'typescript-module-required-internally' },
+                    jsmri: { name: 'javascript-module-required-internally' },
+                    tsmii: { name: 'typescript-module-imported-internally' },
+                    jsmii: { name: 'javascript-module-imported-internally' },
+                },
+                tsmie: { name: 'typescript-module-imported-externally' },
+                jsmie: { name: 'javascript-module-imported-externally' },
+                tsmre: { name: 'typescript-module-required-externally' },
+                jsmre: { name: 'javascript-module-required-externally' },
+            });
+        });
+        test.suite('should respect maxNodeModulesJsDepth', (test) => {
+            test('for unscoped modules', async () => {
+                const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} maxnodemodulesjsdepth`);
+                expect(r.err).not.toBe(null);
+                expect(r.stderr.replace(/\r\n/g, '\n')).toMatch('TSError:  Unable to compile TypeScript:\n' +
+                    "maxnodemodulesjsdepth/other.ts(4,7): error TS2322: Type 'string' is not assignable to type 'boolean'.\n" +
+                    '\n');
+            });
+            test('for @scoped modules', async () => {
+                const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} maxnodemodulesjsdepth-scoped`);
+                expect(r.err).not.toBe(null);
+                expect(r.stderr.replace(/\r\n/g, '\n')).toMatch('TSError:  Unable to compile TypeScript:\n' +
+                    "maxnodemodulesjsdepth-scoped/other.ts(7,7): error TS2322: Type 'string' is not assignable to type 'boolean'.\n" +
+                    '\n');
+            });
+        });
+        test('--showConfig should log resolved configuration', async (t) => {
+            function native(path) {
+                return path.replace(/\/|\\/g, path_1.sep);
+            }
+            function posix(path) {
+                return path.replace(/\/|\\/g, '/');
+            }
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG} --showConfig`);
+            expect(r.err).toBe(null);
+            t.is(r.stdout, JSON.stringify({
+                'ts-node': {
+                    cwd: native(`${helpers_1.ROOT_DIR}/tests`),
+                    projectSearchDir: native(`${helpers_1.ROOT_DIR}/tests`),
+                    project: native(`${helpers_1.ROOT_DIR}/tests/tsconfig.json`),
+                },
+                compilerOptions: {
+                    target: 'es6',
+                    jsx: 'react',
+                    noEmit: false,
+                    strict: true,
+                    typeRoots: [posix(`${helpers_1.ROOT_DIR}/tests/typings`), posix(`${helpers_1.ROOT_DIR}/node_modules/@types`)],
+                    sourceMap: true,
+                    inlineSourceMap: false,
+                    inlineSources: true,
+                    declaration: false,
+                    outDir: './.ts-node',
+                    module: 'commonjs',
+                },
+            }, null, 2) + '\n');
+        });
+        test('should support compiler scope specified via tsconfig.json', async (t) => {
+            const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --project ./scope/c/config/tsconfig.json ./scope/c/index.js`);
+            expect(r.err).toBe(null);
+            expect(r.stdout).toBe(`value\nFailures: 0\n`);
+        });
+    });
+});
+test('Falls back to transpileOnly when ts compiler returns emitSkipped', async () => {
+    const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --project tsconfig.json ./outside-rootDir/foo.js`, {
+        cwd: (0, path_1.join)(helpers_1.TEST_DIR, 'emit-skipped-fallback'),
+    });
+    expect(r.err).toBe(null);
+    expect(r.stdout).toBe('foo\n');
+});
+test.suite('node environment', (test) => {
+    test.suite('Sets argv and execArgv correctly in forked processes', (test) => {
+        forkTest(`node --no-warnings ${helpers_1.BIN_PATH_JS}`, helpers_1.BIN_PATH_JS, '--no-warnings');
+        forkTest(`${helpers_1.BIN_PATH}`, process.platform === 'win32' ? helpers_1.BIN_PATH_JS : helpers_1.BIN_PATH);
+        function forkTest(command, expectParentArgv0, nodeFlag) {
+            test(command, async (t) => {
+                const r = await exec(`${command} --skipIgnore ./recursive-fork/index.ts argv2`);
+                expect(r.err).toBeNull();
+                expect(r.stderr).toBe('');
+                const generations = r.stdout.split('\n');
+                const expectation = {
+                    execArgv: [nodeFlag, helpers_1.BIN_PATH_JS, '--skipIgnore'].filter((v) => v),
+                    argv: [
+                        // Note: argv[0] is *always* BIN_PATH_JS in child & grandchild
+                        expectParentArgv0,
+                        (0, path_1.resolve)(helpers_1.TEST_DIR, 'recursive-fork/index.ts'),
+                        'argv2',
+                    ],
+                };
+                expect(JSON.parse(generations[0])).toMatchObject(expectation);
+                expectation.argv[0] = helpers_1.BIN_PATH_JS;
+                expect(JSON.parse(generations[1])).toMatchObject(expectation);
+                expect(JSON.parse(generations[2])).toMatchObject(expectation);
+            });
+        }
+    });
+});
+//# sourceMappingURL=index.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/index.spec.js.map b/node_modules/ts-node/dist/test/index.spec.js.map
new file mode 100644
index 0000000..3175e6e
--- /dev/null
+++ b/node_modules/ts-node/dist/test/index.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.spec.js","sourceRoot":"","sources":["../../src/test/index.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { context } from './testlib';\nimport * as expect from 'expect';\nimport { join, resolve, sep as pathSep } from 'path';\nimport {\n  BIN_PATH_JS,\n  CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG,\n  tsSupportsMtsCtsExtensions,\n  BIN_PATH,\n  ROOT_DIR,\n  TEST_DIR,\n  testsDirRequire,\n  ctxTsNode,\n  CMD_TS_NODE_WITH_PROJECT_FLAG,\n  CMD_TS_NODE_WITHOUT_PROJECT_FLAG,\n  CMD_ESM_LOADER_WITHOUT_PROJECT,\n  createExec,\n} from './helpers';\n\nconst exec = createExec({\n  cwd: TEST_DIR,\n});\n\nconst test = context(ctxTsNode);\n\ntest.suite('ts-node', (test) => {\n  test('should not load typescript outside of loadConfig', async () => {\n    const r = await exec(\n      `node -e \"require('ts-node'); console.dir(Object.keys(require.cache).filter(k => k.includes('node_modules/typescript')).length)\"`\n    );\n    expect(r.err).toBe(null);\n    expect(r.stdout).toBe('0\\n');\n  });\n\n  test.suite('cli', (test) => {\n    test('should execute cli', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} hello-world`);\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('Hello, world!\\n');\n    });\n\n    test('shows usage via --help', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --help`);\n      expect(r.err).toBe(null);\n      expect(r.stdout).toMatch(/Usage: ts-node /);\n    });\n    test('shows version via -v', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} -v`);\n      expect(r.err).toBe(null);\n      expect(r.stdout.trim()).toBe('v' + testsDirRequire('ts-node/package').version);\n    });\n    test('shows version of compiler via -vv', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} -vv`);\n      expect(r.err).toBe(null);\n      expect(r.stdout.trim()).toBe(\n        `ts-node v${testsDirRequire('ts-node/package').version}\\n` +\n          `node ${process.version}\\n` +\n          `compiler v${testsDirRequire('typescript/package').version}`\n      );\n    });\n\n    test('should register via cli', async () => {\n      const r = await exec(`node -r ts-node/register hello-world.ts`, {\n        cwd: TEST_DIR,\n      });\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('Hello, world!\\n');\n    });\n\n    test('should execute cli with absolute path', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} \"${join(TEST_DIR, 'hello-world')}\"`);\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('Hello, world!\\n');\n    });\n\n    test('should print scripts', async () => {\n      const r = await exec(\n        `${CMD_TS_NODE_WITH_PROJECT_FLAG} -pe \"import { example } from './complex/index';example()\"`\n      );\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('example\\n');\n    });\n\n    test(\"should expose ts-node Service as a symbol property on Node's `process` object\", async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} env`);\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('object\\n');\n    });\n\n    test('should allow js', async () => {\n      const r = await exec(\n        [\n          CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG,\n          '-O \"{\\\\\"allowJs\\\\\":true}\"',\n          '-pe \"import { main } from \\'./allow-js/run\\';main()\"',\n        ].join(' ')\n      );\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('hello world\\n');\n    });\n\n    test('should include jsx when `allow-js` true', async () => {\n      const r = await exec(\n        [\n          CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG,\n          '-O \"{\\\\\"allowJs\\\\\":true}\"',\n          '-pe \"import { Foo2 } from \\'./allow-js/with-jsx\\'; Foo2.sayHi()\"',\n        ].join(' ')\n      );\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('hello world\\n');\n    });\n\n    test.suite('should support cts when module = CommonJS', (test) => {\n      test.if(tsSupportsMtsCtsExtensions);\n      test('test', async (t) => {\n        const r = await exec(\n          [CMD_TS_NODE_WITHOUT_PROJECT_FLAG, '-pe \"import { main } from \\'./index.cjs\\';main()\"'].join(' '),\n          {\n            cwd: join(TEST_DIR, 'ts45-ext/ext-cts'),\n          }\n        );\n        expect(r.err).toBe(null);\n        expect(r.stdout).toBe('hello world\\n');\n      });\n    });\n\n    test.suite('should support mts when module = ESNext', (test) => {\n      test.if(tsSupportsMtsCtsExtensions);\n      test('test', async () => {\n        const r = await exec([CMD_TS_NODE_WITHOUT_PROJECT_FLAG, './entrypoint.mjs'].join(' '), {\n          cwd: join(TEST_DIR, 'ts45-ext/ext-mts'),\n        });\n        expect(r.err).toBe(null);\n        expect(r.stdout).toBe('hello world\\n');\n      });\n    });\n\n    test('should eval code', async () => {\n      const r = await exec(\n        `${CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} -e \"import * as m from './module';console.log(m.example('test'))\"`\n      );\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('TEST\\n');\n    });\n\n    test('should import empty files', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} -e \"import './empty'\"`);\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('');\n    });\n\n    test('should throw typechecking errors', async () => {\n      const r = await exec(\n        `${CMD_TS_NODE_WITH_PROJECT_FLAG} -e \"import * as m from './module';console.log(m.example(123))\"`\n      );\n      if (r.err === null) {\n        throw new Error('Command was expected to fail, but it succeeded.');\n      }\n\n      expect(r.err.message).toMatch(\n        new RegExp(\"TS2345: Argument of type '(?:number|123)' \" + \"is not assignable to parameter of type 'string'\\\\.\")\n      );\n    });\n\n    test('should be able to ignore diagnostic', async () => {\n      const r = await exec(\n        `${CMD_TS_NODE_WITH_PROJECT_FLAG} --ignore-diagnostics 2345 -e \"import * as m from './module';console.log(m.example(123))\"`\n      );\n      if (r.err === null) {\n        throw new Error('Command was expected to fail, but it succeeded.');\n      }\n\n      expect(r.err.message).toMatch(\n        /TypeError: (?:(?:undefined|foo\\.toUpperCase) is not a function|.*has no method \\'toUpperCase\\')/\n      );\n    });\n\n    test('should work with source maps', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} \"throw error\"`);\n      if (r.err === null) {\n        throw new Error('Command was expected to fail, but it succeeded.');\n      }\n\n      expect(r.err.message).toMatch(\n        [\n          `${join(TEST_DIR, 'throw error.ts')}:100`,\n          \"  bar() { throw new Error('this is a demo'); }\",\n          '                ^',\n          'Error: this is a demo',\n        ].join('\\n')\n      );\n    });\n\n    test('should work with source maps in --transpile-only mode', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --transpile-only \"throw error\"`);\n      if (r.err === null) {\n        throw new Error('Command was expected to fail, but it succeeded.');\n      }\n\n      expect(r.err.message).toMatch(\n        [\n          `${join(TEST_DIR, 'throw error.ts')}:100`,\n          \"  bar() { throw new Error('this is a demo'); }\",\n          '                ^',\n          'Error: this is a demo',\n        ].join('\\n')\n      );\n    });\n\n    test('eval should work with source maps', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} -pe \"import './throw error'\"`);\n      if (r.err === null) {\n        throw new Error('Command was expected to fail, but it succeeded.');\n      }\n\n      expect(r.err.message).toMatch(\n        [\n          `${join(TEST_DIR, 'throw error.ts')}:100`,\n          \"  bar() { throw new Error('this is a demo'); }\",\n          '                ^',\n        ].join('\\n')\n      );\n    });\n\n    for (const flavor of [\n      '--transpiler ts-node/transpilers/swc transpile-only-swc',\n      '--transpiler ts-node/transpilers/swc-experimental transpile-only-swc',\n      '--swc transpile-only-swc',\n      'transpile-only-swc-via-tsconfig',\n      'transpile-only-swc-shorthand-via-tsconfig',\n    ]) {\n      test(`should support swc and third-party transpilers: ${flavor}`, async () => {\n        const r = await exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} ${flavor}`, {\n          env: {\n            ...process.env,\n            NODE_OPTIONS: `${process.env.NODE_OPTIONS || ''} --require ${require.resolve(\n              '../../tests/spy-swc-transpiler'\n            )}`,\n          },\n        });\n        expect(r.err).toBe(null);\n        expect(r.stdout).toMatch('Hello World! swc transpiler invocation count: 1\\n');\n      });\n    }\n\n    test.suite('should support `traceResolution` compiler option', (test) => {\n      test('prints traces before running code when enabled', async () => {\n        const r = await exec(`${BIN_PATH} --compiler-options=\"{ \\\\\"traceResolution\\\\\": true }\" -e \"console.log('ok')\"`);\n        expect(r.err).toBeNull();\n        expect(r.stdout).toContain('======== Resolving module');\n        expect(r.stdout.endsWith('ok\\n')).toBe(true);\n      });\n\n      test('does NOT print traces when not enabled', async () => {\n        const r = await exec(`${BIN_PATH} -e \"console.log('ok')\"`);\n        expect(r.err).toBeNull();\n        expect(r.stdout).not.toContain('======== Resolving module');\n        expect(r.stdout.endsWith('ok\\n')).toBe(true);\n      });\n    });\n\n    test('swc transpiler supports native ESM emit', async () => {\n      const r = await exec(`${CMD_ESM_LOADER_WITHOUT_PROJECT} ./index.ts`, {\n        cwd: resolve(TEST_DIR, 'transpile-only-swc-native-esm'),\n      });\n      expect(r.err).toBe(null);\n      expect(r.stdout).toMatch('Hello file://');\n    });\n\n    test('should pipe into `ts-node` and evaluate', async () => {\n      const p = exec(CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG);\n      p.child.stdin!.end(\"console.log('hello')\");\n      const r = await p;\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('hello\\n');\n    });\n\n    test('should pipe into `ts-node`', async () => {\n      const p = exec(`${CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} -p`);\n      p.child.stdin!.end('true');\n      const r = await p;\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('true\\n');\n    });\n\n    test('should pipe into an eval script', async () => {\n      const p = exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --transpile-only -pe \"process.stdin.isTTY\"`);\n      p.child.stdin!.end('true');\n      const r = await p;\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('undefined\\n');\n    });\n\n    test('should support require flags', async () => {\n      const r = await exec(\n        `${CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} -r ./hello-world -pe \"console.log('success')\"`\n      );\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('Hello, world!\\nsuccess\\nundefined\\n');\n    });\n\n    test('should support require from node modules', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} -r typescript -e \"console.log('success')\"`);\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('success\\n');\n    });\n\n    test('should use source maps with react tsx', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} \"throw error react tsx.tsx\"`);\n      expect(r.err).not.toBe(null);\n      expect(r.err!.message).toMatch(\n        [\n          `${join(TEST_DIR, './throw error react tsx.tsx')}:100`,\n          \"  bar() { throw new Error('this is a demo'); }\",\n          '                ^',\n          'Error: this is a demo',\n        ].join('\\n')\n      );\n    });\n\n    test('should use source maps with react tsx in --transpile-only mode', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --transpile-only \"throw error react tsx.tsx\"`);\n      expect(r.err).not.toBe(null);\n      expect(r.err!.message).toMatch(\n        [\n          `${join(TEST_DIR, './throw error react tsx.tsx')}:100`,\n          \"  bar() { throw new Error('this is a demo'); }\",\n          '                ^',\n          'Error: this is a demo',\n        ].join('\\n')\n      );\n    });\n\n    test('should allow custom typings', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} custom-types`);\n      // This error comes from *node*, meaning TypeScript respected the custom types (good) but *node* could not find the non-existent module (expected)\n      expect(r.err?.message).toMatch(/Error: Cannot find module 'does-not-exist'/);\n    });\n\n    test('should import js before ts by default', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} import-order/compiled`);\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('Hello, JavaScript!\\n');\n    });\n\n    test('should import ts before js when --prefer-ts-exts flag is present', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} --prefer-ts-exts import-order/compiled`);\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('Hello, TypeScript!\\n');\n    });\n\n    test('should import ts before js when TS_NODE_PREFER_TS_EXTS env is present', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} import-order/compiled`, {\n        env: { ...process.env, TS_NODE_PREFER_TS_EXTS: 'true' },\n      });\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('Hello, TypeScript!\\n');\n    });\n\n    test('should ignore .d.ts files', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_TRANSPILE_ONLY_FLAG} import-order/importer`);\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('Hello, World!\\n');\n    });\n\n    test.suite('issue #884', (test) => {\n      test('should compile', async (t) => {\n        const r = await exec(`\"${BIN_PATH}\" --project issue-884/tsconfig.json issue-884`);\n        expect(r.err).toBe(null);\n        expect(r.stdout).toBe('');\n      });\n    });\n\n    test.suite('issue #986', (test) => {\n      test('should not compile', async () => {\n        const r = await exec(`\"${BIN_PATH}\" --project issue-986/tsconfig.json issue-986`);\n        expect(r.err).not.toBe(null);\n        expect(r.stderr).toMatch(\"Cannot find name 'TEST'\"); // TypeScript error.\n        expect(r.stdout).toBe('');\n      });\n\n      test('should compile with `--files`', async () => {\n        const r = await exec(`\"${BIN_PATH}\" --files --project issue-986/tsconfig.json issue-986`);\n        expect(r.err).not.toBe(null);\n        expect(r.stderr).toMatch('ReferenceError: TEST is not defined'); // Runtime error.\n        expect(r.stdout).toBe('');\n      });\n    });\n\n    test('should have the correct working directory in the user entry-point', async () => {\n      const r = await exec(`${BIN_PATH} --cwd ./cjs index.ts`, {\n        cwd: resolve(TEST_DIR, 'working-dir'),\n      });\n\n      expect(r.err).toBe(null);\n      expect(r.stdout.trim()).toBe('Passing');\n      expect(r.stderr).toBe('');\n    });\n\n    // Disabled due to bug:\n    // --cwd is passed to forked children when not using --esm, erroneously affects their entrypoint resolution.\n    // tracked/fixed by either https://github.com/TypeStrong/ts-node/issues/1834\n    // or https://github.com/TypeStrong/ts-node/issues/1831\n    test.skip('should be able to fork into a nested TypeScript script with a modified working directory', async () => {\n      const r = await exec(`${BIN_PATH} --cwd ./working-dir/forking/ index.ts`);\n\n      expect(r.err).toBe(null);\n      expect(r.stdout.trim()).toBe('Passing: from main');\n      expect(r.stderr).toBe('');\n    });\n\n    test.suite('compiler host', (test) => {\n      test('should execute cli', async () => {\n        const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --compiler-host hello-world`);\n        expect(r.err).toBe(null);\n        expect(r.stdout).toBe('Hello, world!\\n');\n      });\n    });\n\n    test('should transpile files inside a node_modules directory when not ignored', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} from-node-modules/from-node-modules`);\n      if (r.err) throw new Error(`Unexpected error: ${r.err}\\nstdout:\\n${r.stdout}\\nstderr:\\n${r.stderr}`);\n      expect(JSON.parse(r.stdout)).toEqual({\n        external: {\n          tsmri: { name: 'typescript-module-required-internally' },\n          jsmri: { name: 'javascript-module-required-internally' },\n          tsmii: { name: 'typescript-module-imported-internally' },\n          jsmii: { name: 'javascript-module-imported-internally' },\n        },\n        tsmie: { name: 'typescript-module-imported-externally' },\n        jsmie: { name: 'javascript-module-imported-externally' },\n        tsmre: { name: 'typescript-module-required-externally' },\n        jsmre: { name: 'javascript-module-required-externally' },\n      });\n    });\n\n    test.suite('should respect maxNodeModulesJsDepth', (test) => {\n      test('for unscoped modules', async () => {\n        const r = await exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} maxnodemodulesjsdepth`);\n        expect(r.err).not.toBe(null);\n        expect(r.stderr.replace(/\\r\\n/g, '\\n')).toMatch(\n          'TSError:  Unable to compile TypeScript:\\n' +\n            \"maxnodemodulesjsdepth/other.ts(4,7): error TS2322: Type 'string' is not assignable to type 'boolean'.\\n\" +\n            '\\n'\n        );\n      });\n\n      test('for @scoped modules', async () => {\n        const r = await exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} maxnodemodulesjsdepth-scoped`);\n        expect(r.err).not.toBe(null);\n        expect(r.stderr.replace(/\\r\\n/g, '\\n')).toMatch(\n          'TSError:  Unable to compile TypeScript:\\n' +\n            \"maxnodemodulesjsdepth-scoped/other.ts(7,7): error TS2322: Type 'string' is not assignable to type 'boolean'.\\n\" +\n            '\\n'\n        );\n      });\n    });\n\n    test('--showConfig should log resolved configuration', async (t) => {\n      function native(path: string) {\n        return path.replace(/\\/|\\\\/g, pathSep);\n      }\n      function posix(path: string) {\n        return path.replace(/\\/|\\\\/g, '/');\n      }\n      const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --showConfig`);\n      expect(r.err).toBe(null);\n      t.is(\n        r.stdout,\n        JSON.stringify(\n          {\n            'ts-node': {\n              cwd: native(`${ROOT_DIR}/tests`),\n              projectSearchDir: native(`${ROOT_DIR}/tests`),\n              project: native(`${ROOT_DIR}/tests/tsconfig.json`),\n            },\n            compilerOptions: {\n              target: 'es6',\n              jsx: 'react',\n              noEmit: false,\n              strict: true,\n              typeRoots: [posix(`${ROOT_DIR}/tests/typings`), posix(`${ROOT_DIR}/node_modules/@types`)],\n              sourceMap: true,\n              inlineSourceMap: false,\n              inlineSources: true,\n              declaration: false,\n              outDir: './.ts-node',\n              module: 'commonjs',\n            },\n          },\n          null,\n          2\n        ) + '\\n'\n      );\n    });\n\n    test('should support compiler scope specified via tsconfig.json', async (t) => {\n      const r = await exec(\n        `${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --project ./scope/c/config/tsconfig.json ./scope/c/index.js`\n      );\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe(`value\\nFailures: 0\\n`);\n    });\n  });\n});\n\ntest('Falls back to transpileOnly when ts compiler returns emitSkipped', async () => {\n  const r = await exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --project tsconfig.json ./outside-rootDir/foo.js`, {\n    cwd: join(TEST_DIR, 'emit-skipped-fallback'),\n  });\n  expect(r.err).toBe(null);\n  expect(r.stdout).toBe('foo\\n');\n});\n\ntest.suite('node environment', (test) => {\n  test.suite('Sets argv and execArgv correctly in forked processes', (test) => {\n    forkTest(`node --no-warnings ${BIN_PATH_JS}`, BIN_PATH_JS, '--no-warnings');\n    forkTest(`${BIN_PATH}`, process.platform === 'win32' ? BIN_PATH_JS : BIN_PATH);\n\n    function forkTest(command: string, expectParentArgv0: string, nodeFlag?: string) {\n      test(command, async (t) => {\n        const r = await exec(`${command} --skipIgnore ./recursive-fork/index.ts argv2`);\n        expect(r.err).toBeNull();\n        expect(r.stderr).toBe('');\n        const generations = r.stdout.split('\\n');\n        const expectation = {\n          execArgv: [nodeFlag, BIN_PATH_JS, '--skipIgnore'].filter((v) => v),\n          argv: [\n            // Note: argv[0] is *always* BIN_PATH_JS in child & grandchild\n            expectParentArgv0,\n            resolve(TEST_DIR, 'recursive-fork/index.ts'),\n            'argv2',\n          ],\n        };\n        expect(JSON.parse(generations[0])).toMatchObject(expectation);\n        expectation.argv[0] = BIN_PATH_JS;\n        expect(JSON.parse(generations[1])).toMatchObject(expectation);\n        expect(JSON.parse(generations[2])).toMatchObject(expectation);\n      });\n    }\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/module-node/1778.spec.d.ts b/node_modules/ts-node/dist/test/module-node/1778.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/module-node/1778.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/module-node/1778.spec.js b/node_modules/ts-node/dist/test/module-node/1778.spec.js
new file mode 100644
index 0000000..0fd1e2f
--- /dev/null
+++ b/node_modules/ts-node/dist/test/module-node/1778.spec.js
@@ -0,0 +1,21 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const exec_1 = require("../helpers/exec");
+const helpers_1 = require("../helpers");
+const testlib_1 = require("../testlib");
+const path_1 = require("path");
+const exec = (0, exec_1.createExec)({
+    cwd: helpers_1.TEST_DIR,
+});
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+test.suite('Issue #1778: typechecker resolver should take importer\'s module type -- cjs or esm -- into account when resolving package.json "exports"', (test) => {
+    test.if(helpers_1.tsSupportsStableNodeNextNode16);
+    test('test', async () => {
+        const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} ./index.ts`, {
+            cwd: (0, path_1.join)(helpers_1.TEST_DIR, '1778'),
+        });
+        (0, testlib_1.expect)(r.err).toBe(null);
+        (0, testlib_1.expect)(r.stdout).toBe('{ esm: true }\n');
+    });
+});
+//# sourceMappingURL=1778.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/module-node/1778.spec.js.map b/node_modules/ts-node/dist/test/module-node/1778.spec.js.map
new file mode 100644
index 0000000..c05bb0a
--- /dev/null
+++ b/node_modules/ts-node/dist/test/module-node/1778.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"1778.spec.js","sourceRoot":"","sources":["../../../src/test/module-node/1778.spec.ts"],"names":[],"mappings":";;AAAA,0CAA6C;AAC7C,wCAAmH;AACnH,wCAA6C;AAC7C,+BAA4B;AAE5B,MAAM,IAAI,GAAG,IAAA,iBAAU,EAAC;IACtB,GAAG,EAAE,kBAAQ;CACd,CAAC,CAAC;AAEH,MAAM,IAAI,GAAG,IAAA,iBAAO,EAAC,mBAAS,CAAC,CAAC;AAEhC,IAAI,CAAC,KAAK,CACR,2IAA2I,EAC3I,CAAC,IAAI,EAAE,EAAE;IACP,IAAI,CAAC,EAAE,CAAC,wCAA8B,CAAC,CAAC;IACxC,IAAI,CAAC,MAAM,EAAE,KAAK,IAAI,EAAE;QACtB,MAAM,CAAC,GAAG,MAAM,IAAI,CAAC,GAAG,0CAAgC,aAAa,EAAE;YACrE,GAAG,EAAE,IAAA,WAAI,EAAC,kBAAQ,EAAE,MAAM,CAAC;SAC5B,CAAC,CAAC;QACH,IAAA,gBAAM,EAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACzB,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;IAC3C,CAAC,CAAC,CAAC;AACL,CAAC,CACF,CAAC","sourcesContent":["import { createExec } from '../helpers/exec';\nimport { ctxTsNode, TEST_DIR, tsSupportsStableNodeNextNode16, CMD_TS_NODE_WITHOUT_PROJECT_FLAG } from '../helpers';\nimport { context, expect } from '../testlib';\nimport { join } from 'path';\n\nconst exec = createExec({\n  cwd: TEST_DIR,\n});\n\nconst test = context(ctxTsNode);\n\ntest.suite(\n  'Issue #1778: typechecker resolver should take importer\\'s module type -- cjs or esm -- into account when resolving package.json \"exports\"',\n  (test) => {\n    test.if(tsSupportsStableNodeNextNode16);\n    test('test', async () => {\n      const r = await exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} ./index.ts`, {\n        cwd: join(TEST_DIR, '1778'),\n      });\n      expect(r.err).toBe(null);\n      expect(r.stdout).toBe('{ esm: true }\\n');\n    });\n  }\n);\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/module-node/module-node.spec.d.ts b/node_modules/ts-node/dist/test/module-node/module-node.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/module-node/module-node.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/module-node/module-node.spec.js b/node_modules/ts-node/dist/test/module-node/module-node.spec.js
new file mode 100644
index 0000000..55fc771
--- /dev/null
+++ b/node_modules/ts-node/dist/test/module-node/module-node.spec.js
@@ -0,0 +1,271 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const testlib_1 = require("../testlib");
+const helpers_1 = require("../helpers");
+const Path = require("path");
+const helpers_2 = require("../helpers");
+const exec_1 = require("../helpers/exec");
+const fs_fixture_builder_1 = require("@TypeStrong/fs-fixture-builder");
+const test = (0, testlib_1.context)(helpers_2.ctxTsNode);
+test.beforeEach(async () => {
+    (0, helpers_1.resetNodeEnvironment)();
+});
+// Declare one test case for each permutations of project configuration
+test.suite('TypeScript module=NodeNext and Node16', (test) => {
+    test.if(helpers_1.tsSupportsStableNodeNextNode16 && helpers_1.nodeSupportsImportingTransformedCjsFromEsm);
+    for (const allowJs of [true, false]) {
+        for (const typecheckMode of ['typecheck', 'transpileOnly', 'swc']) {
+            for (const packageJsonType of [undefined, 'commonjs', 'module']) {
+                for (const tsModuleMode of ['NodeNext', 'Node16']) {
+                    declareTest(test, {
+                        allowJs,
+                        packageJsonType,
+                        typecheckMode,
+                        tsModuleMode,
+                    });
+                }
+            }
+        }
+    }
+});
+function declareTest(test, testParams) {
+    const name = `package-json-type=${testParams.packageJsonType} allowJs=${testParams.allowJs} ${testParams.typecheckMode} tsconfig-module=${testParams.tsModuleMode}`;
+    test(name, async (t) => {
+        const proj = writeFixturesToFilesystem(name, testParams);
+        t.log(`Running this command: ( cd ${proj.cwd} ; ${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --esm ./index.mjs )`);
+        // All assertions happen within the fixture scripts
+        // Zero exit code indicates a passing test
+        const r = await (0, exec_1.exec)(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --esm ./index.mjs`, {
+            cwd: proj.cwd,
+        });
+        t.log(r.stdout);
+        t.log(r.stderr);
+        (0, testlib_1.expect)(r.err).toBe(null);
+        (0, testlib_1.expect)(r.stdout).toMatch(/done\n$/);
+    });
+}
+const packageJsonTypes = [undefined, 'commonjs', 'module'];
+const typecheckModes = ['typecheck', 'transpileOnly', 'swc'];
+const importStyles = ['static import', 'require', 'dynamic import', 'import = require'];
+const importExtension = ['js', 'ts', 'omitted'];
+const extensions = [
+    {
+        ext: 'cts',
+        jsEquivalentExt: 'cjs',
+        forcesCjs: true,
+    },
+    {
+        ext: 'cjs',
+        forcesCjs: true,
+        isJs: true,
+    },
+    {
+        ext: 'mts',
+        jsEquivalentExt: 'mjs',
+        forcesEsm: true,
+    },
+    {
+        ext: 'mjs',
+        forcesEsm: true,
+        isJs: true,
+    },
+    {
+        ext: 'ts',
+        jsEquivalentExt: 'js',
+        cjsAllowsOmittingExt: true,
+    },
+    {
+        ext: 'tsx',
+        jsEquivalentExt: 'js',
+        supportsJsx: true,
+        isJsxExt: true,
+        cjsAllowsOmittingExt: true,
+    },
+    {
+        ext: 'jsx',
+        jsEquivalentExt: 'js',
+        isJs: true,
+        supportsJsx: true,
+        isJsxExt: true,
+        cjsAllowsOmittingExt: true,
+    },
+    {
+        ext: 'js',
+        isJs: true,
+        cjsAllowsOmittingExt: true,
+    },
+];
+/**
+ * Describe how a given project config handles files with this extension.
+ * For example, projects with allowJs:false do not like .jsx
+ */
+function getExtensionTreatment(ext, testParams) {
+    // JSX and any TS extensions get compiled.  Everything is compiled in allowJs mode
+    const isCompiled = testParams.allowJs || !ext.isJs || ext.isJsxExt;
+    const isExecutedAsEsm = ext.forcesEsm || (!ext.forcesCjs && testParams.packageJsonType === 'module');
+    const isExecutedAsCjs = !isExecutedAsEsm;
+    // if allowJs:false, then .jsx files are not allowed
+    const isAllowed = !ext.isJsxExt || !ext.isJs || testParams.allowJs;
+    const canHaveJsxSyntax = ext.isJsxExt || (ext.supportsJsx && isCompiled);
+    return {
+        isCompiled,
+        isExecutedAsCjs,
+        isExecutedAsEsm,
+        isAllowed,
+        canHaveJsxSyntax,
+    };
+}
+function writeFixturesToFilesystem(name, testParams) {
+    const { packageJsonType, allowJs, typecheckMode, tsModuleMode } = testParams;
+    const proj = (0, fs_fixture_builder_1.project)(name.replace(/ /g, '_'));
+    proj.addJsonFile('package.json', {
+        type: packageJsonType,
+    });
+    proj.addJsonFile('tsconfig.json', {
+        compilerOptions: {
+            allowJs,
+            target: 'esnext',
+            module: tsModuleMode,
+            jsx: 'react',
+        },
+        'ts-node': {
+            transpileOnly: typecheckMode === 'transpileOnly' || undefined,
+            swc: typecheckMode === 'swc',
+            experimentalResolver: true,
+        },
+    });
+    const indexFile = (0, fs_fixture_builder_1.file)('index.mjs', ``);
+    proj.add(indexFile);
+    for (const importStyle of importStyles) {
+        for (const importerExtension of extensions) {
+            const importer = createImporter(proj, testParams, {
+                importStyle,
+                importerExtension,
+            });
+            if (!importer)
+                continue;
+            let importSpecifier = `./${Path.relative(proj.cwd, importer.path)}`;
+            importSpecifier = replaceExtension(importSpecifier, importerExtension.jsEquivalentExt ?? importerExtension.ext);
+            indexFile.content += `await import('${importSpecifier}');\n`;
+        }
+    }
+    indexFile.content += `console.log('done');\n`;
+    proj.rm();
+    proj.write();
+    return proj;
+}
+function createImporter(proj, testParams, importerParams) {
+    const { importStyle, importerExtension } = importerParams;
+    const name = `${importStyle} from ${importerExtension.ext}`;
+    const importerTreatment = getExtensionTreatment(importerExtension, testParams);
+    if (!importerTreatment.isAllowed)
+        return;
+    // import = require only allowed in non-js files
+    if (importStyle === 'import = require' && importerExtension.isJs)
+        return;
+    // const = require not allowed in ESM
+    if (importStyle === 'require' && importerTreatment.isExecutedAsEsm)
+        return;
+    // swc bug: import = require will not work in ESM, because swc does not emit necessary `__require = createRequire()`
+    if (testParams.typecheckMode === 'swc' && importStyle === 'import = require' && importerTreatment.isExecutedAsEsm)
+        return;
+    const importer = {
+        type: 'string',
+        path: `${name.replace(/ /g, '_')}.${importerExtension.ext}`,
+        imports: '',
+        assertions: '',
+        get content() {
+            return `
+          ${this.imports}
+          async function main() {
+            ${this.assertions}
+          }
+          main();
+        `;
+        },
+    };
+    proj.add(importer);
+    if (!importerExtension.isJs)
+        importer.imports += `export {};\n`;
+    for (const importeeExtension of extensions) {
+        const ci = createImportee(testParams, { importeeExtension });
+        if (!ci)
+            continue;
+        const { importee, treatment: importeeTreatment } = ci;
+        proj.add(importee);
+        // dynamic import is the only way to import ESM from CJS
+        if (importeeTreatment.isExecutedAsEsm && importerTreatment.isExecutedAsCjs && importStyle !== 'dynamic import')
+            continue;
+        // Cannot import = require an ESM file
+        if (importeeTreatment.isExecutedAsEsm && importStyle === 'import = require')
+            continue;
+        // Cannot use static imports in non-compiled non-ESM
+        if (importStyle === 'static import' && !importerTreatment.isCompiled && importerTreatment.isExecutedAsCjs)
+            continue;
+        let importSpecifier = `./${importeeExtension.ext}`;
+        if (!importeeExtension.cjsAllowsOmittingExt || (0, helpers_1.isOneOf)(importStyle, ['dynamic import', 'static import']))
+            importSpecifier += '.' + (importeeExtension.jsEquivalentExt ?? importeeExtension.ext);
+        switch (importStyle) {
+            case 'dynamic import':
+                importer.assertions += `const ${importeeExtension.ext} = await import('${importSpecifier}');\n`;
+                break;
+            case 'import = require':
+                importer.imports += `import ${importeeExtension.ext} = require('${importSpecifier}');\n`;
+                break;
+            case 'require':
+                importer.imports += `const ${importeeExtension.ext} = require('${importSpecifier}');\n`;
+                break;
+            case 'static import':
+                importer.imports += `import * as ${importeeExtension.ext} from '${importSpecifier}';\n`;
+                break;
+        }
+        // Check both namespace.ext and namespace.default.ext, because node can't detect named exports from files we transform
+        const namespaceAsAny = importerExtension.isJs ? importeeExtension.ext : `(${importeeExtension.ext} as any)`;
+        importer.assertions += `if((${importeeExtension.ext}.ext ?? ${namespaceAsAny}.default.ext) !== '${importeeExtension.ext}')\n`;
+        importer.assertions += `  throw new Error('Wrong export from importee: expected ${importeeExtension.ext} but got ' + ${importeeExtension.ext}.ext + '(importee has these keys: ' + Object.keys(${importeeExtension.ext}) + ')');\n`;
+    }
+    return importer;
+}
+function createImportee(testParams, importeeParams) {
+    const { importeeExtension } = importeeParams;
+    const importee = (0, fs_fixture_builder_1.file)(`${importeeExtension.ext}.${importeeExtension.ext}`);
+    const treatment = getExtensionTreatment(importeeExtension, testParams);
+    if (!treatment.isAllowed)
+        return;
+    if (treatment.isCompiled || treatment.isExecutedAsEsm) {
+        importee.content += `export const ext = '${importeeExtension.ext}';\n`;
+    }
+    else {
+        importee.content += `exports.ext = '${importeeExtension.ext}';\n`;
+    }
+    if (!importeeExtension.isJs) {
+        importee.content += `const testTsTypeSyntax: string = 'a string';\n`;
+    }
+    if (treatment.isExecutedAsCjs) {
+        importee.content += `if(typeof __filename !== 'string') throw new Error('expected file to be CJS but __filename is not declared');\n`;
+    }
+    else {
+        importee.content += `if(typeof __filename !== 'undefined') throw new Error('expected file to be ESM but __filename is declared');\n`;
+        importee.content += `if(typeof import.meta.url !== 'string') throw new Error('expected file to be ESM but import.meta.url is not declared');\n`;
+    }
+    if (treatment.canHaveJsxSyntax) {
+        importee.content += `
+          const React = {
+            createElement(tag, dunno, content) {
+              return {props: {children: [content]}};
+            }
+          };
+          const jsxTest = <a>Hello World</a>;
+          if(jsxTest?.props?.children[0] !== 'Hello World') throw new Error('Expected ${importeeExtension.ext} to support JSX but it did not.');
+        `;
+    }
+    return { importee, treatment };
+}
+function replaceExtension(path, ext) {
+    return Path.posix.format({
+        ...Path.parse(path),
+        ext: '.' + ext,
+        base: undefined,
+    });
+}
+//# sourceMappingURL=module-node.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/module-node/module-node.spec.js.map b/node_modules/ts-node/dist/test/module-node/module-node.spec.js.map
new file mode 100644
index 0000000..ccfdc70
--- /dev/null
+++ b/node_modules/ts-node/dist/test/module-node/module-node.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"module-node.spec.js","sourceRoot":"","sources":["../../../src/test/module-node/module-node.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect, context } from '../testlib';\nimport {\n  CMD_TS_NODE_WITHOUT_PROJECT_FLAG,\n  isOneOf,\n  nodeSupportsImportingTransformedCjsFromEsm,\n  resetNodeEnvironment,\n  tsSupportsStableNodeNextNode16,\n} from '../helpers';\nimport * as Path from 'path';\nimport { ctxTsNode } from '../helpers';\nimport { exec } from '../helpers/exec';\nimport { file, project, ProjectAPI as ProjectAPI, StringFile } from '@TypeStrong/fs-fixture-builder';\n\nconst test = context(ctxTsNode);\ntest.beforeEach(async () => {\n  resetNodeEnvironment();\n});\ntype Test = typeof test;\n\n// Declare one test case for each permutations of project configuration\ntest.suite('TypeScript module=NodeNext and Node16', (test) => {\n  test.if(tsSupportsStableNodeNextNode16 && nodeSupportsImportingTransformedCjsFromEsm);\n\n  for (const allowJs of [true, false]) {\n    for (const typecheckMode of ['typecheck', 'transpileOnly', 'swc'] as const) {\n      for (const packageJsonType of [undefined, 'commonjs', 'module'] as const) {\n        for (const tsModuleMode of ['NodeNext', 'Node16'] as const) {\n          declareTest(test, {\n            allowJs,\n            packageJsonType,\n            typecheckMode,\n            tsModuleMode,\n          });\n        }\n      }\n    }\n  }\n});\n\nfunction declareTest(test: Test, testParams: TestParams) {\n  const name = `package-json-type=${testParams.packageJsonType} allowJs=${testParams.allowJs} ${testParams.typecheckMode} tsconfig-module=${testParams.tsModuleMode}`;\n\n  test(name, async (t) => {\n    const proj = writeFixturesToFilesystem(name, testParams);\n\n    t.log(`Running this command: ( cd ${proj.cwd} ; ${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --esm ./index.mjs )`);\n\n    // All assertions happen within the fixture scripts\n    // Zero exit code indicates a passing test\n    const r = await exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} --esm ./index.mjs`, {\n      cwd: proj.cwd,\n    });\n    t.log(r.stdout);\n    t.log(r.stderr);\n    expect(r.err).toBe(null);\n    expect(r.stdout).toMatch(/done\\n$/);\n  });\n}\n\ntype PackageJsonType = typeof packageJsonTypes[number];\nconst packageJsonTypes = [undefined, 'commonjs', 'module'] as const;\nconst typecheckModes = ['typecheck', 'transpileOnly', 'swc'] as const;\nconst importStyles = ['static import', 'require', 'dynamic import', 'import = require'] as const;\nconst importExtension = ['js', 'ts', 'omitted'] as const;\n\ninterface Extension {\n  ext: string;\n  jsEquivalentExt?: string;\n  forcesCjs?: boolean;\n  forcesEsm?: boolean;\n  isJs?: boolean;\n  supportsJsx?: boolean;\n  isJsxExt?: boolean;\n  cjsAllowsOmittingExt?: boolean;\n}\nconst extensions: Extension[] = [\n  {\n    ext: 'cts',\n    jsEquivalentExt: 'cjs',\n    forcesCjs: true,\n  },\n  {\n    ext: 'cjs',\n    forcesCjs: true,\n    isJs: true,\n  },\n  {\n    ext: 'mts',\n    jsEquivalentExt: 'mjs',\n    forcesEsm: true,\n  },\n  {\n    ext: 'mjs',\n    forcesEsm: true,\n    isJs: true,\n  },\n  {\n    ext: 'ts',\n    jsEquivalentExt: 'js',\n    cjsAllowsOmittingExt: true,\n  },\n  {\n    ext: 'tsx',\n    jsEquivalentExt: 'js',\n    supportsJsx: true,\n    isJsxExt: true,\n    cjsAllowsOmittingExt: true,\n  },\n  {\n    ext: 'jsx',\n    jsEquivalentExt: 'js',\n    isJs: true,\n    supportsJsx: true,\n    isJsxExt: true,\n    cjsAllowsOmittingExt: true,\n  },\n  {\n    ext: 'js',\n    isJs: true,\n    cjsAllowsOmittingExt: true,\n  },\n];\n/**\n * Describe how a given project config handles files with this extension.\n * For example, projects with allowJs:false do not like .jsx\n */\nfunction getExtensionTreatment(ext: Extension, testParams: TestParams) {\n  // JSX and any TS extensions get compiled.  Everything is compiled in allowJs mode\n  const isCompiled = testParams.allowJs || !ext.isJs || ext.isJsxExt;\n  const isExecutedAsEsm = ext.forcesEsm || (!ext.forcesCjs && testParams.packageJsonType === 'module');\n  const isExecutedAsCjs = !isExecutedAsEsm;\n  // if allowJs:false, then .jsx files are not allowed\n  const isAllowed = !ext.isJsxExt || !ext.isJs || testParams.allowJs;\n  const canHaveJsxSyntax = ext.isJsxExt || (ext.supportsJsx && isCompiled);\n  return {\n    isCompiled,\n    isExecutedAsCjs,\n    isExecutedAsEsm,\n    isAllowed,\n    canHaveJsxSyntax,\n  };\n}\n\ninterface TestParams {\n  packageJsonType: PackageJsonType;\n  typecheckMode: typeof typecheckModes[number];\n  allowJs: boolean;\n  tsModuleMode: 'NodeNext' | 'Node16';\n}\n\ninterface ImporterParams {\n  importStyle: typeof importStyles[number];\n  importerExtension: typeof extensions[number];\n}\n\ninterface ImporteeParams {\n  importeeExtension: typeof extensions[number];\n}\n\nfunction writeFixturesToFilesystem(name: string, testParams: TestParams) {\n  const { packageJsonType, allowJs, typecheckMode, tsModuleMode } = testParams;\n\n  const proj = project(name.replace(/ /g, '_'));\n\n  proj.addJsonFile('package.json', {\n    type: packageJsonType,\n  });\n\n  proj.addJsonFile('tsconfig.json', {\n    compilerOptions: {\n      allowJs,\n      target: 'esnext',\n      module: tsModuleMode,\n      jsx: 'react',\n    },\n    'ts-node': {\n      transpileOnly: typecheckMode === 'transpileOnly' || undefined,\n      swc: typecheckMode === 'swc',\n      experimentalResolver: true,\n    },\n  });\n\n  const indexFile = file('index.mjs', ``);\n  proj.add(indexFile);\n\n  for (const importStyle of importStyles) {\n    for (const importerExtension of extensions) {\n      const importer = createImporter(proj, testParams, {\n        importStyle,\n        importerExtension,\n      });\n      if (!importer) continue;\n\n      let importSpecifier = `./${Path.relative(proj.cwd, importer.path)}`;\n      importSpecifier = replaceExtension(importSpecifier, importerExtension.jsEquivalentExt ?? importerExtension.ext);\n      indexFile.content += `await import('${importSpecifier}');\\n`;\n    }\n  }\n\n  indexFile.content += `console.log('done');\\n`;\n\n  proj.rm();\n  proj.write();\n  return proj;\n}\n\nfunction createImporter(proj: ProjectAPI, testParams: TestParams, importerParams: ImporterParams) {\n  const { importStyle, importerExtension } = importerParams;\n  const name = `${importStyle} from ${importerExtension.ext}`;\n\n  const importerTreatment = getExtensionTreatment(importerExtension, testParams);\n\n  if (!importerTreatment.isAllowed) return;\n  // import = require only allowed in non-js files\n  if (importStyle === 'import = require' && importerExtension.isJs) return;\n  // const = require not allowed in ESM\n  if (importStyle === 'require' && importerTreatment.isExecutedAsEsm) return;\n  // swc bug: import = require will not work in ESM, because swc does not emit necessary `__require = createRequire()`\n  if (testParams.typecheckMode === 'swc' && importStyle === 'import = require' && importerTreatment.isExecutedAsEsm)\n    return;\n\n  const importer = {\n    type: 'string',\n    path: `${name.replace(/ /g, '_')}.${importerExtension.ext}`,\n    imports: '',\n    assertions: '',\n    get content() {\n      return `\n          ${this.imports}\n          async function main() {\n            ${this.assertions}\n          }\n          main();\n        `;\n    },\n  };\n  proj.add(importer as StringFile);\n\n  if (!importerExtension.isJs) importer.imports += `export {};\\n`;\n\n  for (const importeeExtension of extensions) {\n    const ci = createImportee(testParams, { importeeExtension });\n    if (!ci) continue;\n    const { importee, treatment: importeeTreatment } = ci;\n    proj.add(importee);\n\n    // dynamic import is the only way to import ESM from CJS\n    if (importeeTreatment.isExecutedAsEsm && importerTreatment.isExecutedAsCjs && importStyle !== 'dynamic import')\n      continue;\n    // Cannot import = require an ESM file\n    if (importeeTreatment.isExecutedAsEsm && importStyle === 'import = require') continue;\n    // Cannot use static imports in non-compiled non-ESM\n    if (importStyle === 'static import' && !importerTreatment.isCompiled && importerTreatment.isExecutedAsCjs) continue;\n\n    let importSpecifier = `./${importeeExtension.ext}`;\n    if (!importeeExtension.cjsAllowsOmittingExt || isOneOf(importStyle, ['dynamic import', 'static import']))\n      importSpecifier += '.' + (importeeExtension.jsEquivalentExt ?? importeeExtension.ext);\n\n    switch (importStyle) {\n      case 'dynamic import':\n        importer.assertions += `const ${importeeExtension.ext} = await import('${importSpecifier}');\\n`;\n        break;\n      case 'import = require':\n        importer.imports += `import ${importeeExtension.ext} = require('${importSpecifier}');\\n`;\n        break;\n      case 'require':\n        importer.imports += `const ${importeeExtension.ext} = require('${importSpecifier}');\\n`;\n        break;\n      case 'static import':\n        importer.imports += `import * as ${importeeExtension.ext} from '${importSpecifier}';\\n`;\n        break;\n    }\n\n    // Check both namespace.ext and namespace.default.ext, because node can't detect named exports from files we transform\n    const namespaceAsAny = importerExtension.isJs ? importeeExtension.ext : `(${importeeExtension.ext} as any)`;\n    importer.assertions += `if((${importeeExtension.ext}.ext ?? ${namespaceAsAny}.default.ext) !== '${importeeExtension.ext}')\\n`;\n    importer.assertions += `  throw new Error('Wrong export from importee: expected ${importeeExtension.ext} but got ' + ${importeeExtension.ext}.ext + '(importee has these keys: ' + Object.keys(${importeeExtension.ext}) + ')');\\n`;\n  }\n  return importer;\n}\nfunction createImportee(testParams: TestParams, importeeParams: ImporteeParams) {\n  const { importeeExtension } = importeeParams;\n  const importee = file(`${importeeExtension.ext}.${importeeExtension.ext}`);\n  const treatment = getExtensionTreatment(importeeExtension, testParams);\n  if (!treatment.isAllowed) return;\n  if (treatment.isCompiled || treatment.isExecutedAsEsm) {\n    importee.content += `export const ext = '${importeeExtension.ext}';\\n`;\n  } else {\n    importee.content += `exports.ext = '${importeeExtension.ext}';\\n`;\n  }\n  if (!importeeExtension.isJs) {\n    importee.content += `const testTsTypeSyntax: string = 'a string';\\n`;\n  }\n  if (treatment.isExecutedAsCjs) {\n    importee.content += `if(typeof __filename !== 'string') throw new Error('expected file to be CJS but __filename is not declared');\\n`;\n  } else {\n    importee.content += `if(typeof __filename !== 'undefined') throw new Error('expected file to be ESM but __filename is declared');\\n`;\n    importee.content += `if(typeof import.meta.url !== 'string') throw new Error('expected file to be ESM but import.meta.url is not declared');\\n`;\n  }\n  if (treatment.canHaveJsxSyntax) {\n    importee.content += `\n          const React = {\n            createElement(tag, dunno, content) {\n              return {props: {children: [content]}};\n            }\n          };\n          const jsxTest = <a>Hello World</a>;\n          if(jsxTest?.props?.children[0] !== 'Hello World') throw new Error('Expected ${importeeExtension.ext} to support JSX but it did not.');\n        `;\n  }\n  return { importee, treatment };\n}\n\nfunction replaceExtension(path: string, ext: string) {\n  return Path.posix.format({\n    ...Path.parse(path),\n    ext: '.' + ext,\n    base: undefined,\n  });\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/package.spec.d.ts b/node_modules/ts-node/dist/test/package.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/package.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/package.spec.js b/node_modules/ts-node/dist/test/package.spec.js
new file mode 100644
index 0000000..0b5fc79
--- /dev/null
+++ b/node_modules/ts-node/dist/test/package.spec.js
@@ -0,0 +1,45 @@
+"use strict";
+// Verify the shape of the published tarball:
+// valid import specifiers
+// CLI commands on PATH
+// named exports
+Object.defineProperty(exports, "__esModule", { value: true });
+const helpers_1 = require("./helpers");
+const testlib_1 = require("./testlib");
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+test('should export the correct version', (t) => {
+    (0, testlib_1.expect)(t.context.tsNodeUnderTest.VERSION).toBe(require('../../package.json').version);
+});
+test('should export all CJS entrypoints', () => {
+    // Ensure our package.json "exports" declaration allows `require()`ing all our entrypoints
+    // https://github.com/TypeStrong/ts-node/pull/1026
+    helpers_1.testsDirRequire.resolve('ts-node');
+    // only reliably way to ask node for the root path of a dependency is Path.resolve(require.resolve('ts-node/package'), '..')
+    helpers_1.testsDirRequire.resolve('ts-node/package');
+    helpers_1.testsDirRequire.resolve('ts-node/package.json');
+    // All bin entrypoints for people who need to augment our CLI: `node -r otherstuff ./node_modules/ts-node/dist/bin`
+    helpers_1.testsDirRequire.resolve('ts-node/dist/bin');
+    helpers_1.testsDirRequire.resolve('ts-node/dist/bin.js');
+    helpers_1.testsDirRequire.resolve('ts-node/dist/bin-transpile');
+    helpers_1.testsDirRequire.resolve('ts-node/dist/bin-transpile.js');
+    helpers_1.testsDirRequire.resolve('ts-node/dist/bin-script');
+    helpers_1.testsDirRequire.resolve('ts-node/dist/bin-script.js');
+    helpers_1.testsDirRequire.resolve('ts-node/dist/bin-cwd');
+    helpers_1.testsDirRequire.resolve('ts-node/dist/bin-cwd.js');
+    // Must be `require()`able obviously
+    helpers_1.testsDirRequire.resolve('ts-node/register');
+    helpers_1.testsDirRequire.resolve('ts-node/register/files');
+    helpers_1.testsDirRequire.resolve('ts-node/register/transpile-only');
+    helpers_1.testsDirRequire.resolve('ts-node/register/type-check');
+    // `node --loader ts-node/esm`
+    helpers_1.testsDirRequire.resolve('ts-node/esm');
+    helpers_1.testsDirRequire.resolve('ts-node/esm.mjs');
+    helpers_1.testsDirRequire.resolve('ts-node/esm/transpile-only');
+    helpers_1.testsDirRequire.resolve('ts-node/esm/transpile-only.mjs');
+    helpers_1.testsDirRequire.resolve('ts-node/transpilers/swc');
+    helpers_1.testsDirRequire.resolve('ts-node/transpilers/swc-experimental');
+    helpers_1.testsDirRequire.resolve('ts-node/node14/tsconfig.json');
+    helpers_1.testsDirRequire.resolve('ts-node/node16/tsconfig.json');
+    helpers_1.testsDirRequire.resolve('ts-node/node18/tsconfig.json');
+});
+//# sourceMappingURL=package.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/package.spec.js.map b/node_modules/ts-node/dist/test/package.spec.js.map
new file mode 100644
index 0000000..4cda268
--- /dev/null
+++ b/node_modules/ts-node/dist/test/package.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"package.spec.js","sourceRoot":"","sources":["../../src/test/package.spec.ts"],"names":[],"mappings":";AAAA,6CAA6C;AAC7C,0BAA0B;AAC1B,uBAAuB;AACvB,gBAAgB;;AAEhB,uCAAuD;AACvD,uCAA4C;AAE5C,MAAM,IAAI,GAAG,IAAA,iBAAO,EAAC,mBAAS,CAAC,CAAC;AAEhC,IAAI,CAAC,mCAAmC,EAAE,CAAC,CAAC,EAAE,EAAE;IAC9C,IAAA,gBAAM,EAAC,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC,CAAC,OAAO,CAAC,CAAC;AACxF,CAAC,CAAC,CAAC;AACH,IAAI,CAAC,mCAAmC,EAAE,GAAG,EAAE;IAC7C,0FAA0F;IAC1F,kDAAkD;IAElD,yBAAe,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IAEnC,4HAA4H;IAC5H,yBAAe,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;IAC3C,yBAAe,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAAC;IAEhD,mHAAmH;IACnH,yBAAe,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;IAC5C,yBAAe,CAAC,OAAO,CAAC,qBAAqB,CAAC,CAAC;IAC/C,yBAAe,CAAC,OAAO,CAAC,4BAA4B,CAAC,CAAC;IACtD,yBAAe,CAAC,OAAO,CAAC,+BAA+B,CAAC,CAAC;IACzD,yBAAe,CAAC,OAAO,CAAC,yBAAyB,CAAC,CAAC;IACnD,yBAAe,CAAC,OAAO,CAAC,4BAA4B,CAAC,CAAC;IACtD,yBAAe,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAAC;IAChD,yBAAe,CAAC,OAAO,CAAC,yBAAyB,CAAC,CAAC;IAEnD,oCAAoC;IACpC,yBAAe,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;IAC5C,yBAAe,CAAC,OAAO,CAAC,wBAAwB,CAAC,CAAC;IAClD,yBAAe,CAAC,OAAO,CAAC,iCAAiC,CAAC,CAAC;IAC3D,yBAAe,CAAC,OAAO,CAAC,6BAA6B,CAAC,CAAC;IAEvD,8BAA8B;IAC9B,yBAAe,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACvC,yBAAe,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;IAC3C,yBAAe,CAAC,OAAO,CAAC,4BAA4B,CAAC,CAAC;IACtD,yBAAe,CAAC,OAAO,CAAC,gCAAgC,CAAC,CAAC;IAE1D,yBAAe,CAAC,OAAO,CAAC,yBAAyB,CAAC,CAAC;IACnD,yBAAe,CAAC,OAAO,CAAC,sCAAsC,CAAC,CAAC;IAEhE,yBAAe,CAAC,OAAO,CAAC,8BAA8B,CAAC,CAAC;IACxD,yBAAe,CAAC,OAAO,CAAC,8BAA8B,CAAC,CAAC;IACxD,yBAAe,CAAC,OAAO,CAAC,8BAA8B,CAAC,CAAC;AAC1D,CAAC,CAAC,CAAC","sourcesContent":["// Verify the shape of the published tarball:\n// valid import specifiers\n// CLI commands on PATH\n// named exports\n\nimport { ctxTsNode, testsDirRequire } from './helpers';\nimport { context, expect } from './testlib';\n\nconst test = context(ctxTsNode);\n\ntest('should export the correct version', (t) => {\n  expect(t.context.tsNodeUnderTest.VERSION).toBe(require('../../package.json').version);\n});\ntest('should export all CJS entrypoints', () => {\n  // Ensure our package.json \"exports\" declaration allows `require()`ing all our entrypoints\n  // https://github.com/TypeStrong/ts-node/pull/1026\n\n  testsDirRequire.resolve('ts-node');\n\n  // only reliably way to ask node for the root path of a dependency is Path.resolve(require.resolve('ts-node/package'), '..')\n  testsDirRequire.resolve('ts-node/package');\n  testsDirRequire.resolve('ts-node/package.json');\n\n  // All bin entrypoints for people who need to augment our CLI: `node -r otherstuff ./node_modules/ts-node/dist/bin`\n  testsDirRequire.resolve('ts-node/dist/bin');\n  testsDirRequire.resolve('ts-node/dist/bin.js');\n  testsDirRequire.resolve('ts-node/dist/bin-transpile');\n  testsDirRequire.resolve('ts-node/dist/bin-transpile.js');\n  testsDirRequire.resolve('ts-node/dist/bin-script');\n  testsDirRequire.resolve('ts-node/dist/bin-script.js');\n  testsDirRequire.resolve('ts-node/dist/bin-cwd');\n  testsDirRequire.resolve('ts-node/dist/bin-cwd.js');\n\n  // Must be `require()`able obviously\n  testsDirRequire.resolve('ts-node/register');\n  testsDirRequire.resolve('ts-node/register/files');\n  testsDirRequire.resolve('ts-node/register/transpile-only');\n  testsDirRequire.resolve('ts-node/register/type-check');\n\n  // `node --loader ts-node/esm`\n  testsDirRequire.resolve('ts-node/esm');\n  testsDirRequire.resolve('ts-node/esm.mjs');\n  testsDirRequire.resolve('ts-node/esm/transpile-only');\n  testsDirRequire.resolve('ts-node/esm/transpile-only.mjs');\n\n  testsDirRequire.resolve('ts-node/transpilers/swc');\n  testsDirRequire.resolve('ts-node/transpilers/swc-experimental');\n\n  testsDirRequire.resolve('ts-node/node14/tsconfig.json');\n  testsDirRequire.resolve('ts-node/node16/tsconfig.json');\n  testsDirRequire.resolve('ts-node/node18/tsconfig.json');\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/pluggable-dep-resolution.spec.d.ts b/node_modules/ts-node/dist/test/pluggable-dep-resolution.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/pluggable-dep-resolution.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/pluggable-dep-resolution.spec.js b/node_modules/ts-node/dist/test/pluggable-dep-resolution.spec.js
new file mode 100644
index 0000000..714b8be
--- /dev/null
+++ b/node_modules/ts-node/dist/test/pluggable-dep-resolution.spec.js
@@ -0,0 +1,65 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const testlib_1 = require("./testlib");
+const helpers_1 = require("./helpers");
+const expect = require("expect");
+const path_1 = require("path");
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+test.suite('Pluggable dependency (compiler, transpiler, swc backend) is require()d relative to the tsconfig file that declares it', (test) => {
+    test.serial();
+    // The use-case we want to support:
+    //
+    // User shares their tsconfig across multiple projects as an npm module named "shared-config", similar to @tsconfig/bases
+    // In their npm module
+    //     They have tsconfig.json with `swc: true` or `compiler: "ts-patch"` or something like that
+    //     The module declares a dependency on a known working version of @swc/core, or ts-patch, or something like that.
+    // They use this reusable config via `npm install shared-config` and `"extends": "shared-config/tsconfig.json"`
+    //
+    // ts-node should resolve ts-patch or @swc/core relative to the extended tsconfig
+    // to ensure we use the known working versions.
+    const macro = test.macro((config, expected) => [
+        `${config} uses ${expected}`,
+        async (t) => {
+            t.teardown(helpers_1.resetNodeEnvironment);
+            // A bit hacky: we've monkey-patched the various dependencies to either:
+            // a) return transpiled output we expect
+            // b) throw an error that we expect
+            // Either way, we've proven that the correct dependency is used, which
+            // is our goal.
+            let output;
+            try {
+                output = t.context.tsNodeUnderTest
+                    .create({
+                    project: (0, path_1.resolve)(helpers_1.TEST_DIR, 'pluggable-dep-resolution', config),
+                })
+                    .compile('', 'index.ts');
+            }
+            catch (e) {
+                expect(e).toBe(`emit from ${expected}`);
+                return;
+            }
+            expect(output).toContain(`emit from ${expected}\n`);
+        },
+    ]);
+    test(macro, 'tsconfig-custom-compiler.json', 'root custom compiler');
+    test(macro, 'tsconfig-custom-transpiler.json', 'root custom transpiler');
+    test(macro, 'tsconfig-swc-custom-backend.json', 'root custom swc backend');
+    test(macro, 'tsconfig-swc-core.json', 'root @swc/core');
+    test(macro, 'tsconfig-swc-wasm.json', 'root @swc/wasm');
+    test(macro, 'tsconfig-swc.json', 'root @swc/core');
+    test(macro, 'node_modules/shared-config/tsconfig-custom-compiler.json', 'shared-config custom compiler');
+    test(macro, 'node_modules/shared-config/tsconfig-custom-transpiler.json', 'shared-config custom transpiler');
+    test(macro, 'node_modules/shared-config/tsconfig-swc-custom-backend.json', 'shared-config custom swc backend');
+    test(macro, 'node_modules/shared-config/tsconfig-swc-core.json', 'shared-config @swc/core');
+    test(macro, 'node_modules/shared-config/tsconfig-swc-wasm.json', 'shared-config @swc/wasm');
+    test(macro, 'node_modules/shared-config/tsconfig-swc.json', 'shared-config @swc/core');
+    test.suite('"extends"', (test) => {
+        test(macro, 'tsconfig-extend-custom-compiler.json', 'shared-config custom compiler');
+        test(macro, 'tsconfig-extend-custom-transpiler.json', 'shared-config custom transpiler');
+        test(macro, 'tsconfig-extend-swc-custom-backend.json', 'shared-config custom swc backend');
+        test(macro, 'tsconfig-extend-swc-core.json', 'shared-config @swc/core');
+        test(macro, 'tsconfig-extend-swc-wasm.json', 'shared-config @swc/wasm');
+        test(macro, 'tsconfig-extend-swc.json', 'shared-config @swc/core');
+    });
+});
+//# sourceMappingURL=pluggable-dep-resolution.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/pluggable-dep-resolution.spec.js.map b/node_modules/ts-node/dist/test/pluggable-dep-resolution.spec.js.map
new file mode 100644
index 0000000..c8dbc01
--- /dev/null
+++ b/node_modules/ts-node/dist/test/pluggable-dep-resolution.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"pluggable-dep-resolution.spec.js","sourceRoot":"","sources":["../../src/test/pluggable-dep-resolution.spec.ts"],"names":[],"mappings":";;AAAA,uCAAoC;AACpC,uCAAsE;AACtE,iCAAiC;AACjC,+BAA+B;AAE/B,MAAM,IAAI,GAAG,IAAA,iBAAO,EAAC,mBAAS,CAAC,CAAC;AAEhC,IAAI,CAAC,KAAK,CACR,uHAAuH,EACvH,CAAC,IAAI,EAAE,EAAE;IACP,IAAI,CAAC,MAAM,EAAE,CAAC;IAEd,mCAAmC;IACnC,EAAE;IACF,yHAAyH;IACzH,sBAAsB;IACtB,gGAAgG;IAChG,qHAAqH;IACrH,+GAA+G;IAC/G,EAAE;IACF,iFAAiF;IACjF,+CAA+C;IAE/C,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,MAAc,EAAE,QAAgB,EAAE,EAAE,CAAC;QAC7D,GAAG,MAAM,SAAS,QAAQ,EAAE;QAC5B,KAAK,EAAE,CAAC,EAAE,EAAE;YACV,CAAC,CAAC,QAAQ,CAAC,8BAAoB,CAAC,CAAC;YAEjC,wEAAwE;YACxE,wCAAwC;YACxC,mCAAmC;YACnC,sEAAsE;YACtE,eAAe;YACf,IAAI,MAAc,CAAC;YACnB,IAAI;gBACF,MAAM,GAAG,CAAC,CAAC,OAAO,CAAC,eAAe;qBAC/B,MAAM,CAAC;oBACN,OAAO,EAAE,IAAA,cAAO,EAAC,kBAAQ,EAAE,0BAA0B,EAAE,MAAM,CAAC;iBAC/D,CAAC;qBACD,OAAO,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;aAC5B;YAAC,OAAO,CAAC,EAAE;gBACV,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,QAAQ,EAAE,CAAC,CAAC;gBACxC,OAAO;aACR;YAED,MAAM,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,aAAa,QAAQ,IAAI,CAAC,CAAC;QACtD,CAAC;KACF,CAAC,CAAC;IAEH,IAAI,CAAC,KAAK,EAAE,+BAA+B,EAAE,sBAAsB,CAAC,CAAC;IACrE,IAAI,CAAC,KAAK,EAAE,iCAAiC,EAAE,wBAAwB,CAAC,CAAC;IACzE,IAAI,CAAC,KAAK,EAAE,kCAAkC,EAAE,yBAAyB,CAAC,CAAC;IAC3E,IAAI,CAAC,KAAK,EAAE,wBAAwB,EAAE,gBAAgB,CAAC,CAAC;IACxD,IAAI,CAAC,KAAK,EAAE,wBAAwB,EAAE,gBAAgB,CAAC,CAAC;IACxD,IAAI,CAAC,KAAK,EAAE,mBAAmB,EAAE,gBAAgB,CAAC,CAAC;IAEnD,IAAI,CAAC,KAAK,EAAE,0DAA0D,EAAE,+BAA+B,CAAC,CAAC;IACzG,IAAI,CAAC,KAAK,EAAE,4DAA4D,EAAE,iCAAiC,CAAC,CAAC;IAC7G,IAAI,CAAC,KAAK,EAAE,6DAA6D,EAAE,kCAAkC,CAAC,CAAC;IAC/G,IAAI,CAAC,KAAK,EAAE,mDAAmD,EAAE,yBAAyB,CAAC,CAAC;IAC5F,IAAI,CAAC,KAAK,EAAE,mDAAmD,EAAE,yBAAyB,CAAC,CAAC;IAC5F,IAAI,CAAC,KAAK,EAAE,8CAA8C,EAAE,yBAAyB,CAAC,CAAC;IAEvF,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,IAAI,EAAE,EAAE;QAC/B,IAAI,CAAC,KAAK,EAAE,sCAAsC,EAAE,+BAA+B,CAAC,CAAC;QACrF,IAAI,CAAC,KAAK,EAAE,wCAAwC,EAAE,iCAAiC,CAAC,CAAC;QACzF,IAAI,CAAC,KAAK,EAAE,yCAAyC,EAAE,kCAAkC,CAAC,CAAC;QAC3F,IAAI,CAAC,KAAK,EAAE,+BAA+B,EAAE,yBAAyB,CAAC,CAAC;QACxE,IAAI,CAAC,KAAK,EAAE,+BAA+B,EAAE,yBAAyB,CAAC,CAAC;QACxE,IAAI,CAAC,KAAK,EAAE,0BAA0B,EAAE,yBAAyB,CAAC,CAAC;IACrE,CAAC,CAAC,CAAC;AACL,CAAC,CACF,CAAC","sourcesContent":["import { context } from './testlib';\nimport { ctxTsNode, resetNodeEnvironment, TEST_DIR } from './helpers';\nimport * as expect from 'expect';\nimport { resolve } from 'path';\n\nconst test = context(ctxTsNode);\n\ntest.suite(\n  'Pluggable dependency (compiler, transpiler, swc backend) is require()d relative to the tsconfig file that declares it',\n  (test) => {\n    test.serial();\n\n    // The use-case we want to support:\n    //\n    // User shares their tsconfig across multiple projects as an npm module named \"shared-config\", similar to @tsconfig/bases\n    // In their npm module\n    //     They have tsconfig.json with `swc: true` or `compiler: \"ts-patch\"` or something like that\n    //     The module declares a dependency on a known working version of @swc/core, or ts-patch, or something like that.\n    // They use this reusable config via `npm install shared-config` and `\"extends\": \"shared-config/tsconfig.json\"`\n    //\n    // ts-node should resolve ts-patch or @swc/core relative to the extended tsconfig\n    // to ensure we use the known working versions.\n\n    const macro = test.macro((config: string, expected: string) => [\n      `${config} uses ${expected}`,\n      async (t) => {\n        t.teardown(resetNodeEnvironment);\n\n        // A bit hacky: we've monkey-patched the various dependencies to either:\n        // a) return transpiled output we expect\n        // b) throw an error that we expect\n        // Either way, we've proven that the correct dependency is used, which\n        // is our goal.\n        let output: string;\n        try {\n          output = t.context.tsNodeUnderTest\n            .create({\n              project: resolve(TEST_DIR, 'pluggable-dep-resolution', config),\n            })\n            .compile('', 'index.ts');\n        } catch (e) {\n          expect(e).toBe(`emit from ${expected}`);\n          return;\n        }\n\n        expect(output).toContain(`emit from ${expected}\\n`);\n      },\n    ]);\n\n    test(macro, 'tsconfig-custom-compiler.json', 'root custom compiler');\n    test(macro, 'tsconfig-custom-transpiler.json', 'root custom transpiler');\n    test(macro, 'tsconfig-swc-custom-backend.json', 'root custom swc backend');\n    test(macro, 'tsconfig-swc-core.json', 'root @swc/core');\n    test(macro, 'tsconfig-swc-wasm.json', 'root @swc/wasm');\n    test(macro, 'tsconfig-swc.json', 'root @swc/core');\n\n    test(macro, 'node_modules/shared-config/tsconfig-custom-compiler.json', 'shared-config custom compiler');\n    test(macro, 'node_modules/shared-config/tsconfig-custom-transpiler.json', 'shared-config custom transpiler');\n    test(macro, 'node_modules/shared-config/tsconfig-swc-custom-backend.json', 'shared-config custom swc backend');\n    test(macro, 'node_modules/shared-config/tsconfig-swc-core.json', 'shared-config @swc/core');\n    test(macro, 'node_modules/shared-config/tsconfig-swc-wasm.json', 'shared-config @swc/wasm');\n    test(macro, 'node_modules/shared-config/tsconfig-swc.json', 'shared-config @swc/core');\n\n    test.suite('\"extends\"', (test) => {\n      test(macro, 'tsconfig-extend-custom-compiler.json', 'shared-config custom compiler');\n      test(macro, 'tsconfig-extend-custom-transpiler.json', 'shared-config custom transpiler');\n      test(macro, 'tsconfig-extend-swc-custom-backend.json', 'shared-config custom swc backend');\n      test(macro, 'tsconfig-extend-swc-core.json', 'shared-config @swc/core');\n      test(macro, 'tsconfig-extend-swc-wasm.json', 'shared-config @swc/wasm');\n      test(macro, 'tsconfig-extend-swc.json', 'shared-config @swc/core');\n    });\n  }\n);\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/register.spec.d.ts b/node_modules/ts-node/dist/test/register.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/register.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/register.spec.js b/node_modules/ts-node/dist/test/register.spec.js
new file mode 100644
index 0000000..8fc365a
--- /dev/null
+++ b/node_modules/ts-node/dist/test/register.spec.js
@@ -0,0 +1,149 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+require("lodash");
+const helpers_1 = require("./helpers");
+const testlib_1 = require("./testlib");
+const exp = require("expect");
+const path_1 = require("path");
+const proxyquire = require("proxyquire");
+const SOURCE_MAP_REGEXP = /\/\/# sourceMappingURL=data:application\/json;charset=utf\-8;base64,[\w\+]+=*$/;
+const createOptions = {
+    project: helpers_1.PROJECT_TRANSPILE_ONLY,
+    compilerOptions: {
+        jsx: 'preserve',
+    },
+};
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode).context(async (t) => {
+    return {
+        moduleTestPath: (0, path_1.resolve)(__dirname, '../../tests/module.ts'),
+        service: t.context.tsNodeUnderTest.create(createOptions),
+    };
+});
+test.beforeEach(async (t) => {
+    // Un-install all hook and remove our test module from cache
+    (0, helpers_1.resetNodeEnvironment)();
+    delete require.cache[t.context.moduleTestPath];
+    // Paranoid check that we are truly uninstalled
+    exp(() => require(t.context.moduleTestPath)).toThrow("Unexpected token 'export'");
+});
+test.serial();
+test('create() does not register()', async (t) => {
+    // nyc sets its own `require.extensions` hooks; to truly detect if we're
+    // installed we must attempt to load a TS file
+    t.context.tsNodeUnderTest.create(createOptions);
+    // This error indicates node attempted to run the code as .js
+    exp(() => require(t.context.moduleTestPath)).toThrow("Unexpected token 'export'");
+});
+test('register(options) is shorthand for register(create(options))', (t) => {
+    t.context.tsNodeUnderTest.register(createOptions);
+    require(t.context.moduleTestPath);
+});
+test('register(service) registers a previously-created service', (t) => {
+    t.context.tsNodeUnderTest.register(t.context.service);
+    require(t.context.moduleTestPath);
+});
+test.suite('register(create(options))', (test) => {
+    test.beforeEach(async (t) => {
+        // Re-enable project for every test.
+        t.context.service.enabled(true);
+        t.context.tsNodeUnderTest.register(t.context.service);
+        t.context.service.installSourceMapSupport();
+    });
+    test('should be able to require typescript', ({ context: { moduleTestPath } }) => {
+        const m = require(moduleTestPath);
+        (0, testlib_1.expect)(m.example('foo')).toBe('FOO');
+    });
+    test('should support dynamically disabling', ({ context: { service, moduleTestPath } }) => {
+        delete require.cache[moduleTestPath];
+        (0, testlib_1.expect)(service.enabled(false)).toBe(false);
+        (0, testlib_1.expect)(() => require(moduleTestPath)).toThrow(/Unexpected token/);
+        delete require.cache[moduleTestPath];
+        (0, testlib_1.expect)(service.enabled()).toBe(false);
+        (0, testlib_1.expect)(() => require(moduleTestPath)).toThrow(/Unexpected token/);
+        delete require.cache[moduleTestPath];
+        (0, testlib_1.expect)(service.enabled(true)).toBe(true);
+        (0, testlib_1.expect)(() => require(moduleTestPath)).not.toThrow();
+        delete require.cache[moduleTestPath];
+        (0, testlib_1.expect)(service.enabled()).toBe(true);
+        (0, testlib_1.expect)(() => require(moduleTestPath)).not.toThrow();
+    });
+    test('should compile through js and ts', () => {
+        const m = require('../../tests/complex');
+        (0, testlib_1.expect)(m.example()).toBe('example');
+    });
+    test('should work with proxyquire', () => {
+        const m = proxyquire('../../tests/complex', {
+            './example': 'hello',
+        });
+        (0, testlib_1.expect)(m.example()).toBe('hello');
+    });
+    test('should work with `require.cache`', () => {
+        const { example1, example2 } = require('../../tests/require-cache');
+        (0, testlib_1.expect)(example1).not.toBe(example2);
+    });
+    test('should use source maps', async () => {
+        try {
+            require('../../tests/throw error');
+        }
+        catch (error) {
+            exp(error.stack).toMatch(['Error: this is a demo', `    at Foo.bar (${(0, path_1.join)(helpers_1.TEST_DIR, './throw error.ts')}:100:17)`].join('\n'));
+        }
+    });
+    test.suite('JSX preserve', (test) => {
+        let compiled;
+        test.before(async () => {
+            const old = require.extensions['.tsx'];
+            require.extensions['.tsx'] = (m, fileName) => {
+                const _compile = m._compile;
+                m._compile = function (code, fileName) {
+                    compiled = code;
+                    return _compile.call(this, code, fileName);
+                };
+                return old(m, fileName);
+            };
+        });
+        test('should use source maps', async (t) => {
+            try {
+                require('../../tests/with-jsx.tsx');
+            }
+            catch (error) {
+                (0, testlib_1.expect)(error.stack).toMatch('SyntaxError: Unexpected token');
+            }
+            (0, testlib_1.expect)(compiled).toMatch(SOURCE_MAP_REGEXP);
+        });
+    });
+});
+test('should support compiler scopes w/multiple registered compiler services at once', (t) => {
+    const { moduleTestPath, tsNodeUnderTest } = t.context;
+    const calls = [];
+    const compilers = [
+        tsNodeUnderTest.register({
+            projectSearchDir: (0, path_1.join)(helpers_1.TEST_DIR, 'scope/a'),
+            scopeDir: (0, path_1.join)(helpers_1.TEST_DIR, 'scope/a'),
+            scope: true,
+        }),
+        tsNodeUnderTest.register({
+            projectSearchDir: (0, path_1.join)(helpers_1.TEST_DIR, 'scope/a'),
+            scopeDir: (0, path_1.join)(helpers_1.TEST_DIR, 'scope/b'),
+            scope: true,
+        }),
+    ];
+    compilers.forEach((c) => {
+        const old = c.compile;
+        c.compile = (code, fileName, lineOffset) => {
+            calls.push(fileName);
+            return old(code, fileName, lineOffset);
+        };
+    });
+    try {
+        (0, testlib_1.expect)(require('../../tests/scope/a').ext).toBe('.ts');
+        (0, testlib_1.expect)(require('../../tests/scope/b').ext).toBe('.ts');
+    }
+    finally {
+        compilers.forEach((c) => c.enabled(false));
+    }
+    (0, testlib_1.expect)(calls).toEqual([(0, path_1.join)(helpers_1.TEST_DIR, 'scope/a/index.ts'), (0, path_1.join)(helpers_1.TEST_DIR, 'scope/b/index.ts')]);
+    delete require.cache[moduleTestPath];
+    (0, testlib_1.expect)(() => require(moduleTestPath)).toThrow();
+});
+//# sourceMappingURL=register.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/register.spec.js.map b/node_modules/ts-node/dist/test/register.spec.js.map
new file mode 100644
index 0000000..a9520d6
--- /dev/null
+++ b/node_modules/ts-node/dist/test/register.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"register.spec.js","sourceRoot":"","sources":["../../src/test/register.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { once } from 'lodash';\nimport { ctxTsNode, PROJECT_TRANSPILE_ONLY, resetNodeEnvironment, TEST_DIR, tsNodeTypes } from './helpers';\nimport { context, expect } from './testlib';\nimport * as exp from 'expect';\nimport { join, resolve } from 'path';\nimport proxyquire = require('proxyquire');\n\nconst SOURCE_MAP_REGEXP = /\\/\\/# sourceMappingURL=data:application\\/json;charset=utf\\-8;base64,[\\w\\+]+=*$/;\n\nconst createOptions: tsNodeTypes.CreateOptions = {\n  project: PROJECT_TRANSPILE_ONLY,\n  compilerOptions: {\n    jsx: 'preserve',\n  },\n};\n\nconst test = context(ctxTsNode).context(async (t) => {\n  return {\n    moduleTestPath: resolve(__dirname, '../../tests/module.ts'),\n    service: t.context.tsNodeUnderTest.create(createOptions),\n  };\n});\ntest.beforeEach(async (t) => {\n  // Un-install all hook and remove our test module from cache\n  resetNodeEnvironment();\n  delete require.cache[t.context.moduleTestPath];\n  // Paranoid check that we are truly uninstalled\n  exp(() => require(t.context.moduleTestPath)).toThrow(\"Unexpected token 'export'\");\n});\ntest.serial();\n\ntest('create() does not register()', async (t) => {\n  // nyc sets its own `require.extensions` hooks; to truly detect if we're\n  // installed we must attempt to load a TS file\n  t.context.tsNodeUnderTest.create(createOptions);\n  // This error indicates node attempted to run the code as .js\n  exp(() => require(t.context.moduleTestPath)).toThrow(\"Unexpected token 'export'\");\n});\n\ntest('register(options) is shorthand for register(create(options))', (t) => {\n  t.context.tsNodeUnderTest.register(createOptions);\n  require(t.context.moduleTestPath);\n});\n\ntest('register(service) registers a previously-created service', (t) => {\n  t.context.tsNodeUnderTest.register(t.context.service);\n  require(t.context.moduleTestPath);\n});\n\ntest.suite('register(create(options))', (test) => {\n  test.beforeEach(async (t) => {\n    // Re-enable project for every test.\n    t.context.service.enabled(true);\n    t.context.tsNodeUnderTest.register(t.context.service);\n    t.context.service.installSourceMapSupport();\n  });\n\n  test('should be able to require typescript', ({ context: { moduleTestPath } }) => {\n    const m = require(moduleTestPath);\n\n    expect(m.example('foo')).toBe('FOO');\n  });\n\n  test('should support dynamically disabling', ({ context: { service, moduleTestPath } }) => {\n    delete require.cache[moduleTestPath];\n\n    expect(service.enabled(false)).toBe(false);\n    expect(() => require(moduleTestPath)).toThrow(/Unexpected token/);\n\n    delete require.cache[moduleTestPath];\n\n    expect(service.enabled()).toBe(false);\n    expect(() => require(moduleTestPath)).toThrow(/Unexpected token/);\n\n    delete require.cache[moduleTestPath];\n\n    expect(service.enabled(true)).toBe(true);\n    expect(() => require(moduleTestPath)).not.toThrow();\n\n    delete require.cache[moduleTestPath];\n\n    expect(service.enabled()).toBe(true);\n    expect(() => require(moduleTestPath)).not.toThrow();\n  });\n\n  test('should compile through js and ts', () => {\n    const m = require('../../tests/complex');\n\n    expect(m.example()).toBe('example');\n  });\n\n  test('should work with proxyquire', () => {\n    const m = proxyquire('../../tests/complex', {\n      './example': 'hello',\n    });\n\n    expect(m.example()).toBe('hello');\n  });\n\n  test('should work with `require.cache`', () => {\n    const { example1, example2 } = require('../../tests/require-cache');\n\n    expect(example1).not.toBe(example2);\n  });\n\n  test('should use source maps', async () => {\n    try {\n      require('../../tests/throw error');\n    } catch (error: any) {\n      exp(error.stack).toMatch(\n        ['Error: this is a demo', `    at Foo.bar (${join(TEST_DIR, './throw error.ts')}:100:17)`].join('\\n')\n      );\n    }\n  });\n\n  test.suite('JSX preserve', (test) => {\n    let compiled: string;\n\n    test.before(async () => {\n      const old = require.extensions['.tsx']!;\n      require.extensions['.tsx'] = (m: any, fileName) => {\n        const _compile = m._compile;\n\n        m._compile = function (code: string, fileName: string) {\n          compiled = code;\n          return _compile.call(this, code, fileName);\n        };\n\n        return old(m, fileName);\n      };\n    });\n\n    test('should use source maps', async (t) => {\n      try {\n        require('../../tests/with-jsx.tsx');\n      } catch (error: any) {\n        expect(error.stack).toMatch('SyntaxError: Unexpected token');\n      }\n\n      expect(compiled).toMatch(SOURCE_MAP_REGEXP);\n    });\n  });\n});\n\ntest('should support compiler scopes w/multiple registered compiler services at once', (t) => {\n  const { moduleTestPath, tsNodeUnderTest } = t.context;\n  const calls: string[] = [];\n\n  const compilers = [\n    tsNodeUnderTest.register({\n      projectSearchDir: join(TEST_DIR, 'scope/a'),\n      scopeDir: join(TEST_DIR, 'scope/a'),\n      scope: true,\n    }),\n    tsNodeUnderTest.register({\n      projectSearchDir: join(TEST_DIR, 'scope/a'),\n      scopeDir: join(TEST_DIR, 'scope/b'),\n      scope: true,\n    }),\n  ];\n\n  compilers.forEach((c) => {\n    const old = c.compile;\n    c.compile = (code, fileName, lineOffset) => {\n      calls.push(fileName);\n\n      return old(code, fileName, lineOffset);\n    };\n  });\n\n  try {\n    expect(require('../../tests/scope/a').ext).toBe('.ts');\n    expect(require('../../tests/scope/b').ext).toBe('.ts');\n  } finally {\n    compilers.forEach((c) => c.enabled(false));\n  }\n\n  expect(calls).toEqual([join(TEST_DIR, 'scope/a/index.ts'), join(TEST_DIR, 'scope/b/index.ts')]);\n\n  delete require.cache[moduleTestPath];\n\n  expect(() => require(moduleTestPath)).toThrow();\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/regression.spec.d.ts b/node_modules/ts-node/dist/test/regression.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/regression.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/regression.spec.js b/node_modules/ts-node/dist/test/regression.spec.js
new file mode 100644
index 0000000..f30d476
--- /dev/null
+++ b/node_modules/ts-node/dist/test/regression.spec.js
@@ -0,0 +1,88 @@
+"use strict";
+// Misc regression tests go here if they do not have a better home
+Object.defineProperty(exports, "__esModule", { value: true });
+const exp = require("expect");
+const path_1 = require("path");
+const exec_1 = require("./helpers/exec");
+const helpers_1 = require("./helpers");
+const testlib_1 = require("./testlib");
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+const exec = (0, exec_1.createExecTester)({
+    exec: (0, exec_1.createExec)({
+        cwd: helpers_1.TEST_DIR,
+    }),
+});
+test('#1488 regression test', async () => {
+    // Scenario that caused the bug:
+    // `allowJs` turned on
+    // `skipIgnore` turned on so that ts-node tries to compile itself (not ideal but theoretically we should be ok with this)
+    // Attempt to `require()` a `.js` file
+    // `assertScriptCanLoadAsCJS` is triggered within `require()`
+    // `./package.json` needs to be fetched into cache via `assertScriptCanLoadAsCJS` which caused a recursive `require()` call
+    // Circular dependency warning is emitted by node
+    const r = await exec({
+        exec: (0, exec_1.createExec)({
+            cwd: (0, path_1.join)(helpers_1.TEST_DIR, '1488'),
+        }),
+        cmd: `${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} ./index.js`,
+    });
+    exp(r.err).toBeNull();
+    // Assert that we do *not* get `Warning: Accessing non-existent property 'getOptionValue' of module exports inside circular dependency`
+    exp(r.stdout).toBe('foo\n'); // prove that it ran
+    exp(r.stderr).toBe(''); // prove that no warnings
+});
+test.suite('issue #1098', (test) => {
+    function testAllowedExtensions(t, compilerOptions, allowed) {
+        const disallowed = allExtensions.filter((ext) => !allowed.includes(ext));
+        const { ignored } = t.context.tsNodeUnderTest.create({
+            compilerOptions,
+            skipProject: true,
+        });
+        for (const ext of allowed) {
+            t.log(`Testing that ${ext} files are allowed`);
+            (0, testlib_1.expect)(ignored((0, path_1.join)(helpers_1.DIST_DIR, `index${ext}`))).toBe(false);
+        }
+        for (const ext of disallowed) {
+            t.log(`Testing that ${ext} files are ignored`);
+            (0, testlib_1.expect)(ignored((0, path_1.join)(helpers_1.DIST_DIR, `index${ext}`))).toBe(true);
+        }
+    }
+    const allExtensions = [
+        '.ts',
+        '.js',
+        '.d.ts',
+        '.mts',
+        '.cts',
+        '.d.mts',
+        '.d.cts',
+        '.mjs',
+        '.cjs',
+        '.tsx',
+        '.jsx',
+        '.xyz',
+        '',
+    ];
+    const mtsCts = helpers_1.tsSupportsMtsCtsExtensions ? ['.mts', '.cts', '.d.mts', '.d.cts'] : [];
+    const mjsCjs = helpers_1.tsSupportsMtsCtsExtensions ? ['.mjs', '.cjs'] : [];
+    test('correctly filters file extensions from the compiler when allowJs=false and jsx=false', (t) => {
+        testAllowedExtensions(t, {}, ['.ts', '.d.ts', ...mtsCts]);
+    });
+    test('correctly filters file extensions from the compiler when allowJs=true and jsx=false', (t) => {
+        testAllowedExtensions(t, { allowJs: true }, ['.ts', '.js', '.d.ts', ...mtsCts, ...mjsCjs]);
+    });
+    test('correctly filters file extensions from the compiler when allowJs=false and jsx=true', (t) => {
+        testAllowedExtensions(t, { allowJs: false, jsx: 'preserve' }, ['.ts', '.tsx', '.d.ts', ...mtsCts]);
+    });
+    test('correctly filters file extensions from the compiler when allowJs=true and jsx=true', (t) => {
+        testAllowedExtensions(t, { allowJs: true, jsx: 'preserve' }, [
+            '.ts',
+            '.tsx',
+            '.js',
+            '.jsx',
+            '.d.ts',
+            ...mtsCts,
+            ...mjsCjs,
+        ]);
+    });
+});
+//# sourceMappingURL=regression.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/regression.spec.js.map b/node_modules/ts-node/dist/test/regression.spec.js.map
new file mode 100644
index 0000000..01d9871
--- /dev/null
+++ b/node_modules/ts-node/dist/test/regression.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"regression.spec.js","sourceRoot":"","sources":["../../src/test/regression.spec.ts"],"names":[],"mappings":"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","sourcesContent":["// Misc regression tests go here if they do not have a better home\n\nimport * as exp from 'expect';\nimport { join } from 'path';\nimport type { CreateOptions } from '..';\nimport { createExec, createExecTester } from './helpers/exec';\nimport { CMD_TS_NODE_WITHOUT_PROJECT_FLAG, ctxTsNode, DIST_DIR, TEST_DIR, tsSupportsMtsCtsExtensions } from './helpers';\nimport { context, ExecutionContext, expect } from './testlib';\n\nconst test = context(ctxTsNode);\nconst exec = createExecTester({\n  exec: createExec({\n    cwd: TEST_DIR,\n  }),\n});\n\ntest('#1488 regression test', async () => {\n  // Scenario that caused the bug:\n  // `allowJs` turned on\n  // `skipIgnore` turned on so that ts-node tries to compile itself (not ideal but theoretically we should be ok with this)\n  // Attempt to `require()` a `.js` file\n  // `assertScriptCanLoadAsCJS` is triggered within `require()`\n  // `./package.json` needs to be fetched into cache via `assertScriptCanLoadAsCJS` which caused a recursive `require()` call\n  // Circular dependency warning is emitted by node\n\n  const r = await exec({\n    exec: createExec({\n      cwd: join(TEST_DIR, '1488'),\n    }),\n    cmd: `${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} ./index.js`,\n  });\n\n  exp(r.err).toBeNull();\n\n  // Assert that we do *not* get `Warning: Accessing non-existent property 'getOptionValue' of module exports inside circular dependency`\n  exp(r.stdout).toBe('foo\\n'); // prove that it ran\n  exp(r.stderr).toBe(''); // prove that no warnings\n});\n\ntest.suite('issue #1098', (test) => {\n  function testAllowedExtensions(\n    t: ExecutionContext<ctxTsNode.Ctx>,\n    compilerOptions: CreateOptions['compilerOptions'],\n    allowed: string[]\n  ) {\n    const disallowed = allExtensions.filter((ext) => !allowed.includes(ext));\n    const { ignored } = t.context.tsNodeUnderTest.create({\n      compilerOptions,\n      skipProject: true,\n    });\n    for (const ext of allowed) {\n      t.log(`Testing that ${ext} files are allowed`);\n      expect(ignored(join(DIST_DIR, `index${ext}`))).toBe(false);\n    }\n    for (const ext of disallowed) {\n      t.log(`Testing that ${ext} files are ignored`);\n      expect(ignored(join(DIST_DIR, `index${ext}`))).toBe(true);\n    }\n  }\n\n  const allExtensions = [\n    '.ts',\n    '.js',\n    '.d.ts',\n    '.mts',\n    '.cts',\n    '.d.mts',\n    '.d.cts',\n    '.mjs',\n    '.cjs',\n    '.tsx',\n    '.jsx',\n    '.xyz',\n    '',\n  ];\n  const mtsCts = tsSupportsMtsCtsExtensions ? ['.mts', '.cts', '.d.mts', '.d.cts'] : [];\n  const mjsCjs = tsSupportsMtsCtsExtensions ? ['.mjs', '.cjs'] : [];\n\n  test('correctly filters file extensions from the compiler when allowJs=false and jsx=false', (t) => {\n    testAllowedExtensions(t, {}, ['.ts', '.d.ts', ...mtsCts]);\n  });\n  test('correctly filters file extensions from the compiler when allowJs=true and jsx=false', (t) => {\n    testAllowedExtensions(t, { allowJs: true }, ['.ts', '.js', '.d.ts', ...mtsCts, ...mjsCjs]);\n  });\n  test('correctly filters file extensions from the compiler when allowJs=false and jsx=true', (t) => {\n    testAllowedExtensions(t, { allowJs: false, jsx: 'preserve' }, ['.ts', '.tsx', '.d.ts', ...mtsCts]);\n  });\n  test('correctly filters file extensions from the compiler when allowJs=true and jsx=true', (t) => {\n    testAllowedExtensions(t, { allowJs: true, jsx: 'preserve' }, [\n      '.ts',\n      '.tsx',\n      '.js',\n      '.jsx',\n      '.d.ts',\n      ...mtsCts,\n      ...mjsCjs,\n    ]);\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/reminders.spec.d.ts b/node_modules/ts-node/dist/test/reminders.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/reminders.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/reminders.spec.js b/node_modules/ts-node/dist/test/reminders.spec.js
new file mode 100644
index 0000000..2cb3380
--- /dev/null
+++ b/node_modules/ts-node/dist/test/reminders.spec.js
@@ -0,0 +1,48 @@
+"use strict";
+// Reminders about chores to stay up-to-date with the ecosystem
+Object.defineProperty(exports, "__esModule", { value: true });
+const helpers_1 = require("./helpers");
+const testlib_1 = require("./testlib");
+(0, testlib_1.test)('Detect when typescript adds new ModuleKind values; flag as a failure so we can update our code flagged [MUST_UPDATE_FOR_NEW_MODULEKIND]', async () => {
+    // We have marked a few places in our code with MUST_UPDATE_FOR_NEW_MODULEKIND to make it easier to update them when TS adds new ModuleKinds
+    const foundKeys = [];
+    function check(value, name, required) {
+        if (required)
+            (0, testlib_1.expect)(helpers_1.ts.ModuleKind[name]).toBe(value);
+        if (helpers_1.ts.ModuleKind[value] === undefined) {
+            (0, testlib_1.expect)(helpers_1.ts.ModuleKind[name]).toBeUndefined();
+        }
+        else {
+            (0, testlib_1.expect)(helpers_1.ts.ModuleKind[value]).toBe(name);
+            foundKeys.push(name, `${value}`);
+        }
+    }
+    check(0, 'None', true);
+    check(1, 'CommonJS', true);
+    check(2, 'AMD', true);
+    check(3, 'UMD', true);
+    check(4, 'System', true);
+    check(5, 'ES2015', true);
+    try {
+        check(6, 'ES2020', false);
+        check(99, 'ESNext', true);
+    }
+    catch {
+        // the value changed: is `99` now, but was `6` in TS 2.7
+        check(6, 'ESNext', true);
+        (0, testlib_1.expect)(helpers_1.ts.ModuleKind[99]).toBeUndefined();
+    }
+    check(7, 'ES2022', false);
+    if (helpers_1.tsSupportsStableNodeNextNode16) {
+        check(100, 'Node16', true);
+    }
+    else {
+        check(100, 'Node12', false);
+    }
+    check(199, 'NodeNext', false);
+    const actualKeys = Object.keys(helpers_1.ts.ModuleKind);
+    actualKeys.sort();
+    foundKeys.sort();
+    (0, testlib_1.expect)(actualKeys).toEqual(foundKeys);
+});
+//# sourceMappingURL=reminders.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/reminders.spec.js.map b/node_modules/ts-node/dist/test/reminders.spec.js.map
new file mode 100644
index 0000000..5ed2122
--- /dev/null
+++ b/node_modules/ts-node/dist/test/reminders.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"reminders.spec.js","sourceRoot":"","sources":["../../src/test/reminders.spec.ts"],"names":[],"mappings":";AAAA,+DAA+D;;AAE/D,uCAA+D;AAC/D,uCAAyC;AAEzC,IAAA,cAAI,EAAC,yIAAyI,EAAE,KAAK,IAAI,EAAE;IACzJ,4IAA4I;IAC5I,MAAM,SAAS,GAAa,EAAE,CAAC;IAC/B,SAAS,KAAK,CAAC,KAAa,EAAE,IAAY,EAAE,QAAiB;QAC3D,IAAI,QAAQ;YAAE,IAAA,gBAAM,EAAC,YAAE,CAAC,UAAU,CAAC,IAAW,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC7D,IAAI,YAAE,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,SAAS,EAAE;YACtC,IAAA,gBAAM,EAAC,YAAE,CAAC,UAAU,CAAC,IAAW,CAAC,CAAC,CAAC,aAAa,EAAE,CAAC;SACpD;aAAM;YACL,IAAA,gBAAM,EAAC,YAAE,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACxC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,KAAK,EAAE,CAAC,CAAC;SAClC;IACH,CAAC;IACD,KAAK,CAAC,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;IACvB,KAAK,CAAC,CAAC,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;IAC3B,KAAK,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;IACtB,KAAK,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;IACtB,KAAK,CAAC,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;IACzB,KAAK,CAAC,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;IACzB,IAAI;QACF,KAAK,CAAC,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;QAC1B,KAAK,CAAC,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;KAC3B;IAAC,MAAM;QACN,wDAAwD;QACxD,KAAK,CAAC,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;QACzB,IAAA,gBAAM,EAAC,YAAE,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,aAAa,EAAE,CAAC;KAC3C;IACD,KAAK,CAAC,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;IAC1B,IAAI,wCAA8B,EAAE;QAClC,KAAK,CAAC,GAAG,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;KAC5B;SAAM;QACL,KAAK,CAAC,GAAG,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;KAC7B;IACD,KAAK,CAAC,GAAG,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;IAC9B,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,YAAE,CAAC,UAAU,CAAC,CAAC;IAC9C,UAAU,CAAC,IAAI,EAAE,CAAC;IAClB,SAAS,CAAC,IAAI,EAAE,CAAC;IACjB,IAAA,gBAAM,EAAC,UAAU,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;AACxC,CAAC,CAAC,CAAC","sourcesContent":["// Reminders about chores to stay up-to-date with the ecosystem\n\nimport { ts, tsSupportsStableNodeNextNode16 } from './helpers';\nimport { expect, test } from './testlib';\n\ntest('Detect when typescript adds new ModuleKind values; flag as a failure so we can update our code flagged [MUST_UPDATE_FOR_NEW_MODULEKIND]', async () => {\n  // We have marked a few places in our code with MUST_UPDATE_FOR_NEW_MODULEKIND to make it easier to update them when TS adds new ModuleKinds\n  const foundKeys: string[] = [];\n  function check(value: number, name: string, required: boolean) {\n    if (required) expect(ts.ModuleKind[name as any]).toBe(value);\n    if (ts.ModuleKind[value] === undefined) {\n      expect(ts.ModuleKind[name as any]).toBeUndefined();\n    } else {\n      expect(ts.ModuleKind[value]).toBe(name);\n      foundKeys.push(name, `${value}`);\n    }\n  }\n  check(0, 'None', true);\n  check(1, 'CommonJS', true);\n  check(2, 'AMD', true);\n  check(3, 'UMD', true);\n  check(4, 'System', true);\n  check(5, 'ES2015', true);\n  try {\n    check(6, 'ES2020', false);\n    check(99, 'ESNext', true);\n  } catch {\n    // the value changed: is `99` now, but was `6` in TS 2.7\n    check(6, 'ESNext', true);\n    expect(ts.ModuleKind[99]).toBeUndefined();\n  }\n  check(7, 'ES2022', false);\n  if (tsSupportsStableNodeNextNode16) {\n    check(100, 'Node16', true);\n  } else {\n    check(100, 'Node12', false);\n  }\n  check(199, 'NodeNext', false);\n  const actualKeys = Object.keys(ts.ModuleKind);\n  actualKeys.sort();\n  foundKeys.sort();\n  expect(actualKeys).toEqual(foundKeys);\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/helpers/ctx-repl.d.ts b/node_modules/ts-node/dist/test/repl/helpers/ctx-repl.d.ts
new file mode 100644
index 0000000..fb9aea3
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/helpers/ctx-repl.d.ts
@@ -0,0 +1,37 @@
+/// <reference types="node" />
+import type { ExecutionContext } from '@cspotcode/ava-lib';
+import { PassThrough } from 'stream';
+import type { ctxTsNode } from '../../helpers/ctx-ts-node';
+import { tsNodeTypes } from '../../helpers/misc';
+export interface CreateReplViaApiOptions {
+    registerHooks: boolean;
+    createReplOpts?: Partial<tsNodeTypes.CreateReplOptions>;
+    createServiceOpts?: Partial<tsNodeTypes.CreateOptions>;
+}
+export interface ExecuteInReplOptions extends CreateReplViaApiOptions {
+    waitMs?: number;
+    waitPattern?: string | RegExp;
+    /** When specified, calls `startInternal` instead of `start` and passes options */
+    startInternalOptions?: Parameters<tsNodeTypes.ReplService['startInternal']>[0];
+}
+export declare namespace ctxRepl {
+    type Ctx = ctxTsNode.Ctx & Awaited<ReturnType<typeof ctxRepl>>;
+    type T = ExecutionContext<Ctx>;
+}
+/**
+ * pass to test.context() to get REPL testing helper functions
+ */
+export declare function ctxRepl(t: ctxTsNode.T): Promise<{
+    createReplViaApi: ({ registerHooks, createReplOpts, createServiceOpts }: CreateReplViaApiOptions) => {
+        stdin: PassThrough;
+        stdout: PassThrough;
+        stderr: PassThrough;
+        replService: tsNodeTypes.ReplService;
+        service: tsNodeTypes.Service;
+    };
+    executeInRepl: (input: string, options: ExecuteInReplOptions) => Promise<{
+        stdin: PassThrough;
+        stdout: string;
+        stderr: string;
+    }>;
+}>;
diff --git a/node_modules/ts-node/dist/test/repl/helpers/ctx-repl.js b/node_modules/ts-node/dist/test/repl/helpers/ctx-repl.js
new file mode 100644
index 0000000..31b4ecb
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/helpers/ctx-repl.js
@@ -0,0 +1,67 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.ctxRepl = void 0;
+const expect_stream_1 = require("@cspotcode/expect-stream");
+const stream_1 = require("stream");
+const misc_1 = require("../../helpers/misc");
+const paths_1 = require("../../helpers/paths");
+/**
+ * pass to test.context() to get REPL testing helper functions
+ */
+async function ctxRepl(t) {
+    const { tsNodeUnderTest } = t.context;
+    return { createReplViaApi, executeInRepl };
+    function createReplViaApi({ registerHooks, createReplOpts, createServiceOpts }) {
+        const stdin = new stream_1.PassThrough();
+        const stdout = new stream_1.PassThrough();
+        const stderr = new stream_1.PassThrough();
+        const replService = tsNodeUnderTest.createRepl({
+            stdin,
+            stdout,
+            stderr,
+            ...createReplOpts,
+        });
+        const service = (registerHooks ? tsNodeUnderTest.register : tsNodeUnderTest.create)({
+            ...replService.evalAwarePartialHost,
+            project: `${paths_1.TEST_DIR}/tsconfig.json`,
+            ...createServiceOpts,
+            tsTrace: replService.console.log.bind(replService.console),
+        });
+        replService.setService(service);
+        t.teardown(async () => {
+            service.enabled(false);
+        });
+        return { stdin, stdout, stderr, replService, service };
+    }
+    async function executeInRepl(input, options) {
+        const { waitPattern, 
+        // Wait longer if there's a signal to end it early
+        waitMs = waitPattern != null ? 20e3 : 1e3, startInternalOptions, ...rest } = options;
+        const { stdin, stdout, stderr, replService } = createReplViaApi(rest);
+        if (startInternalOptions) {
+            replService.startInternal(startInternalOptions);
+        }
+        else {
+            replService.start();
+        }
+        stdin.write(input);
+        stdin.end();
+        const stdoutPromise = (0, expect_stream_1.expectStream)(stdout);
+        const stderrPromise = (0, expect_stream_1.expectStream)(stderr);
+        // Wait for expected output pattern or timeout, whichever comes first
+        await Promise.race([
+            (0, misc_1.delay)(waitMs),
+            waitPattern != null ? stdoutPromise.wait(waitPattern) : stdoutPromise,
+            waitPattern != null ? stderrPromise.wait(waitPattern) : stderrPromise,
+        ]);
+        stdout.end();
+        stderr.end();
+        return {
+            stdin,
+            stdout: await stdoutPromise,
+            stderr: await stderrPromise,
+        };
+    }
+}
+exports.ctxRepl = ctxRepl;
+//# sourceMappingURL=ctx-repl.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/helpers/ctx-repl.js.map b/node_modules/ts-node/dist/test/repl/helpers/ctx-repl.js.map
new file mode 100644
index 0000000..15adbf5
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/helpers/ctx-repl.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ctx-repl.js","sourceRoot":"","sources":["../../../../src/test/repl/helpers/ctx-repl.ts"],"names":[],"mappings":";;;AACA,4DAAwD;AACxD,mCAAqC;AAErC,6CAAwD;AACxD,+CAA+C;AAoB/C;;GAEG;AACI,KAAK,UAAU,OAAO,CAAC,CAAc;IAC1C,MAAM,EAAE,eAAe,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC;IACtC,OAAO,EAAE,gBAAgB,EAAE,aAAa,EAAE,CAAC;IAE3C,SAAS,gBAAgB,CAAC,EAAE,aAAa,EAAE,cAAc,EAAE,iBAAiB,EAA2B;QACrG,MAAM,KAAK,GAAG,IAAI,oBAAW,EAAE,CAAC;QAChC,MAAM,MAAM,GAAG,IAAI,oBAAW,EAAE,CAAC;QACjC,MAAM,MAAM,GAAG,IAAI,oBAAW,EAAE,CAAC;QACjC,MAAM,WAAW,GAAG,eAAe,CAAC,UAAU,CAAC;YAC7C,KAAK;YACL,MAAM;YACN,MAAM;YACN,GAAG,cAAc;SAClB,CAAC,CAAC;QACH,MAAM,OAAO,GAAG,CAAC,aAAa,CAAC,CAAC,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;YAClF,GAAG,WAAW,CAAC,oBAAoB;YACnC,OAAO,EAAE,GAAG,gBAAQ,gBAAgB;YACpC,GAAG,iBAAiB;YACpB,OAAO,EAAE,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC;SAC3D,CAAC,CAAC;QACH,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QAChC,CAAC,CAAC,QAAQ,CAAC,KAAK,IAAI,EAAE;YACpB,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;QAEH,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,OAAO,EAAE,CAAC;IACzD,CAAC;IAED,KAAK,UAAU,aAAa,CAAC,KAAa,EAAE,OAA6B;QACvE,MAAM,EACJ,WAAW;QACX,kDAAkD;QAClD,MAAM,GAAG,WAAW,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,EACzC,oBAAoB,EACpB,GAAG,IAAI,EACR,GAAG,OAAO,CAAC;QACZ,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAEtE,IAAI,oBAAoB,EAAE;YACxB,WAAW,CAAC,aAAa,CAAC,oBAAoB,CAAC,CAAC;SACjD;aAAM;YACL,WAAW,CAAC,KAAK,EAAE,CAAC;SACrB;QAED,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACnB,KAAK,CAAC,GAAG,EAAE,CAAC;QACZ,MAAM,aAAa,GAAG,IAAA,4BAAY,EAAC,MAAM,CAAC,CAAC;QAC3C,MAAM,aAAa,GAAG,IAAA,4BAAY,EAAC,MAAM,CAAC,CAAC;QAC3C,qEAAqE;QACrE,MAAM,OAAO,CAAC,IAAI,CAAC;YACjB,IAAA,YAAK,EAAC,MAAM,CAAC;YACb,WAAW,IAAI,IAAI,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa;YACrE,WAAW,IAAI,IAAI,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa;SACtE,CAAC,CAAC;QACH,MAAM,CAAC,GAAG,EAAE,CAAC;QACb,MAAM,CAAC,GAAG,EAAE,CAAC;QAEb,OAAO;YACL,KAAK;YACL,MAAM,EAAE,MAAM,aAAa;YAC3B,MAAM,EAAE,MAAM,aAAa;SAC5B,CAAC;IACJ,CAAC;AACH,CAAC;AA/DD,0BA+DC","sourcesContent":["import type { ExecutionContext } from '@cspotcode/ava-lib';\nimport { expectStream } from '@cspotcode/expect-stream';\nimport { PassThrough } from 'stream';\nimport type { ctxTsNode } from '../../helpers/ctx-ts-node';\nimport { delay, tsNodeTypes } from '../../helpers/misc';\nimport { TEST_DIR } from '../../helpers/paths';\n\nexport interface CreateReplViaApiOptions {\n  registerHooks: boolean;\n  createReplOpts?: Partial<tsNodeTypes.CreateReplOptions>;\n  createServiceOpts?: Partial<tsNodeTypes.CreateOptions>;\n}\n\nexport interface ExecuteInReplOptions extends CreateReplViaApiOptions {\n  waitMs?: number;\n  waitPattern?: string | RegExp;\n  /** When specified, calls `startInternal` instead of `start` and passes options */\n  startInternalOptions?: Parameters<tsNodeTypes.ReplService['startInternal']>[0];\n}\n\nexport namespace ctxRepl {\n  export type Ctx = ctxTsNode.Ctx & Awaited<ReturnType<typeof ctxRepl>>;\n  export type T = ExecutionContext<Ctx>;\n}\n\n/**\n * pass to test.context() to get REPL testing helper functions\n */\nexport async function ctxRepl(t: ctxTsNode.T) {\n  const { tsNodeUnderTest } = t.context;\n  return { createReplViaApi, executeInRepl };\n\n  function createReplViaApi({ registerHooks, createReplOpts, createServiceOpts }: CreateReplViaApiOptions) {\n    const stdin = new PassThrough();\n    const stdout = new PassThrough();\n    const stderr = new PassThrough();\n    const replService = tsNodeUnderTest.createRepl({\n      stdin,\n      stdout,\n      stderr,\n      ...createReplOpts,\n    });\n    const service = (registerHooks ? tsNodeUnderTest.register : tsNodeUnderTest.create)({\n      ...replService.evalAwarePartialHost,\n      project: `${TEST_DIR}/tsconfig.json`,\n      ...createServiceOpts,\n      tsTrace: replService.console.log.bind(replService.console),\n    });\n    replService.setService(service);\n    t.teardown(async () => {\n      service.enabled(false);\n    });\n\n    return { stdin, stdout, stderr, replService, service };\n  }\n\n  async function executeInRepl(input: string, options: ExecuteInReplOptions) {\n    const {\n      waitPattern,\n      // Wait longer if there's a signal to end it early\n      waitMs = waitPattern != null ? 20e3 : 1e3,\n      startInternalOptions,\n      ...rest\n    } = options;\n    const { stdin, stdout, stderr, replService } = createReplViaApi(rest);\n\n    if (startInternalOptions) {\n      replService.startInternal(startInternalOptions);\n    } else {\n      replService.start();\n    }\n\n    stdin.write(input);\n    stdin.end();\n    const stdoutPromise = expectStream(stdout);\n    const stderrPromise = expectStream(stderr);\n    // Wait for expected output pattern or timeout, whichever comes first\n    await Promise.race([\n      delay(waitMs),\n      waitPattern != null ? stdoutPromise.wait(waitPattern) : stdoutPromise,\n      waitPattern != null ? stderrPromise.wait(waitPattern) : stderrPromise,\n    ]);\n    stdout.end();\n    stderr.end();\n\n    return {\n      stdin,\n      stdout: await stdoutPromise,\n      stderr: await stderrPromise,\n    };\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/helpers/macros.d.ts b/node_modules/ts-node/dist/test/repl/helpers/macros.d.ts
new file mode 100644
index 0000000..dd01e64
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/helpers/macros.d.ts
@@ -0,0 +1,3 @@
+import type { ctxRepl, ExecuteInReplOptions } from './ctx-repl';
+export declare const macroReplNoErrorsAndStdoutContains: import("@cspotcode/ava-lib").Macro<[script: string, contains: string, options?: Partial<ExecuteInReplOptions> | undefined], ctxRepl.Ctx>;
+export declare const macroReplStderrContains: import("@cspotcode/ava-lib").Macro<[script: string, errorContains: string, options?: Partial<ExecuteInReplOptions> | undefined], ctxRepl.Ctx>;
diff --git a/node_modules/ts-node/dist/test/repl/helpers/macros.js b/node_modules/ts-node/dist/test/repl/helpers/macros.js
new file mode 100644
index 0000000..dcd8367
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/helpers/macros.js
@@ -0,0 +1,25 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.macroReplStderrContains = exports.macroReplNoErrorsAndStdoutContains = void 0;
+const testlib_1 = require("../../testlib");
+exports.macroReplNoErrorsAndStdoutContains = testlib_1.test.macro((script, contains, options) => async (t) => {
+    macroReplInternal(t, script, contains, undefined, contains, options);
+});
+exports.macroReplStderrContains = testlib_1.test.macro((script, errorContains, options) => async (t) => {
+    macroReplInternal(t, script, undefined, errorContains, errorContains, options);
+});
+async function macroReplInternal(t, script, stdoutContains, stderrContains, waitPattern, options) {
+    const r = await t.context.executeInRepl(script, {
+        registerHooks: true,
+        startInternalOptions: { useGlobal: false },
+        waitPattern,
+        ...options,
+    });
+    if (stderrContains)
+        (0, testlib_1.expect)(r.stderr).toContain(stderrContains);
+    else
+        (0, testlib_1.expect)(r.stderr).toBe('');
+    if (stdoutContains)
+        (0, testlib_1.expect)(r.stdout).toContain(stdoutContains);
+}
+//# sourceMappingURL=macros.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/helpers/macros.js.map b/node_modules/ts-node/dist/test/repl/helpers/macros.js.map
new file mode 100644
index 0000000..798ba27
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/helpers/macros.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"macros.js","sourceRoot":"","sources":["../../../../src/test/repl/helpers/macros.ts"],"names":[],"mappings":";;;AACA,2CAA6C;AAEhC,QAAA,kCAAkC,GAAG,cAAI,CAAC,KAAK,CAC1D,CAAC,MAAc,EAAE,QAAgB,EAAE,OAAuC,EAAE,EAAE,CAAC,KAAK,EAAE,CAAY,EAAE,EAAE;IACpG,iBAAiB,CAAC,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AACvE,CAAC,CACF,CAAC;AACW,QAAA,uBAAuB,GAAG,cAAI,CAAC,KAAK,CAC/C,CAAC,MAAc,EAAE,aAAqB,EAAE,OAAuC,EAAE,EAAE,CAAC,KAAK,EAAE,CAAY,EAAE,EAAE;IACzG,iBAAiB,CAAC,CAAC,EAAE,MAAM,EAAE,SAAS,EAAE,aAAa,EAAE,aAAa,EAAE,OAAO,CAAC,CAAC;AACjF,CAAC,CACF,CAAC;AAEF,KAAK,UAAU,iBAAiB,CAC9B,CAAY,EACZ,MAAc,EACd,cAAkC,EAClC,cAAkC,EAClC,WAAmB,EACnB,OAAuC;IAEvC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,MAAM,EAAE;QAC9C,aAAa,EAAE,IAAI;QACnB,oBAAoB,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE;QAC1C,WAAW;QACX,GAAG,OAAO;KACX,CAAC,CAAC;IACH,IAAI,cAAc;QAAE,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;;QAC1D,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC/B,IAAI,cAAc;QAAE,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;AACjE,CAAC","sourcesContent":["import type { ctxRepl, ExecuteInReplOptions } from './ctx-repl';\nimport { expect, test } from '../../testlib';\n\nexport const macroReplNoErrorsAndStdoutContains = test.macro(\n  (script: string, contains: string, options?: Partial<ExecuteInReplOptions>) => async (t: ctxRepl.T) => {\n    macroReplInternal(t, script, contains, undefined, contains, options);\n  }\n);\nexport const macroReplStderrContains = test.macro(\n  (script: string, errorContains: string, options?: Partial<ExecuteInReplOptions>) => async (t: ctxRepl.T) => {\n    macroReplInternal(t, script, undefined, errorContains, errorContains, options);\n  }\n);\n\nasync function macroReplInternal(\n  t: ctxRepl.T,\n  script: string,\n  stdoutContains: string | undefined,\n  stderrContains: string | undefined,\n  waitPattern: string,\n  options?: Partial<ExecuteInReplOptions>\n) {\n  const r = await t.context.executeInRepl(script, {\n    registerHooks: true,\n    startInternalOptions: { useGlobal: false },\n    waitPattern,\n    ...options,\n  });\n  if (stderrContains) expect(r.stderr).toContain(stderrContains);\n  else expect(r.stderr).toBe('');\n  if (stdoutContains) expect(r.stdout).toContain(stdoutContains);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/helpers/misc.d.ts b/node_modules/ts-node/dist/test/repl/helpers/misc.d.ts
new file mode 100644
index 0000000..acbc778
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/helpers/misc.d.ts
@@ -0,0 +1 @@
+export declare const replFile: string;
diff --git a/node_modules/ts-node/dist/test/repl/helpers/misc.js b/node_modules/ts-node/dist/test/repl/helpers/misc.js
new file mode 100644
index 0000000..a7caf9d
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/helpers/misc.js
@@ -0,0 +1,6 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.replFile = void 0;
+const helpers_1 = require("../../helpers");
+exports.replFile = helpers_1.tsSupportsMtsCtsExtensions ? '<repl>.cts' : '<repl>.ts';
+//# sourceMappingURL=misc.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/helpers/misc.js.map b/node_modules/ts-node/dist/test/repl/helpers/misc.js.map
new file mode 100644
index 0000000..681dabe
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/helpers/misc.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"misc.js","sourceRoot":"","sources":["../../../../src/test/repl/helpers/misc.ts"],"names":[],"mappings":";;;AAAA,2CAAwE;AAE3D,QAAA,QAAQ,GAAG,oCAA0B,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,WAAW,CAAC","sourcesContent":["import { tsNodeTypes, tsSupportsMtsCtsExtensions } from '../../helpers';\n\nexport const replFile = tsSupportsMtsCtsExtensions ? '<repl>.cts' : '<repl>.ts';\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/node-repl-tla.d.ts b/node_modules/ts-node/dist/test/repl/node-repl-tla.d.ts
new file mode 100644
index 0000000..005d35e
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/node-repl-tla.d.ts
@@ -0,0 +1,25 @@
+/// <reference types="node" />
+/// <reference types="node" />
+/// <reference types="node" />
+import { Stream } from 'stream';
+import type { ctxTsNode } from '../helpers';
+interface SharedObjects extends ctxTsNode.Ctx {
+    TEST_DIR: string;
+}
+export declare function upstreamTopLevelAwaitTests({ TEST_DIR, tsNodeUnderTest }: SharedObjects): Promise<void>;
+declare class ArrayStream extends Stream {
+    readable: boolean;
+    writable: boolean;
+    run(data: string[]): void;
+    pause(): void;
+    resume(): void;
+    write(_chunk: Buffer | string, _encoding: string, _callback: () => {}): void;
+}
+export declare class REPLStream extends ArrayStream {
+    waitingForResponse: boolean;
+    lines: string[];
+    constructor();
+    write(chunk: Buffer | string, encoding: string, callback: () => void): boolean;
+    wait(): Promise<string[]>;
+}
+export {};
diff --git a/node_modules/ts-node/dist/test/repl/node-repl-tla.js b/node_modules/ts-node/dist/test/repl/node-repl-tla.js
new file mode 100644
index 0000000..2c39e3a
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/node-repl-tla.js
@@ -0,0 +1,252 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.REPLStream = exports.upstreamTopLevelAwaitTests = void 0;
+const testlib_1 = require("../testlib");
+const stream_1 = require("stream");
+require("../helpers");
+// Based on https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/test/parallel/test-repl-top-level-await.js
+async function upstreamTopLevelAwaitTests({ TEST_DIR, tsNodeUnderTest }) {
+    const PROMPT = 'await repl > ';
+    const putIn = new REPLStream();
+    const replService = tsNodeUnderTest.createRepl({
+        // @ts-ignore
+        stdin: putIn,
+        // @ts-ignore
+        stdout: putIn,
+        // @ts-ignore
+        stderr: putIn,
+    });
+    const service = tsNodeUnderTest.create({
+        ...replService.evalAwarePartialHost,
+        project: `${TEST_DIR}/tsconfig.json`,
+        experimentalReplAwait: true,
+        transpileOnly: true,
+        compilerOptions: {
+            target: 'es2018',
+        },
+    });
+    replService.setService(service);
+    replService.stdout.isTTY = true;
+    const replServer = replService.startInternal({
+        prompt: PROMPT,
+        terminal: true,
+        useColors: true,
+        useGlobal: false,
+    });
+    function runAndWait(cmds) {
+        const promise = putIn.wait();
+        for (const cmd of cmds) {
+            if (typeof cmd === 'string') {
+                putIn.run([cmd]);
+            }
+            else {
+                replServer.write('', cmd);
+            }
+        }
+        return promise;
+    }
+    await runAndWait(['function foo(x) { return x; }', 'function koo() { return Promise.resolve(4); }']);
+    const testCases = [
+        ['await Promise.resolve(0)', '0'],
+        // issue: { a: await Promise.resolve(1) } is being interpreted as a block
+        // remove surrounding parenthesis once issue is fixed
+        ['({ a: await Promise.resolve(1) })', '{ a: 1 }'],
+        ['_', '{ a: 1 }'],
+        ['let { aa, bb } = await Promise.resolve({ aa: 1, bb: 2 }), f = 5;'],
+        ['aa', '1'],
+        ['bb', '2'],
+        ['f', '5'],
+        ['let cc = await Promise.resolve(2)'],
+        ['cc', '2'],
+        ['let dd;'],
+        ['dd'],
+        ['let [ii, { abc: { kk } }] = [0, { abc: { kk: 1 } }];'],
+        ['ii', '0'],
+        ['kk', '1'],
+        ['var ll = await Promise.resolve(2);'],
+        ['ll', '2'],
+        ['foo(await koo())', '4'],
+        ['_', '4'],
+        ['const m = foo(await koo());'],
+        ['m', '4'],
+        // issue: REPL doesn't recognize end of input
+        // compile is returning TS1005 after second line even though
+        // it's valid syntax
+        // [
+        //   'const n = foo(await\nkoo());',
+        //   ['const n = foo(await\r', '... koo());\r', 'undefined'],
+        // ],
+        ['`status: ${(await Promise.resolve({ status: 200 })).status}`', "'status: 200'"],
+        ['for (let i = 0; i < 2; ++i) await i'],
+        ['for (let i = 0; i < 2; ++i) { await i }'],
+        ['await 0', '0'],
+        ['await 0; function foo() {}'],
+        ['foo', '[Function: foo]'],
+        ['class Foo {}; await 1;', '1'],
+        ['Foo', '[class Foo]'],
+        ['if (await true) { function fooz() {}; }'],
+        ['fooz', '[Function: fooz]'],
+        ['if (await true) { class Bar {}; }'],
+        [
+            'Bar',
+            'Uncaught ReferenceError: Bar is not defined',
+            // Line increased due to TS added lines
+            {
+                line: 4,
+            },
+        ],
+        ['await 0; function* gen(){}'],
+        ['for (var i = 0; i < 10; ++i) { await i; }'],
+        ['i', '10'],
+        ['for (let j = 0; j < 5; ++j) { await j; }'],
+        [
+            'j',
+            'Uncaught ReferenceError: j is not defined',
+            // Line increased due to TS added lines
+            {
+                line: 4,
+            },
+        ],
+        ['gen', '[GeneratorFunction: gen]'],
+        [
+            'return 42; await 5;',
+            'Uncaught SyntaxError: Illegal return statement',
+            // Line increased due to TS added lines
+            {
+                line: 4,
+            },
+        ],
+        ['let o = await 1, p'],
+        ['p'],
+        ['let q = 1, s = await 2'],
+        ['s', '2'],
+        [
+            'for await (let i of [1,2,3]) console.log(i)',
+            ['for await (let i of [1,2,3]) console.log(i)\r', '1', '2', '3', 'undefined'],
+        ],
+        // issue: REPL is expecting more input to finish execution
+        // compiler is returning TS1003 error
+        // [
+        //   'await Promise..resolve()',
+        //   [
+        //     'await Promise..resolve()\r',
+        //     'Uncaught SyntaxError: ',
+        //     'await Promise..resolve()',
+        //     '              ^',
+        //     '',
+        //     "Unexpected token '.'",
+        //   ],
+        // ],
+        [
+            'for (const x of [1,2,3]) {\nawait x\n}',
+            ['for (const x of [1,2,3]) {\r', '... await x\r', '... }\r', 'undefined'],
+        ],
+        [
+            'for (const x of [1,2,3]) {\nawait x;\n}',
+            ['for (const x of [1,2,3]) {\r', '... await x;\r', '... }\r', 'undefined'],
+        ],
+        [
+            'for await (const x of [1,2,3]) {\nconsole.log(x)\n}',
+            ['for await (const x of [1,2,3]) {\r', '... console.log(x)\r', '... }\r', '1', '2', '3', 'undefined'],
+        ],
+        [
+            'for await (const x of [1,2,3]) {\nconsole.log(x);\n}',
+            ['for await (const x of [1,2,3]) {\r', '... console.log(x);\r', '... }\r', '1', '2', '3', 'undefined'],
+        ],
+    ];
+    for (const [input, expected = [`${input}\r`], options = {}] of testCases) {
+        const toBeRun = input.split('\n');
+        const lines = await runAndWait(toBeRun);
+        if (Array.isArray(expected)) {
+            if (expected.length === 1)
+                expected.push('undefined');
+            if (lines[0] === input)
+                lines.shift();
+            (0, testlib_1.expect)(lines).toEqual([...expected, PROMPT]);
+        }
+        else if ('line' in options) {
+            (0, testlib_1.expect)(lines[toBeRun.length + options.line]).toEqual(expected);
+        }
+        else {
+            const echoed = toBeRun.map((a, i) => `${i > 0 ? '... ' : ''}${a}\r`);
+            (0, testlib_1.expect)(lines).toEqual([...echoed, expected, PROMPT]);
+        }
+    }
+}
+exports.upstreamTopLevelAwaitTests = upstreamTopLevelAwaitTests;
+// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/lib/internal/util/inspect.js#L220-L227
+// Regex used for ansi escape code splitting
+// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js
+// License: MIT, authors: @sindresorhus, Qix-, arjunmehta and LitoMore
+// Matches all ansi escape code sequences in a string
+const ansiPattern = '[\\u001B\\u009B][[\\]()#;?]*' +
+    '(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)' +
+    '|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))';
+const ansi = new RegExp(ansiPattern, 'g');
+// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/lib/internal/util/inspect.js#L2112-L2117
+/**
+ * Remove all VT control characters. Use to estimate displayed string width.
+ */
+function stripVTControlCharacters(str) {
+    return str.replace(ansi, '');
+}
+// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/test/parallel/test-repl-top-level-await.js
+class ArrayStream extends stream_1.Stream {
+    constructor() {
+        super(...arguments);
+        this.readable = true;
+        this.writable = true;
+    }
+    run(data) {
+        data.forEach((line) => {
+            this.emit('data', `${line}\n`);
+        });
+    }
+    pause() { }
+    resume() { }
+    write(_chunk, _encoding, _callback) { }
+}
+class REPLStream extends ArrayStream {
+    constructor() {
+        super();
+        this.waitingForResponse = false;
+        this.lines = [''];
+    }
+    write(chunk, encoding, callback) {
+        if (Buffer.isBuffer(chunk)) {
+            chunk = chunk.toString(encoding);
+        }
+        const chunkLines = stripVTControlCharacters(chunk).split('\n');
+        this.lines[this.lines.length - 1] += chunkLines[0];
+        if (chunkLines.length > 1) {
+            this.lines.push(...chunkLines.slice(1));
+        }
+        this.emit('line');
+        if (callback)
+            callback();
+        return true;
+    }
+    wait() {
+        if (this.waitingForResponse) {
+            throw new Error('Currently waiting for response to another command');
+        }
+        this.lines = [''];
+        return new Promise((resolve, reject) => {
+            const onError = (err) => {
+                this.removeListener('line', onLine);
+                reject(err);
+            };
+            const onLine = () => {
+                if (this.lines[this.lines.length - 1].includes('> ')) {
+                    this.removeListener('error', onError);
+                    this.removeListener('line', onLine);
+                    resolve(this.lines);
+                }
+            };
+            this.once('error', onError);
+            this.on('line', onLine);
+        });
+    }
+}
+exports.REPLStream = REPLStream;
+//# sourceMappingURL=node-repl-tla.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/node-repl-tla.js.map b/node_modules/ts-node/dist/test/repl/node-repl-tla.js.map
new file mode 100644
index 0000000..c901c44
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/node-repl-tla.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"node-repl-tla.js","sourceRoot":"","sources":["../../../src/test/repl/node-repl-tla.ts"],"names":[],"mappings":"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","sourcesContent":["import { expect } from '../testlib';\nimport type { Key } from 'readline';\nimport { Stream } from 'stream';\nimport semver = require('semver');\nimport { ts } from '../helpers';\nimport type { ctxTsNode } from '../helpers';\n\ninterface SharedObjects extends ctxTsNode.Ctx {\n  TEST_DIR: string;\n}\n\n// Based on https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/test/parallel/test-repl-top-level-await.js\nexport async function upstreamTopLevelAwaitTests({ TEST_DIR, tsNodeUnderTest }: SharedObjects) {\n  const PROMPT = 'await repl > ';\n\n  const putIn = new REPLStream();\n  const replService = tsNodeUnderTest.createRepl({\n    // @ts-ignore\n    stdin: putIn,\n    // @ts-ignore\n    stdout: putIn,\n    // @ts-ignore\n    stderr: putIn,\n  });\n  const service = tsNodeUnderTest.create({\n    ...replService.evalAwarePartialHost,\n    project: `${TEST_DIR}/tsconfig.json`,\n    experimentalReplAwait: true,\n    transpileOnly: true,\n    compilerOptions: {\n      target: 'es2018',\n    },\n  });\n  replService.setService(service);\n  (\n    replService.stdout as NodeJS.WritableStream & {\n      isTTY: boolean;\n    }\n  ).isTTY = true;\n  const replServer = replService.startInternal({\n    prompt: PROMPT,\n    terminal: true,\n    useColors: true,\n    useGlobal: false,\n  });\n\n  function runAndWait(cmds: Array<string | Key>) {\n    const promise = putIn.wait();\n    for (const cmd of cmds) {\n      if (typeof cmd === 'string') {\n        putIn.run([cmd]);\n      } else {\n        replServer.write('', cmd);\n      }\n    }\n    return promise;\n  }\n\n  await runAndWait(['function foo(x) { return x; }', 'function koo() { return Promise.resolve(4); }']);\n\n  const testCases = [\n    ['await Promise.resolve(0)', '0'],\n\n    // issue: { a: await Promise.resolve(1) } is being interpreted as a block\n    // remove surrounding parenthesis once issue is fixed\n    ['({ a: await Promise.resolve(1) })', '{ a: 1 }'],\n\n    ['_', '{ a: 1 }'],\n    ['let { aa, bb } = await Promise.resolve({ aa: 1, bb: 2 }), f = 5;'],\n    ['aa', '1'],\n    ['bb', '2'],\n    ['f', '5'],\n    ['let cc = await Promise.resolve(2)'],\n    ['cc', '2'],\n    ['let dd;'],\n    ['dd'],\n    ['let [ii, { abc: { kk } }] = [0, { abc: { kk: 1 } }];'],\n    ['ii', '0'],\n    ['kk', '1'],\n    ['var ll = await Promise.resolve(2);'],\n    ['ll', '2'],\n    ['foo(await koo())', '4'],\n    ['_', '4'],\n    ['const m = foo(await koo());'],\n    ['m', '4'],\n\n    // issue: REPL doesn't recognize end of input\n    // compile is returning TS1005 after second line even though\n    // it's valid syntax\n    // [\n    //   'const n = foo(await\\nkoo());',\n    //   ['const n = foo(await\\r', '... koo());\\r', 'undefined'],\n    // ],\n\n    ['`status: ${(await Promise.resolve({ status: 200 })).status}`', \"'status: 200'\"],\n    ['for (let i = 0; i < 2; ++i) await i'],\n    ['for (let i = 0; i < 2; ++i) { await i }'],\n    ['await 0', '0'],\n    ['await 0; function foo() {}'],\n    ['foo', '[Function: foo]'],\n    ['class Foo {}; await 1;', '1'],\n\n    ['Foo', '[class Foo]'],\n    ['if (await true) { function fooz() {}; }'],\n    ['fooz', '[Function: fooz]'],\n    ['if (await true) { class Bar {}; }'],\n\n    [\n      'Bar',\n      'Uncaught ReferenceError: Bar is not defined',\n      // Line increased due to TS added lines\n      {\n        line: 4,\n      },\n    ],\n\n    ['await 0; function* gen(){}'],\n    ['for (var i = 0; i < 10; ++i) { await i; }'],\n    ['i', '10'],\n    ['for (let j = 0; j < 5; ++j) { await j; }'],\n\n    [\n      'j',\n      'Uncaught ReferenceError: j is not defined',\n      // Line increased due to TS added lines\n      {\n        line: 4,\n      },\n    ],\n\n    ['gen', '[GeneratorFunction: gen]'],\n\n    [\n      'return 42; await 5;',\n      'Uncaught SyntaxError: Illegal return statement',\n      // Line increased due to TS added lines\n      {\n        line: 4,\n      },\n    ],\n\n    ['let o = await 1, p'],\n    ['p'],\n    ['let q = 1, s = await 2'],\n    ['s', '2'],\n    [\n      'for await (let i of [1,2,3]) console.log(i)',\n      ['for await (let i of [1,2,3]) console.log(i)\\r', '1', '2', '3', 'undefined'],\n    ],\n\n    // issue: REPL is expecting more input to finish execution\n    // compiler is returning TS1003 error\n    // [\n    //   'await Promise..resolve()',\n    //   [\n    //     'await Promise..resolve()\\r',\n    //     'Uncaught SyntaxError: ',\n    //     'await Promise..resolve()',\n    //     '              ^',\n    //     '',\n    //     \"Unexpected token '.'\",\n    //   ],\n    // ],\n\n    [\n      'for (const x of [1,2,3]) {\\nawait x\\n}',\n      ['for (const x of [1,2,3]) {\\r', '... await x\\r', '... }\\r', 'undefined'],\n    ],\n    [\n      'for (const x of [1,2,3]) {\\nawait x;\\n}',\n      ['for (const x of [1,2,3]) {\\r', '... await x;\\r', '... }\\r', 'undefined'],\n    ],\n    [\n      'for await (const x of [1,2,3]) {\\nconsole.log(x)\\n}',\n      ['for await (const x of [1,2,3]) {\\r', '... console.log(x)\\r', '... }\\r', '1', '2', '3', 'undefined'],\n    ],\n    [\n      'for await (const x of [1,2,3]) {\\nconsole.log(x);\\n}',\n      ['for await (const x of [1,2,3]) {\\r', '... console.log(x);\\r', '... }\\r', '1', '2', '3', 'undefined'],\n    ],\n  ] as const;\n\n  for (const [input, expected = [`${input}\\r`], options = {} as { line?: number }] of testCases) {\n    const toBeRun = input.split('\\n');\n    const lines = await runAndWait(toBeRun);\n    if (Array.isArray(expected)) {\n      if (expected.length === 1) expected.push('undefined');\n      if (lines[0] === input) lines.shift();\n      expect(lines).toEqual([...expected, PROMPT]);\n    } else if ('line' in options) {\n      expect(lines[toBeRun.length + options.line!]).toEqual(expected);\n    } else {\n      const echoed = toBeRun.map((a, i) => `${i > 0 ? '... ' : ''}${a}\\r`);\n      expect(lines).toEqual([...echoed, expected, PROMPT]);\n    }\n  }\n}\n\n// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/lib/internal/util/inspect.js#L220-L227\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT, authors: @sindresorhus, Qix-, arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nconst ansiPattern =\n  '[\\\\u001B\\\\u009B][[\\\\]()#;?]*' +\n  '(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)' +\n  '|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))';\nconst ansi = new RegExp(ansiPattern, 'g');\n\n// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/lib/internal/util/inspect.js#L2112-L2117\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str: string) {\n  return str.replace(ansi, '');\n}\n\n// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/test/parallel/test-repl-top-level-await.js\nclass ArrayStream extends Stream {\n  readable = true;\n  writable = true;\n\n  run(data: string[]) {\n    data.forEach((line) => {\n      this.emit('data', `${line}\\n`);\n    });\n  }\n\n  pause() {}\n  resume() {}\n  write(_chunk: Buffer | string, _encoding: string, _callback: () => {}) {}\n}\n\nexport class REPLStream extends ArrayStream {\n  waitingForResponse = false;\n  lines = [''];\n\n  constructor() {\n    super();\n  }\n\n  write(chunk: Buffer | string, encoding: string, callback: () => void) {\n    if (Buffer.isBuffer(chunk)) {\n      chunk = chunk.toString(encoding);\n    }\n    const chunkLines = stripVTControlCharacters(chunk).split('\\n');\n    this.lines[this.lines.length - 1] += chunkLines[0];\n    if (chunkLines.length > 1) {\n      this.lines.push(...chunkLines.slice(1));\n    }\n    this.emit('line');\n    if (callback) callback();\n    return true;\n  }\n\n  wait(): Promise<string[]> {\n    if (this.waitingForResponse) {\n      throw new Error('Currently waiting for response to another command');\n    }\n    this.lines = [''];\n    return new Promise((resolve, reject) => {\n      const onError = (err: any) => {\n        this.removeListener('line', onLine);\n        reject(err);\n      };\n      const onLine = () => {\n        if (this.lines[this.lines.length - 1].includes('> ')) {\n          this.removeListener('error', onError);\n          this.removeListener('line', onLine);\n          resolve(this.lines);\n        }\n      };\n      this.once('error', onError);\n      this.on('line', onLine);\n    });\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/repl-environment.spec.d.ts b/node_modules/ts-node/dist/test/repl/repl-environment.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/repl-environment.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/repl/repl-environment.spec.js b/node_modules/ts-node/dist/test/repl/repl-environment.spec.js
new file mode 100644
index 0000000..17c5e0c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/repl-environment.spec.js
@@ -0,0 +1,401 @@
+"use strict";
+/*
+ * Tests that the REPL environment is setup correctly:
+ * globals, __filename, builtin module accessors.
+ */
+Object.defineProperty(exports, "__esModule", { value: true });
+const testlib_1 = require("../testlib");
+const expect_stream_1 = require("@cspotcode/expect-stream");
+const helpers_1 = require("../helpers");
+const path_1 = require("path");
+const exec_1 = require("../helpers/exec");
+const os_1 = require("os");
+const misc_1 = require("./helpers/misc");
+const ctx_repl_1 = require("./helpers/ctx-repl");
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode).contextEach(ctx_repl_1.ctxRepl);
+const exec = (0, exec_1.createExec)({
+    cwd: helpers_1.TEST_DIR,
+});
+const execTester = (0, exec_1.createExecTester)({
+    cmd: helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG,
+    exec,
+});
+test.suite('[eval], <repl>, and [stdin] execute with correct globals', (test) => {
+    const globalInRepl = global;
+    const programmaticTest = test.macro(({ evalCodeBefore, stdinCode, waitFor, }, assertions) => async (t) => {
+        delete globalInRepl.testReport;
+        delete globalInRepl.replReport;
+        delete globalInRepl.stdinReport;
+        delete globalInRepl.evalReport;
+        delete globalInRepl.module;
+        delete globalInRepl.exports;
+        delete globalInRepl.fs;
+        delete globalInRepl.__filename;
+        delete globalInRepl.__dirname;
+        const { stdin, stderr, stdout, replService } = t.context.createReplViaApi({
+            registerHooks: true,
+        });
+        if (typeof evalCodeBefore === 'string') {
+            replService.evalCode(evalCodeBefore);
+        }
+        replService.start();
+        stdin.write(stdinCode);
+        stdin.end();
+        let done = false;
+        await Promise.race([
+            (0, helpers_1.delay)(20e3),
+            (async () => {
+                while (!done && !waitFor?.()) {
+                    await (0, helpers_1.delay)(1e3);
+                }
+            })(),
+        ]);
+        done = true;
+        stdout.end();
+        stderr.end();
+        (0, testlib_1.expect)(await (0, expect_stream_1.expectStream)(stderr)).toBe('');
+        await assertions(await (0, expect_stream_1.expectStream)(stdout));
+    });
+    const declareGlobals = `declare var replReport: any, stdinReport: any, evalReport: any, restReport: any, global: any, __filename: any, __dirname: any, module: any, exports: any;`;
+    function setReportGlobal(type) {
+        return `
+            ${declareGlobals}
+            global.${type}Report = {
+              __filename: typeof __filename !== 'undefined' && __filename,
+              __dirname: typeof __dirname !== 'undefined' && __dirname,
+              moduleId: typeof module !== 'undefined' && module.id,
+              modulePath: typeof module !== 'undefined' && module.path,
+              moduleFilename: typeof module !== 'undefined' && module.filename,
+              modulePaths: typeof module !== 'undefined' && [...module.paths],
+              exportsTest: typeof exports !== 'undefined' && typeof module !== 'undefined' ? module.exports === exports : null,
+              stackTest: new Error().stack!.split('\\n')[1],
+              moduleAccessorsTest: eval('typeof fs') === 'undefined' ? null : eval('fs') === require('fs'),
+              argv: [...process.argv]
+            };
+          `.replace(/\n/g, '');
+    }
+    const reportsObject = `
+          {
+            stdinReport: typeof stdinReport !== 'undefined' && stdinReport,
+            evalReport: typeof evalReport !== 'undefined' && evalReport,
+            replReport: typeof replReport !== 'undefined' && replReport
+          }
+        `;
+    const printReports = `
+          ${declareGlobals}
+          console.log(JSON.stringify(${reportsObject}));
+        `.replace(/\n/g, '');
+    const saveReportsAsGlobal = `
+          ${declareGlobals}
+          global.testReport = ${reportsObject};
+        `.replace(/\n/g, '');
+    function parseStdoutStripReplPrompt(stdout) {
+        // Strip node's welcome header, only uncomment if running these tests manually against vanilla node
+        // stdout = stdout.replace(/^Welcome to.*\nType "\.help" .*\n/, '');
+        (0, testlib_1.expect)(stdout.slice(0, 2)).toBe('> ');
+        (0, testlib_1.expect)(stdout.slice(-12)).toBe('undefined\n> ');
+        return parseStdout(stdout.slice(2, -12));
+    }
+    function parseStdout(stdout) {
+        return JSON.parse(stdout);
+    }
+    /** Every possible ./node_modules directory ascending upwards starting with ./tests/node_modules */
+    const modulePaths = createModulePaths(helpers_1.TEST_DIR);
+    function createModulePaths(dir) {
+        const modulePaths = [];
+        for (let path = dir;; path = (0, path_1.dirname)(path)) {
+            modulePaths.push((0, path_1.join)(path, 'node_modules'));
+            if ((0, path_1.dirname)(path) === path)
+                break;
+        }
+        return modulePaths;
+    }
+    // Executable is `ts-node` on Posix, `bin.js` on Windows due to Windows shimming limitations (this is determined by package manager)
+    const tsNodeExe = testlib_1.expect.stringMatching(/\b(ts-node|bin.js)$/);
+    test('stdin', async (t) => {
+        const r = await execTester({
+            stdin: `${setReportGlobal('stdin')};${printReports}`,
+            flags: '',
+        });
+        const report = parseStdout(r.stdout);
+        (0, testlib_1.expect)(report).toMatchObject({
+            stdinReport: {
+                __filename: '[stdin]',
+                __dirname: '.',
+                moduleId: '[stdin]',
+                modulePath: '.',
+                // Note: vanilla node does does not have file extension
+                moduleFilename: (0, path_1.join)(helpers_1.TEST_DIR, `[stdin].ts`),
+                modulePaths,
+                exportsTest: true,
+                // Note: vanilla node uses different name. See #1360
+                stackTest: testlib_1.expect.stringContaining(`    at ${(0, path_1.join)(helpers_1.TEST_DIR, `[stdin].ts`)}:1:`),
+                moduleAccessorsTest: null,
+                argv: [tsNodeExe],
+            },
+            evalReport: false,
+            replReport: false,
+        });
+    });
+    test('repl', async (t) => {
+        const r = await execTester({
+            stdin: `${setReportGlobal('repl')};${printReports}`,
+            flags: '-i',
+        });
+        const report = parseStdoutStripReplPrompt(r.stdout);
+        (0, testlib_1.expect)(report).toMatchObject({
+            stdinReport: false,
+            evalReport: false,
+            replReport: {
+                __filename: false,
+                __dirname: false,
+                moduleId: '<repl>',
+                modulePath: '.',
+                moduleFilename: null,
+                modulePaths: testlib_1.expect.objectContaining({
+                    ...[(0, path_1.join)(helpers_1.TEST_DIR, `repl/node_modules`), ...modulePaths],
+                }),
+                // Note: vanilla node REPL does not set exports
+                exportsTest: true,
+                // Note: vanilla node uses different name. See #1360
+                stackTest: testlib_1.expect.stringContaining(`    at ${(0, path_1.join)(helpers_1.TEST_DIR, misc_1.replFile)}:4:`),
+                moduleAccessorsTest: true,
+                argv: [tsNodeExe],
+            },
+        });
+        // Prior to these, nyc adds another entry on Windows; we need to ignore it
+        (0, testlib_1.expect)(report.replReport.modulePaths.slice(-3)).toMatchObject([
+            (0, path_1.join)((0, os_1.homedir)(), `.node_modules`),
+            (0, path_1.join)((0, os_1.homedir)(), `.node_libraries`),
+            // additional entry goes to node's install path
+            testlib_1.expect.any(String),
+        ]);
+    });
+    // Should ignore -i and run the entrypoint
+    test('-i w/entrypoint ignores -i', async (t) => {
+        const r = await execTester({
+            stdin: `${setReportGlobal('repl')};${printReports}`,
+            flags: '-i ./repl/script.js',
+        });
+        const report = parseStdout(r.stdout);
+        (0, testlib_1.expect)(report).toMatchObject({
+            stdinReport: false,
+            evalReport: false,
+            replReport: false,
+        });
+    });
+    // Should not execute stdin
+    // Should not interpret positional arg as an entrypoint script
+    test('-e', async (t) => {
+        const r = await execTester({
+            stdin: `throw new Error()`,
+            flags: `-e "${setReportGlobal('eval')};${printReports}"`,
+        });
+        const report = parseStdout(r.stdout);
+        (0, testlib_1.expect)(report).toMatchObject({
+            stdinReport: false,
+            evalReport: {
+                __filename: '[eval]',
+                __dirname: '.',
+                moduleId: '[eval]',
+                modulePath: '.',
+                // Note: vanilla node does does not have file extension
+                moduleFilename: (0, path_1.join)(helpers_1.TEST_DIR, `[eval].ts`),
+                modulePaths: [...modulePaths],
+                exportsTest: true,
+                // Note: vanilla node uses different name. See #1360
+                stackTest: testlib_1.expect.stringContaining(`    at ${(0, path_1.join)(helpers_1.TEST_DIR, `[eval].ts`)}:1:`),
+                moduleAccessorsTest: true,
+                argv: [tsNodeExe],
+            },
+            replReport: false,
+        });
+    });
+    test('-e w/entrypoint arg does not execute entrypoint', async (t) => {
+        const r = await execTester({
+            stdin: `throw new Error()`,
+            flags: `-e "${setReportGlobal('eval')};${printReports}" ./repl/script.js`,
+        });
+        const report = parseStdout(r.stdout);
+        (0, testlib_1.expect)(report).toMatchObject({
+            stdinReport: false,
+            evalReport: {
+                __filename: '[eval]',
+                __dirname: '.',
+                moduleId: '[eval]',
+                modulePath: '.',
+                // Note: vanilla node does does not have file extension
+                moduleFilename: (0, path_1.join)(helpers_1.TEST_DIR, `[eval].ts`),
+                modulePaths,
+                exportsTest: true,
+                // Note: vanilla node uses different name. See #1360
+                stackTest: testlib_1.expect.stringContaining(`    at ${(0, path_1.join)(helpers_1.TEST_DIR, `[eval].ts`)}:1:`),
+                moduleAccessorsTest: true,
+                argv: [tsNodeExe, './repl/script.js'],
+            },
+            replReport: false,
+        });
+    });
+    test('-e w/non-path arg', async (t) => {
+        const r = await execTester({
+            stdin: `throw new Error()`,
+            flags: `-e "${setReportGlobal('eval')};${printReports}" ./does-not-exist.js`,
+        });
+        const report = parseStdout(r.stdout);
+        (0, testlib_1.expect)(report).toMatchObject({
+            stdinReport: false,
+            evalReport: {
+                __filename: '[eval]',
+                __dirname: '.',
+                moduleId: '[eval]',
+                modulePath: '.',
+                // Note: vanilla node does does not have file extension
+                moduleFilename: (0, path_1.join)(helpers_1.TEST_DIR, `[eval].ts`),
+                modulePaths,
+                exportsTest: true,
+                // Note: vanilla node uses different name. See #1360
+                stackTest: testlib_1.expect.stringContaining(`    at ${(0, path_1.join)(helpers_1.TEST_DIR, `[eval].ts`)}:1:`),
+                moduleAccessorsTest: true,
+                argv: [tsNodeExe, './does-not-exist.js'],
+            },
+            replReport: false,
+        });
+    });
+    test('-e -i', async (t) => {
+        const r = await execTester({
+            stdin: `${setReportGlobal('repl')};${printReports}`,
+            flags: `-e "${setReportGlobal('eval')}" -i`,
+        });
+        const report = parseStdoutStripReplPrompt(r.stdout);
+        (0, testlib_1.expect)(report).toMatchObject({
+            stdinReport: false,
+            evalReport: {
+                __filename: '[eval]',
+                __dirname: '.',
+                moduleId: '[eval]',
+                modulePath: '.',
+                // Note: vanilla node does does not have file extension
+                moduleFilename: (0, path_1.join)(helpers_1.TEST_DIR, `[eval].ts`),
+                modulePaths,
+                exportsTest: true,
+                // Note: vanilla node uses different name. See #1360
+                stackTest: testlib_1.expect.stringContaining(`    at ${(0, path_1.join)(helpers_1.TEST_DIR, `[eval].ts`)}:1:`),
+                moduleAccessorsTest: true,
+                argv: [tsNodeExe],
+            },
+            replReport: {
+                __filename: '[eval]',
+                __dirname: '.',
+                moduleId: '<repl>',
+                modulePath: '.',
+                moduleFilename: null,
+                modulePaths: testlib_1.expect.objectContaining({
+                    ...[(0, path_1.join)(helpers_1.TEST_DIR, `repl/node_modules`), ...modulePaths],
+                }),
+                // Note: vanilla node REPL does not set exports, so this would be false
+                exportsTest: true,
+                // Note: vanilla node uses different name. See #1360
+                stackTest: testlib_1.expect.stringContaining(`    at ${(0, path_1.join)(helpers_1.TEST_DIR, misc_1.replFile)}:4:`),
+                moduleAccessorsTest: true,
+                argv: [tsNodeExe],
+            },
+        });
+        // Prior to these, nyc adds another entry on Windows; we need to ignore it
+        (0, testlib_1.expect)(report.replReport.modulePaths.slice(-3)).toMatchObject([
+            (0, path_1.join)((0, os_1.homedir)(), `.node_modules`),
+            (0, path_1.join)((0, os_1.homedir)(), `.node_libraries`),
+            // additional entry goes to node's install path
+            testlib_1.expect.any(String),
+        ]);
+    });
+    test('-e -i w/entrypoint ignores -e and -i, runs entrypoint', async (t) => {
+        const r = await execTester({
+            stdin: `throw new Error()`,
+            flags: '-e "throw new Error()" -i ./repl/script.js',
+        });
+        const report = parseStdout(r.stdout);
+        (0, testlib_1.expect)(report).toMatchObject({
+            stdinReport: false,
+            evalReport: false,
+            replReport: false,
+        });
+    });
+    test('-e -i when -e throws error, -i does not run', async (t) => {
+        const r = await execTester({
+            stdin: `console.log('hello')`,
+            flags: `-e "throw new Error('error from -e')" -i`,
+            expectError: true,
+        });
+        (0, testlib_1.expect)(r.err).toBeDefined();
+        (0, testlib_1.expect)(r.stdout).toBe('');
+        (0, testlib_1.expect)(r.stderr).toContain('error from -e');
+    });
+    // Serial because it's timing-sensitive
+    test.serial('programmatically, eval-ing before starting REPL', programmaticTest, {
+        evalCodeBefore: `${setReportGlobal('repl')};${saveReportsAsGlobal}`,
+        stdinCode: '',
+        waitFor: () => !!globalInRepl.testReport,
+    }, (stdout) => {
+        (0, testlib_1.expect)(globalInRepl.testReport).toMatchObject({
+            stdinReport: false,
+            evalReport: false,
+            replReport: {
+                __filename: false,
+                __dirname: false,
+                // Due to limitations in node's REPL API, we can't really expose
+                // the `module` prior to calling repl.start() which also sends
+                // output to stdout.
+                // For now, leaving this as unsupported / undefined behavior.
+                // moduleId: '<repl>',
+                // modulePath: '.',
+                // moduleFilename: null,
+                // modulePaths: [
+                //   join(ROOT_DIR, `repl/node_modules`),
+                //   ...rootModulePaths,
+                //   join(homedir(), `.node_modules`),
+                //   join(homedir(), `.node_libraries`),
+                //   // additional entry goes to node's install path
+                //   exp.any(String),
+                // ],
+                // // Note: vanilla node REPL does not set exports
+                // exportsTest: true,
+                // moduleAccessorsTest: true,
+                // Note: vanilla node uses different name. See #1360
+                stackTest: testlib_1.expect.stringContaining(`    at ${(0, path_1.join)(helpers_1.TEST_DIR, misc_1.replFile)}:1:`),
+            },
+        });
+    });
+    test.serial('programmatically, passing code to stdin after starting REPL', programmaticTest, {
+        evalCodeBefore: null,
+        stdinCode: `${setReportGlobal('repl')};${saveReportsAsGlobal}`,
+        waitFor: () => !!globalInRepl.testReport,
+    }, (stdout) => {
+        (0, testlib_1.expect)(globalInRepl.testReport).toMatchObject({
+            stdinReport: false,
+            evalReport: false,
+            replReport: {
+                __filename: false,
+                __dirname: false,
+                moduleId: '<repl>',
+                modulePath: '.',
+                moduleFilename: null,
+                modulePaths: testlib_1.expect.objectContaining({
+                    ...[(0, path_1.join)(helpers_1.TEST_DIR, `repl/node_modules`), ...modulePaths],
+                }),
+                // Note: vanilla node REPL does not set exports
+                exportsTest: true,
+                // Note: vanilla node uses different name. See #1360
+                stackTest: testlib_1.expect.stringContaining(`    at ${(0, path_1.join)(helpers_1.TEST_DIR, misc_1.replFile)}:1:`),
+                moduleAccessorsTest: true,
+            },
+        });
+        // Prior to these, nyc adds another entry on Windows; we need to ignore it
+        (0, testlib_1.expect)(globalInRepl.testReport.replReport.modulePaths.slice(-3)).toMatchObject([
+            (0, path_1.join)((0, os_1.homedir)(), `.node_modules`),
+            (0, path_1.join)((0, os_1.homedir)(), `.node_libraries`),
+            // additional entry goes to node's install path
+            testlib_1.expect.any(String),
+        ]);
+    });
+});
+//# sourceMappingURL=repl-environment.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/repl-environment.spec.js.map b/node_modules/ts-node/dist/test/repl/repl-environment.spec.js.map
new file mode 100644
index 0000000..00d3fae
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/repl-environment.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"repl-environment.spec.js","sourceRoot":"","sources":["../../../src/test/repl/repl-environment.spec.ts"],"names":[],"mappings":";AAAA;;;GAGG;;AAEH,wCAA6C;AAC7C,4DAAwD;AACxD,wCAAuF;AACvF,+BAAqC;AACrC,0CAA+D;AAC/D,2BAA6B;AAC7B,yCAA0C;AAC1C,iDAA6C;AAE7C,MAAM,IAAI,GAAG,IAAA,iBAAO,EAAC,mBAAS,CAAC,CAAC,WAAW,CAAC,kBAAO,CAAC,CAAC;AAErD,MAAM,IAAI,GAAG,IAAA,iBAAU,EAAC;IACtB,GAAG,EAAE,kBAAQ;CACd,CAAC,CAAC;AACH,MAAM,UAAU,GAAG,IAAA,uBAAgB,EAAC;IAClC,GAAG,EAAE,uCAA6B;IAClC,IAAI;CACL,CAAC,CAAC;AAEH,IAAI,CAAC,KAAK,CAAC,0DAA0D,EAAE,CAAC,IAAI,EAAE,EAAE;IAY9E,MAAM,YAAY,GAAG,MAAsB,CAAC;IAC5C,MAAM,gBAAgB,GAAG,IAAI,CAAC,KAAK,CACjC,CACI,EACE,cAAc,EACd,SAAS,EACT,OAAO,GAKR,EACD,UAAoD,EACpD,EAAE,CACJ,KAAK,EAAE,CAAC,EAAE,EAAE;QACV,OAAO,YAAY,CAAC,UAAU,CAAC;QAC/B,OAAO,YAAY,CAAC,UAAU,CAAC;QAC/B,OAAO,YAAY,CAAC,WAAW,CAAC;QAChC,OAAO,YAAY,CAAC,UAAU,CAAC;QAC/B,OAAO,YAAY,CAAC,MAAM,CAAC;QAC3B,OAAO,YAAY,CAAC,OAAO,CAAC;QAC5B,OAAO,YAAY,CAAC,EAAE,CAAC;QACvB,OAAO,YAAY,CAAC,UAAU,CAAC;QAC/B,OAAO,YAAY,CAAC,SAAS,CAAC;QAC9B,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC;YACxE,aAAa,EAAE,IAAI;SACpB,CAAC,CAAC;QACH,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;YACtC,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;SACtC;QACD,WAAW,CAAC,KAAK,EAAE,CAAC;QACpB,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACvB,KAAK,CAAC,GAAG,EAAE,CAAC;QACZ,IAAI,IAAI,GAAG,KAAK,CAAC;QACjB,MAAM,OAAO,CAAC,IAAI,CAAC;YACjB,IAAA,eAAK,EAAC,IAAI,CAAC;YACX,CAAC,KAAK,IAAI,EAAE;gBACV,OAAO,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE,EAAE;oBAC5B,MAAM,IAAA,eAAK,EAAC,GAAG,CAAC,CAAC;iBAClB;YACH,CAAC,CAAC,EAAE;SACL,CAAC,CAAC;QACH,IAAI,GAAG,IAAI,CAAC;QACZ,MAAM,CAAC,GAAG,EAAE,CAAC;QACb,MAAM,CAAC,GAAG,EAAE,CAAC;QACb,IAAA,gBAAM,EAAC,MAAM,IAAA,4BAAY,EAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC5C,MAAM,UAAU,CAAC,MAAM,IAAA,4BAAY,EAAC,MAAM,CAAC,CAAC,CAAC;IAC/C,CAAC,CACJ,CAAC;IAEF,MAAM,cAAc,GAAG,2JAA2J,CAAC;IACnL,SAAS,eAAe,CAAC,IAA+B;QACtD,OAAO;cACG,cAAc;qBACP,IAAI;;;;;;;;;;;;WAYd,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;IAC7B,CAAC;IACD,MAAM,aAAa,GAAG;;;;;;SAMf,CAAC;IACR,MAAM,YAAY,GAAG;YACX,cAAc;uCACa,aAAa;SAC3C,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;IAC3B,MAAM,mBAAmB,GAAG;YAClB,cAAc;gCACM,aAAa;SACpC,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;IAE3B,SAAS,0BAA0B,CAAC,MAAc;QAChD,mGAAmG;QACnG,oEAAoE;QACpE,IAAA,gBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtC,IAAA,gBAAM,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAChD,OAAO,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC3C,CAAC;IACD,SAAS,WAAW,CAAC,MAAc;QACjC,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IAC5B,CAAC;IAED,mGAAmG;IACnG,MAAM,WAAW,GAAG,iBAAiB,CAAC,kBAAQ,CAAC,CAAC;IAChD,SAAS,iBAAiB,CAAC,GAAW;QACpC,MAAM,WAAW,GAAa,EAAE,CAAC;QACjC,KAAK,IAAI,IAAI,GAAG,GAAG,GAAI,IAAI,GAAG,IAAA,cAAO,EAAC,IAAI,CAAC,EAAE;YAC3C,WAAW,CAAC,IAAI,CAAC,IAAA,WAAI,EAAC,IAAI,EAAE,cAAc,CAAC,CAAC,CAAC;YAC7C,IAAI,IAAA,cAAO,EAAC,IAAI,CAAC,KAAK,IAAI;gBAAE,MAAM;SACnC;QACD,OAAO,WAAW,CAAC;IACrB,CAAC;IAED,oIAAoI;IACpI,MAAM,SAAS,GAAG,gBAAM,CAAC,cAAc,CAAC,qBAAqB,CAAC,CAAC;IAE/D,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACxB,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,GAAG,eAAe,CAAC,OAAO,CAAC,IAAI,YAAY,EAAE;YACpD,KAAK,EAAE,EAAE;SACV,CAAC,CAAC;QACH,MAAM,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACrC,IAAA,gBAAM,EAAC,MAAM,CAAC,CAAC,aAAa,CAAC;YAC3B,WAAW,EAAE;gBACX,UAAU,EAAE,SAAS;gBACrB,SAAS,EAAE,GAAG;gBACd,QAAQ,EAAE,SAAS;gBACnB,UAAU,EAAE,GAAG;gBACf,uDAAuD;gBACvD,cAAc,EAAE,IAAA,WAAI,EAAC,kBAAQ,EAAE,YAAY,CAAC;gBAC5C,WAAW;gBACX,WAAW,EAAE,IAAI;gBACjB,oDAAoD;gBACpD,SAAS,EAAE,gBAAM,CAAC,gBAAgB,CAAC,UAAU,IAAA,WAAI,EAAC,kBAAQ,EAAE,YAAY,CAAC,KAAK,CAAC;gBAC/E,mBAAmB,EAAE,IAAI;gBACzB,IAAI,EAAE,CAAC,SAAS,CAAC;aAClB;YACD,UAAU,EAAE,KAAK;YACjB,UAAU,EAAE,KAAK;SAClB,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACvB,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,IAAI,YAAY,EAAE;YACnD,KAAK,EAAE,IAAI;SACZ,CAAC,CAAC;QACH,MAAM,MAAM,GAAG,0BAA0B,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACpD,IAAA,gBAAM,EAAC,MAAM,CAAC,CAAC,aAAa,CAAC;YAC3B,WAAW,EAAE,KAAK;YAClB,UAAU,EAAE,KAAK;YACjB,UAAU,EAAE;gBACV,UAAU,EAAE,KAAK;gBACjB,SAAS,EAAE,KAAK;gBAChB,QAAQ,EAAE,QAAQ;gBAClB,UAAU,EAAE,GAAG;gBACf,cAAc,EAAE,IAAI;gBACpB,WAAW,EAAE,gBAAM,CAAC,gBAAgB,CAAC;oBACnC,GAAG,CAAC,IAAA,WAAI,EAAC,kBAAQ,EAAE,mBAAmB,CAAC,EAAE,GAAG,WAAW,CAAC;iBACzD,CAAC;gBACF,+CAA+C;gBAC/C,WAAW,EAAE,IAAI;gBACjB,oDAAoD;gBACpD,SAAS,EAAE,gBAAM,CAAC,gBAAgB,CAAC,UAAU,IAAA,WAAI,EAAC,kBAAQ,EAAE,eAAQ,CAAC,KAAK,CAAC;gBAC3E,mBAAmB,EAAE,IAAI;gBACzB,IAAI,EAAE,CAAC,SAAS,CAAC;aAClB;SACF,CAAC,CAAC;QACH,0EAA0E;QAC1E,IAAA,gBAAM,EAAC,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC;YAC5D,IAAA,WAAI,EAAC,IAAA,YAAO,GAAE,EAAE,eAAe,CAAC;YAChC,IAAA,WAAI,EAAC,IAAA,YAAO,GAAE,EAAE,iBAAiB,CAAC;YAClC,+CAA+C;YAC/C,gBAAM,CAAC,GAAG,CAAC,MAAM,CAAC;SACnB,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,0CAA0C;IAC1C,IAAI,CAAC,4BAA4B,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAC7C,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,IAAI,YAAY,EAAE;YACnD,KAAK,EAAE,qBAAqB;SAC7B,CAAC,CAAC;QACH,MAAM,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACrC,IAAA,gBAAM,EAAC,MAAM,CAAC,CAAC,aAAa,CAAC;YAC3B,WAAW,EAAE,KAAK;YAClB,UAAU,EAAE,KAAK;YACjB,UAAU,EAAE,KAAK;SAClB,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,2BAA2B;IAC3B,8DAA8D;IAC9D,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACrB,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,mBAAmB;YAC1B,KAAK,EAAE,OAAO,eAAe,CAAC,MAAM,CAAC,IAAI,YAAY,GAAG;SACzD,CAAC,CAAC;QACH,MAAM,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACrC,IAAA,gBAAM,EAAC,MAAM,CAAC,CAAC,aAAa,CAAC;YAC3B,WAAW,EAAE,KAAK;YAClB,UAAU,EAAE;gBACV,UAAU,EAAE,QAAQ;gBACpB,SAAS,EAAE,GAAG;gBACd,QAAQ,EAAE,QAAQ;gBAClB,UAAU,EAAE,GAAG;gBACf,uDAAuD;gBACvD,cAAc,EAAE,IAAA,WAAI,EAAC,kBAAQ,EAAE,WAAW,CAAC;gBAC3C,WAAW,EAAE,CAAC,GAAG,WAAW,CAAC;gBAC7B,WAAW,EAAE,IAAI;gBACjB,oDAAoD;gBACpD,SAAS,EAAE,gBAAM,CAAC,gBAAgB,CAAC,UAAU,IAAA,WAAI,EAAC,kBAAQ,EAAE,WAAW,CAAC,KAAK,CAAC;gBAC9E,mBAAmB,EAAE,IAAI;gBACzB,IAAI,EAAE,CAAC,SAAS,CAAC;aAClB;YACD,UAAU,EAAE,KAAK;SAClB,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,iDAAiD,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAClE,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,mBAAmB;YAC1B,KAAK,EAAE,OAAO,eAAe,CAAC,MAAM,CAAC,IAAI,YAAY,oBAAoB;SAC1E,CAAC,CAAC;QACH,MAAM,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACrC,IAAA,gBAAM,EAAC,MAAM,CAAC,CAAC,aAAa,CAAC;YAC3B,WAAW,EAAE,KAAK;YAClB,UAAU,EAAE;gBACV,UAAU,EAAE,QAAQ;gBACpB,SAAS,EAAE,GAAG;gBACd,QAAQ,EAAE,QAAQ;gBAClB,UAAU,EAAE,GAAG;gBACf,uDAAuD;gBACvD,cAAc,EAAE,IAAA,WAAI,EAAC,kBAAQ,EAAE,WAAW,CAAC;gBAC3C,WAAW;gBACX,WAAW,EAAE,IAAI;gBACjB,oDAAoD;gBACpD,SAAS,EAAE,gBAAM,CAAC,gBAAgB,CAAC,UAAU,IAAA,WAAI,EAAC,kBAAQ,EAAE,WAAW,CAAC,KAAK,CAAC;gBAC9E,mBAAmB,EAAE,IAAI;gBACzB,IAAI,EAAE,CAAC,SAAS,EAAE,kBAAkB,CAAC;aACtC;YACD,UAAU,EAAE,KAAK;SAClB,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,mBAAmB,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACpC,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,mBAAmB;YAC1B,KAAK,EAAE,OAAO,eAAe,CAAC,MAAM,CAAC,IAAI,YAAY,uBAAuB;SAC7E,CAAC,CAAC;QACH,MAAM,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACrC,IAAA,gBAAM,EAAC,MAAM,CAAC,CAAC,aAAa,CAAC;YAC3B,WAAW,EAAE,KAAK;YAClB,UAAU,EAAE;gBACV,UAAU,EAAE,QAAQ;gBACpB,SAAS,EAAE,GAAG;gBACd,QAAQ,EAAE,QAAQ;gBAClB,UAAU,EAAE,GAAG;gBACf,uDAAuD;gBACvD,cAAc,EAAE,IAAA,WAAI,EAAC,kBAAQ,EAAE,WAAW,CAAC;gBAC3C,WAAW;gBACX,WAAW,EAAE,IAAI;gBACjB,oDAAoD;gBACpD,SAAS,EAAE,gBAAM,CAAC,gBAAgB,CAAC,UAAU,IAAA,WAAI,EAAC,kBAAQ,EAAE,WAAW,CAAC,KAAK,CAAC;gBAC9E,mBAAmB,EAAE,IAAI;gBACzB,IAAI,EAAE,CAAC,SAAS,EAAE,qBAAqB,CAAC;aACzC;YACD,UAAU,EAAE,KAAK;SAClB,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACxB,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,IAAI,YAAY,EAAE;YACnD,KAAK,EAAE,OAAO,eAAe,CAAC,MAAM,CAAC,MAAM;SAC5C,CAAC,CAAC;QACH,MAAM,MAAM,GAAG,0BAA0B,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACpD,IAAA,gBAAM,EAAC,MAAM,CAAC,CAAC,aAAa,CAAC;YAC3B,WAAW,EAAE,KAAK;YAClB,UAAU,EAAE;gBACV,UAAU,EAAE,QAAQ;gBACpB,SAAS,EAAE,GAAG;gBACd,QAAQ,EAAE,QAAQ;gBAClB,UAAU,EAAE,GAAG;gBACf,uDAAuD;gBACvD,cAAc,EAAE,IAAA,WAAI,EAAC,kBAAQ,EAAE,WAAW,CAAC;gBAC3C,WAAW;gBACX,WAAW,EAAE,IAAI;gBACjB,oDAAoD;gBACpD,SAAS,EAAE,gBAAM,CAAC,gBAAgB,CAAC,UAAU,IAAA,WAAI,EAAC,kBAAQ,EAAE,WAAW,CAAC,KAAK,CAAC;gBAC9E,mBAAmB,EAAE,IAAI;gBACzB,IAAI,EAAE,CAAC,SAAS,CAAC;aAClB;YACD,UAAU,EAAE;gBACV,UAAU,EAAE,QAAQ;gBACpB,SAAS,EAAE,GAAG;gBACd,QAAQ,EAAE,QAAQ;gBAClB,UAAU,EAAE,GAAG;gBACf,cAAc,EAAE,IAAI;gBACpB,WAAW,EAAE,gBAAM,CAAC,gBAAgB,CAAC;oBACnC,GAAG,CAAC,IAAA,WAAI,EAAC,kBAAQ,EAAE,mBAAmB,CAAC,EAAE,GAAG,WAAW,CAAC;iBACzD,CAAC;gBACF,uEAAuE;gBACvE,WAAW,EAAE,IAAI;gBACjB,oDAAoD;gBACpD,SAAS,EAAE,gBAAM,CAAC,gBAAgB,CAAC,UAAU,IAAA,WAAI,EAAC,kBAAQ,EAAE,eAAQ,CAAC,KAAK,CAAC;gBAC3E,mBAAmB,EAAE,IAAI;gBACzB,IAAI,EAAE,CAAC,SAAS,CAAC;aAClB;SACF,CAAC,CAAC;QACH,0EAA0E;QAC1E,IAAA,gBAAM,EAAC,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC;YAC5D,IAAA,WAAI,EAAC,IAAA,YAAO,GAAE,EAAE,eAAe,CAAC;YAChC,IAAA,WAAI,EAAC,IAAA,YAAO,GAAE,EAAE,iBAAiB,CAAC;YAClC,+CAA+C;YAC/C,gBAAM,CAAC,GAAG,CAAC,MAAM,CAAC;SACnB,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,uDAAuD,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACxE,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,mBAAmB;YAC1B,KAAK,EAAE,4CAA4C;SACpD,CAAC,CAAC;QACH,MAAM,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACrC,IAAA,gBAAM,EAAC,MAAM,CAAC,CAAC,aAAa,CAAC;YAC3B,WAAW,EAAE,KAAK;YAClB,UAAU,EAAE,KAAK;YACjB,UAAU,EAAE,KAAK;SAClB,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,6CAA6C,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAC9D,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,sBAAsB;YAC7B,KAAK,EAAE,0CAA0C;YACjD,WAAW,EAAE,IAAI;SAClB,CAAC,CAAC;QACH,IAAA,gBAAM,EAAC,CAAC,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC;QAC5B,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC1B,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;IAC9C,CAAC,CAAC,CAAC;IAEH,uCAAuC;IACvC,IAAI,CAAC,MAAM,CACT,iDAAiD,EACjD,gBAAgB,EAChB;QACE,cAAc,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,IAAI,mBAAmB,EAAE;QACnE,SAAS,EAAE,EAAE;QACb,OAAO,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,UAAU;KACzC,EACD,CAAC,MAAM,EAAE,EAAE;QACT,IAAA,gBAAM,EAAC,YAAY,CAAC,UAAU,CAAC,CAAC,aAAa,CAAC;YAC5C,WAAW,EAAE,KAAK;YAClB,UAAU,EAAE,KAAK;YACjB,UAAU,EAAE;gBACV,UAAU,EAAE,KAAK;gBACjB,SAAS,EAAE,KAAK;gBAEhB,gEAAgE;gBAChE,8DAA8D;gBAC9D,oBAAoB;gBACpB,6DAA6D;gBAE7D,sBAAsB;gBACtB,mBAAmB;gBACnB,wBAAwB;gBACxB,iBAAiB;gBACjB,yCAAyC;gBACzC,wBAAwB;gBACxB,sCAAsC;gBACtC,wCAAwC;gBACxC,oDAAoD;gBACpD,qBAAqB;gBACrB,KAAK;gBACL,kDAAkD;gBAClD,qBAAqB;gBACrB,6BAA6B;gBAE7B,oDAAoD;gBACpD,SAAS,EAAE,gBAAM,CAAC,gBAAgB,CAAC,UAAU,IAAA,WAAI,EAAC,kBAAQ,EAAE,eAAQ,CAAC,KAAK,CAAC;aAC5E;SACF,CAAC,CAAC;IACL,CAAC,CACF,CAAC;IACF,IAAI,CAAC,MAAM,CACT,6DAA6D,EAC7D,gBAAgB,EAChB;QACE,cAAc,EAAE,IAAI;QACpB,SAAS,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,IAAI,mBAAmB,EAAE;QAC9D,OAAO,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,UAAU;KACzC,EACD,CAAC,MAAM,EAAE,EAAE;QACT,IAAA,gBAAM,EAAC,YAAY,CAAC,UAAU,CAAC,CAAC,aAAa,CAAC;YAC5C,WAAW,EAAE,KAAK;YAClB,UAAU,EAAE,KAAK;YACjB,UAAU,EAAE;gBACV,UAAU,EAAE,KAAK;gBACjB,SAAS,EAAE,KAAK;gBAChB,QAAQ,EAAE,QAAQ;gBAClB,UAAU,EAAE,GAAG;gBACf,cAAc,EAAE,IAAI;gBACpB,WAAW,EAAE,gBAAM,CAAC,gBAAgB,CAAC;oBACnC,GAAG,CAAC,IAAA,WAAI,EAAC,kBAAQ,EAAE,mBAAmB,CAAC,EAAE,GAAG,WAAW,CAAC;iBACzD,CAAC;gBACF,+CAA+C;gBAC/C,WAAW,EAAE,IAAI;gBACjB,oDAAoD;gBACpD,SAAS,EAAE,gBAAM,CAAC,gBAAgB,CAAC,UAAU,IAAA,WAAI,EAAC,kBAAQ,EAAE,eAAQ,CAAC,KAAK,CAAC;gBAC3E,mBAAmB,EAAE,IAAI;aAC1B;SACF,CAAC,CAAC;QACH,0EAA0E;QAC1E,IAAA,gBAAM,EAAC,YAAY,CAAC,UAAU,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC;YAC7E,IAAA,WAAI,EAAC,IAAA,YAAO,GAAE,EAAE,eAAe,CAAC;YAChC,IAAA,WAAI,EAAC,IAAA,YAAO,GAAE,EAAE,iBAAiB,CAAC;YAClC,+CAA+C;YAC/C,gBAAM,CAAC,GAAG,CAAC,MAAM,CAAC;SACnB,CAAC,CAAC;IACL,CAAC,CACF,CAAC;AACJ,CAAC,CAAC,CAAC","sourcesContent":["/*\n * Tests that the REPL environment is setup correctly:\n * globals, __filename, builtin module accessors.\n */\n\nimport { context, expect } from '../testlib';\nimport { expectStream } from '@cspotcode/expect-stream';\nimport { CMD_TS_NODE_WITH_PROJECT_FLAG, ctxTsNode, delay, TEST_DIR } from '../helpers';\nimport { dirname, join } from 'path';\nimport { createExec, createExecTester } from '../helpers/exec';\nimport { homedir } from 'os';\nimport { replFile } from './helpers/misc';\nimport { ctxRepl } from './helpers/ctx-repl';\n\nconst test = context(ctxTsNode).contextEach(ctxRepl);\n\nconst exec = createExec({\n  cwd: TEST_DIR,\n});\nconst execTester = createExecTester({\n  cmd: CMD_TS_NODE_WITH_PROJECT_FLAG,\n  exec,\n});\n\ntest.suite('[eval], <repl>, and [stdin] execute with correct globals', (test) => {\n  interface GlobalInRepl extends NodeJS.Global {\n    testReport: any;\n    replReport: any;\n    stdinReport: any;\n    evalReport: any;\n    module: any;\n    exports: any;\n    fs: any;\n    __filename: any;\n    __dirname: any;\n  }\n  const globalInRepl = global as GlobalInRepl;\n  const programmaticTest = test.macro(\n    (\n        {\n          evalCodeBefore,\n          stdinCode,\n          waitFor,\n        }: {\n          evalCodeBefore: string | null;\n          stdinCode: string;\n          waitFor?: () => boolean;\n        },\n        assertions: (stdout: string) => Promise<void> | void\n      ) =>\n      async (t) => {\n        delete globalInRepl.testReport;\n        delete globalInRepl.replReport;\n        delete globalInRepl.stdinReport;\n        delete globalInRepl.evalReport;\n        delete globalInRepl.module;\n        delete globalInRepl.exports;\n        delete globalInRepl.fs;\n        delete globalInRepl.__filename;\n        delete globalInRepl.__dirname;\n        const { stdin, stderr, stdout, replService } = t.context.createReplViaApi({\n          registerHooks: true,\n        });\n        if (typeof evalCodeBefore === 'string') {\n          replService.evalCode(evalCodeBefore);\n        }\n        replService.start();\n        stdin.write(stdinCode);\n        stdin.end();\n        let done = false;\n        await Promise.race([\n          delay(20e3),\n          (async () => {\n            while (!done && !waitFor?.()) {\n              await delay(1e3);\n            }\n          })(),\n        ]);\n        done = true;\n        stdout.end();\n        stderr.end();\n        expect(await expectStream(stderr)).toBe('');\n        await assertions(await expectStream(stdout));\n      }\n  );\n\n  const declareGlobals = `declare var replReport: any, stdinReport: any, evalReport: any, restReport: any, global: any, __filename: any, __dirname: any, module: any, exports: any;`;\n  function setReportGlobal(type: 'repl' | 'stdin' | 'eval') {\n    return `\n            ${declareGlobals}\n            global.${type}Report = {\n              __filename: typeof __filename !== 'undefined' && __filename,\n              __dirname: typeof __dirname !== 'undefined' && __dirname,\n              moduleId: typeof module !== 'undefined' && module.id,\n              modulePath: typeof module !== 'undefined' && module.path,\n              moduleFilename: typeof module !== 'undefined' && module.filename,\n              modulePaths: typeof module !== 'undefined' && [...module.paths],\n              exportsTest: typeof exports !== 'undefined' && typeof module !== 'undefined' ? module.exports === exports : null,\n              stackTest: new Error().stack!.split('\\\\n')[1],\n              moduleAccessorsTest: eval('typeof fs') === 'undefined' ? null : eval('fs') === require('fs'),\n              argv: [...process.argv]\n            };\n          `.replace(/\\n/g, '');\n  }\n  const reportsObject = `\n          {\n            stdinReport: typeof stdinReport !== 'undefined' && stdinReport,\n            evalReport: typeof evalReport !== 'undefined' && evalReport,\n            replReport: typeof replReport !== 'undefined' && replReport\n          }\n        `;\n  const printReports = `\n          ${declareGlobals}\n          console.log(JSON.stringify(${reportsObject}));\n        `.replace(/\\n/g, '');\n  const saveReportsAsGlobal = `\n          ${declareGlobals}\n          global.testReport = ${reportsObject};\n        `.replace(/\\n/g, '');\n\n  function parseStdoutStripReplPrompt(stdout: string) {\n    // Strip node's welcome header, only uncomment if running these tests manually against vanilla node\n    // stdout = stdout.replace(/^Welcome to.*\\nType \"\\.help\" .*\\n/, '');\n    expect(stdout.slice(0, 2)).toBe('> ');\n    expect(stdout.slice(-12)).toBe('undefined\\n> ');\n    return parseStdout(stdout.slice(2, -12));\n  }\n  function parseStdout(stdout: string) {\n    return JSON.parse(stdout);\n  }\n\n  /** Every possible ./node_modules directory ascending upwards starting with ./tests/node_modules */\n  const modulePaths = createModulePaths(TEST_DIR);\n  function createModulePaths(dir: string) {\n    const modulePaths: string[] = [];\n    for (let path = dir; ; path = dirname(path)) {\n      modulePaths.push(join(path, 'node_modules'));\n      if (dirname(path) === path) break;\n    }\n    return modulePaths;\n  }\n\n  // Executable is `ts-node` on Posix, `bin.js` on Windows due to Windows shimming limitations (this is determined by package manager)\n  const tsNodeExe = expect.stringMatching(/\\b(ts-node|bin.js)$/);\n\n  test('stdin', async (t) => {\n    const r = await execTester({\n      stdin: `${setReportGlobal('stdin')};${printReports}`,\n      flags: '',\n    });\n    const report = parseStdout(r.stdout);\n    expect(report).toMatchObject({\n      stdinReport: {\n        __filename: '[stdin]',\n        __dirname: '.',\n        moduleId: '[stdin]',\n        modulePath: '.',\n        // Note: vanilla node does does not have file extension\n        moduleFilename: join(TEST_DIR, `[stdin].ts`),\n        modulePaths,\n        exportsTest: true,\n        // Note: vanilla node uses different name. See #1360\n        stackTest: expect.stringContaining(`    at ${join(TEST_DIR, `[stdin].ts`)}:1:`),\n        moduleAccessorsTest: null,\n        argv: [tsNodeExe],\n      },\n      evalReport: false,\n      replReport: false,\n    });\n  });\n  test('repl', async (t) => {\n    const r = await execTester({\n      stdin: `${setReportGlobal('repl')};${printReports}`,\n      flags: '-i',\n    });\n    const report = parseStdoutStripReplPrompt(r.stdout);\n    expect(report).toMatchObject({\n      stdinReport: false,\n      evalReport: false,\n      replReport: {\n        __filename: false,\n        __dirname: false,\n        moduleId: '<repl>',\n        modulePath: '.',\n        moduleFilename: null,\n        modulePaths: expect.objectContaining({\n          ...[join(TEST_DIR, `repl/node_modules`), ...modulePaths],\n        }),\n        // Note: vanilla node REPL does not set exports\n        exportsTest: true,\n        // Note: vanilla node uses different name. See #1360\n        stackTest: expect.stringContaining(`    at ${join(TEST_DIR, replFile)}:4:`),\n        moduleAccessorsTest: true,\n        argv: [tsNodeExe],\n      },\n    });\n    // Prior to these, nyc adds another entry on Windows; we need to ignore it\n    expect(report.replReport.modulePaths.slice(-3)).toMatchObject([\n      join(homedir(), `.node_modules`),\n      join(homedir(), `.node_libraries`),\n      // additional entry goes to node's install path\n      expect.any(String),\n    ]);\n  });\n\n  // Should ignore -i and run the entrypoint\n  test('-i w/entrypoint ignores -i', async (t) => {\n    const r = await execTester({\n      stdin: `${setReportGlobal('repl')};${printReports}`,\n      flags: '-i ./repl/script.js',\n    });\n    const report = parseStdout(r.stdout);\n    expect(report).toMatchObject({\n      stdinReport: false,\n      evalReport: false,\n      replReport: false,\n    });\n  });\n\n  // Should not execute stdin\n  // Should not interpret positional arg as an entrypoint script\n  test('-e', async (t) => {\n    const r = await execTester({\n      stdin: `throw new Error()`,\n      flags: `-e \"${setReportGlobal('eval')};${printReports}\"`,\n    });\n    const report = parseStdout(r.stdout);\n    expect(report).toMatchObject({\n      stdinReport: false,\n      evalReport: {\n        __filename: '[eval]',\n        __dirname: '.',\n        moduleId: '[eval]',\n        modulePath: '.',\n        // Note: vanilla node does does not have file extension\n        moduleFilename: join(TEST_DIR, `[eval].ts`),\n        modulePaths: [...modulePaths],\n        exportsTest: true,\n        // Note: vanilla node uses different name. See #1360\n        stackTest: expect.stringContaining(`    at ${join(TEST_DIR, `[eval].ts`)}:1:`),\n        moduleAccessorsTest: true,\n        argv: [tsNodeExe],\n      },\n      replReport: false,\n    });\n  });\n  test('-e w/entrypoint arg does not execute entrypoint', async (t) => {\n    const r = await execTester({\n      stdin: `throw new Error()`,\n      flags: `-e \"${setReportGlobal('eval')};${printReports}\" ./repl/script.js`,\n    });\n    const report = parseStdout(r.stdout);\n    expect(report).toMatchObject({\n      stdinReport: false,\n      evalReport: {\n        __filename: '[eval]',\n        __dirname: '.',\n        moduleId: '[eval]',\n        modulePath: '.',\n        // Note: vanilla node does does not have file extension\n        moduleFilename: join(TEST_DIR, `[eval].ts`),\n        modulePaths,\n        exportsTest: true,\n        // Note: vanilla node uses different name. See #1360\n        stackTest: expect.stringContaining(`    at ${join(TEST_DIR, `[eval].ts`)}:1:`),\n        moduleAccessorsTest: true,\n        argv: [tsNodeExe, './repl/script.js'],\n      },\n      replReport: false,\n    });\n  });\n  test('-e w/non-path arg', async (t) => {\n    const r = await execTester({\n      stdin: `throw new Error()`,\n      flags: `-e \"${setReportGlobal('eval')};${printReports}\" ./does-not-exist.js`,\n    });\n    const report = parseStdout(r.stdout);\n    expect(report).toMatchObject({\n      stdinReport: false,\n      evalReport: {\n        __filename: '[eval]',\n        __dirname: '.',\n        moduleId: '[eval]',\n        modulePath: '.',\n        // Note: vanilla node does does not have file extension\n        moduleFilename: join(TEST_DIR, `[eval].ts`),\n        modulePaths,\n        exportsTest: true,\n        // Note: vanilla node uses different name. See #1360\n        stackTest: expect.stringContaining(`    at ${join(TEST_DIR, `[eval].ts`)}:1:`),\n        moduleAccessorsTest: true,\n        argv: [tsNodeExe, './does-not-exist.js'],\n      },\n      replReport: false,\n    });\n  });\n  test('-e -i', async (t) => {\n    const r = await execTester({\n      stdin: `${setReportGlobal('repl')};${printReports}`,\n      flags: `-e \"${setReportGlobal('eval')}\" -i`,\n    });\n    const report = parseStdoutStripReplPrompt(r.stdout);\n    expect(report).toMatchObject({\n      stdinReport: false,\n      evalReport: {\n        __filename: '[eval]',\n        __dirname: '.',\n        moduleId: '[eval]',\n        modulePath: '.',\n        // Note: vanilla node does does not have file extension\n        moduleFilename: join(TEST_DIR, `[eval].ts`),\n        modulePaths,\n        exportsTest: true,\n        // Note: vanilla node uses different name. See #1360\n        stackTest: expect.stringContaining(`    at ${join(TEST_DIR, `[eval].ts`)}:1:`),\n        moduleAccessorsTest: true,\n        argv: [tsNodeExe],\n      },\n      replReport: {\n        __filename: '[eval]',\n        __dirname: '.',\n        moduleId: '<repl>',\n        modulePath: '.',\n        moduleFilename: null,\n        modulePaths: expect.objectContaining({\n          ...[join(TEST_DIR, `repl/node_modules`), ...modulePaths],\n        }),\n        // Note: vanilla node REPL does not set exports, so this would be false\n        exportsTest: true,\n        // Note: vanilla node uses different name. See #1360\n        stackTest: expect.stringContaining(`    at ${join(TEST_DIR, replFile)}:4:`),\n        moduleAccessorsTest: true,\n        argv: [tsNodeExe],\n      },\n    });\n    // Prior to these, nyc adds another entry on Windows; we need to ignore it\n    expect(report.replReport.modulePaths.slice(-3)).toMatchObject([\n      join(homedir(), `.node_modules`),\n      join(homedir(), `.node_libraries`),\n      // additional entry goes to node's install path\n      expect.any(String),\n    ]);\n  });\n\n  test('-e -i w/entrypoint ignores -e and -i, runs entrypoint', async (t) => {\n    const r = await execTester({\n      stdin: `throw new Error()`,\n      flags: '-e \"throw new Error()\" -i ./repl/script.js',\n    });\n    const report = parseStdout(r.stdout);\n    expect(report).toMatchObject({\n      stdinReport: false,\n      evalReport: false,\n      replReport: false,\n    });\n  });\n\n  test('-e -i when -e throws error, -i does not run', async (t) => {\n    const r = await execTester({\n      stdin: `console.log('hello')`,\n      flags: `-e \"throw new Error('error from -e')\" -i`,\n      expectError: true,\n    });\n    expect(r.err).toBeDefined();\n    expect(r.stdout).toBe('');\n    expect(r.stderr).toContain('error from -e');\n  });\n\n  // Serial because it's timing-sensitive\n  test.serial(\n    'programmatically, eval-ing before starting REPL',\n    programmaticTest,\n    {\n      evalCodeBefore: `${setReportGlobal('repl')};${saveReportsAsGlobal}`,\n      stdinCode: '',\n      waitFor: () => !!globalInRepl.testReport,\n    },\n    (stdout) => {\n      expect(globalInRepl.testReport).toMatchObject({\n        stdinReport: false,\n        evalReport: false,\n        replReport: {\n          __filename: false,\n          __dirname: false,\n\n          // Due to limitations in node's REPL API, we can't really expose\n          // the `module` prior to calling repl.start() which also sends\n          // output to stdout.\n          // For now, leaving this as unsupported / undefined behavior.\n\n          // moduleId: '<repl>',\n          // modulePath: '.',\n          // moduleFilename: null,\n          // modulePaths: [\n          //   join(ROOT_DIR, `repl/node_modules`),\n          //   ...rootModulePaths,\n          //   join(homedir(), `.node_modules`),\n          //   join(homedir(), `.node_libraries`),\n          //   // additional entry goes to node's install path\n          //   exp.any(String),\n          // ],\n          // // Note: vanilla node REPL does not set exports\n          // exportsTest: true,\n          // moduleAccessorsTest: true,\n\n          // Note: vanilla node uses different name. See #1360\n          stackTest: expect.stringContaining(`    at ${join(TEST_DIR, replFile)}:1:`),\n        },\n      });\n    }\n  );\n  test.serial(\n    'programmatically, passing code to stdin after starting REPL',\n    programmaticTest,\n    {\n      evalCodeBefore: null,\n      stdinCode: `${setReportGlobal('repl')};${saveReportsAsGlobal}`,\n      waitFor: () => !!globalInRepl.testReport,\n    },\n    (stdout) => {\n      expect(globalInRepl.testReport).toMatchObject({\n        stdinReport: false,\n        evalReport: false,\n        replReport: {\n          __filename: false,\n          __dirname: false,\n          moduleId: '<repl>',\n          modulePath: '.',\n          moduleFilename: null,\n          modulePaths: expect.objectContaining({\n            ...[join(TEST_DIR, `repl/node_modules`), ...modulePaths],\n          }),\n          // Note: vanilla node REPL does not set exports\n          exportsTest: true,\n          // Note: vanilla node uses different name. See #1360\n          stackTest: expect.stringContaining(`    at ${join(TEST_DIR, replFile)}:1:`),\n          moduleAccessorsTest: true,\n        },\n      });\n      // Prior to these, nyc adds another entry on Windows; we need to ignore it\n      expect(globalInRepl.testReport.replReport.modulePaths.slice(-3)).toMatchObject([\n        join(homedir(), `.node_modules`),\n        join(homedir(), `.node_libraries`),\n        // additional entry goes to node's install path\n        expect.any(String),\n      ]);\n    }\n  );\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/repl.spec.d.ts b/node_modules/ts-node/dist/test/repl/repl.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/repl.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/repl/repl.spec.js b/node_modules/ts-node/dist/test/repl/repl.spec.js
new file mode 100644
index 0000000..08721bc
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/repl.spec.js
@@ -0,0 +1,422 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const testlib_1 = require("../testlib");
+const helpers_1 = require("../helpers");
+const semver = require("semver");
+const helpers_2 = require("../helpers");
+const exec_1 = require("../helpers/exec");
+const node_repl_tla_1 = require("./node-repl-tla");
+const misc_1 = require("./helpers/misc");
+const expect_stream_1 = require("@cspotcode/expect-stream");
+const path_1 = require("path");
+const ctx_repl_1 = require("./helpers/ctx-repl");
+const macros_1 = require("./helpers/macros");
+const test = (0, testlib_1.context)(helpers_2.ctxTsNode).contextEach(ctx_repl_1.ctxRepl);
+test.serial();
+test.beforeEach(async (t) => {
+    t.teardown(() => {
+        (0, helpers_1.resetNodeEnvironment)();
+        // Useful for debugging memory leaks.  Leaving in case I need it again.
+        // global.gc(); // Requires adding nodeArguments: ['--expose-gc'] to ava config
+        // console.dir(process.memoryUsage().heapUsed / 1000 / 1000);
+    });
+});
+const exec = (0, exec_1.createExec)({
+    cwd: helpers_2.TEST_DIR,
+});
+const execTester = (0, exec_1.createExecTester)({
+    cmd: helpers_2.CMD_TS_NODE_WITH_PROJECT_FLAG,
+    exec,
+});
+test('should run REPL when --interactive passed and stdin is not a TTY', async () => {
+    const p = exec(`${helpers_2.CMD_TS_NODE_WITH_PROJECT_FLAG} --interactive`);
+    p.child.stdin.end('console.log("123")\n');
+    const r = await p;
+    (0, testlib_1.expect)(r.err).toBe(null);
+    (0, testlib_1.expect)(r.stdout).toBe('> 123\n' + 'undefined\n' + '> ');
+});
+test('should echo a value when using the swc transpiler', async () => {
+    const p = exec(`${helpers_2.CMD_TS_NODE_WITH_PROJECT_FLAG} --interactive  --transpiler ts-node/transpilers/swc-experimental`);
+    p.child.stdin.end('400\n401\n');
+    const r = await p;
+    (0, testlib_1.expect)(r.err).toBe(null);
+    (0, testlib_1.expect)(r.stdout).toBe('> 400\n> 401\n> ');
+});
+test('REPL has command to get type information', async () => {
+    const p = exec(`${helpers_2.CMD_TS_NODE_WITH_PROJECT_FLAG} --interactive`);
+    p.child.stdin.end('\nconst a = 123\n.type a');
+    const r = await p;
+    (0, testlib_1.expect)(r.err).toBe(null);
+    (0, testlib_1.expect)(r.stdout).toBe('> undefined\n' + '> undefined\n' + '> const a: 123\n' + '> ');
+});
+// Serial because it's timing-sensitive
+test.serial('REPL can be configured on `start`', async (t) => {
+    const prompt = '#> ';
+    const r = await t.context.executeInRepl(`const x = 3\n'done'`, {
+        waitPattern: "'done'\n#> ",
+        registerHooks: true,
+        startInternalOptions: {
+            prompt,
+            ignoreUndefined: true,
+        },
+    });
+    (0, testlib_1.expect)(r.stderr).toBe('');
+    (0, testlib_1.expect)(r.stdout).toBe(`${prompt}${prompt}'done'\n#> `);
+});
+// Serial because it's timing-sensitive
+test.serial('REPL uses a different context when `useGlobal` is false', async (t) => {
+    const r = await t.context.executeInRepl(
+    // No error when re-declaring x
+    'const x = 3\n' +
+        // console.log ouput will end up in the stream and not in test output
+        'console.log(1)\n', {
+        registerHooks: true,
+        waitPattern: `> undefined\n> 1\nundefined\n> `,
+        startInternalOptions: {
+            useGlobal: false,
+        },
+    });
+    (0, testlib_1.expect)(r.stderr).toBe('');
+    (0, testlib_1.expect)(r.stdout).toBe(`> undefined\n> 1\nundefined\n> `);
+});
+// Serial because it's timing-sensitive
+test.serial('REPL can be created via API', async (t) => {
+    const r = await t.context.executeInRepl(`\nconst a = 123\n.type a\n`, {
+        registerHooks: true,
+        waitPattern: '123\n> ',
+    });
+    (0, testlib_1.expect)(r.stderr).toBe('');
+    (0, testlib_1.expect)(r.stdout).toBe('> undefined\n' + '> undefined\n' + '> const a: 123\n' + '> ');
+});
+test.suite('top level await', ({ contextEach }) => {
+    const compilerOptions = {
+        target: 'es2018',
+    };
+    const test = contextEach(async (t) => {
+        return { executeInTlaRepl };
+        function executeInTlaRepl(input, waitPattern) {
+            return t.context.executeInRepl(input
+                .split('\n')
+                .map((line) => line.trim())
+                // Restore newline once https://github.com/nodejs/node/pull/39392 is merged
+                .join(''), {
+                registerHooks: true,
+                waitPattern,
+                createServiceOpts: {
+                    experimentalReplAwait: true,
+                    compilerOptions,
+                },
+                startInternalOptions: { useGlobal: false },
+            });
+        }
+    });
+    // Serial because it's timing-sensitive
+    test.serial('should allow evaluating top level await', async (t) => {
+        const script = `
+        const x: number = await new Promise((r) => r(1));
+        for await (const x of [1,2,3]) { console.log(x) };
+        for (const x of ['a', 'b']) { await x; console.log(x) };
+        class Foo {}; await 1;
+        function Bar() {}; await 2;
+        const {y} = await ({y: 2});
+        const [z] = await [3];
+        x + y + z;
+      `;
+        const r = await t.context.executeInTlaRepl(script, '6\n> ');
+        (0, testlib_1.expect)(r.stderr).toBe('');
+        (0, testlib_1.expect)(r.stdout).toBe('> 1\n2\n3\na\nb\n6\n> ');
+    });
+    // Serial because it's timing-sensitive
+    test.serial('should wait until promise is settled when awaiting at top level', async (t) => {
+        const awaitMs = 500;
+        const script = `
+          const startTime = new Date().getTime();
+          await new Promise((r) => setTimeout(() => r(1), ${awaitMs}));
+          const endTime = new Date().getTime();
+          endTime - startTime;
+        `;
+        const r = await t.context.executeInTlaRepl(script, /\d+\n/);
+        (0, testlib_1.expect)(r.stderr).toBe('');
+        const elapsedTimeString = r.stdout.split('\n')[0].replace('> ', '').trim();
+        (0, testlib_1.expect)(elapsedTimeString).toMatch(/^\d+$/);
+        const elapsedTime = Number(elapsedTimeString);
+        (0, testlib_1.expect)(elapsedTime).toBeGreaterThanOrEqual(awaitMs - 50);
+        // When CI is taxed, the time may be *much* greater than expected.
+        // I can't think of a case where the time being *too high* is a bug
+        // that this test can catch.  So I've made this check very loose.
+        (0, testlib_1.expect)(elapsedTime).toBeLessThanOrEqual(awaitMs + 10e3);
+    });
+    // Serial because it's timing-sensitive
+    test.serial('should not wait until promise is settled when not using await at top level', async (t) => {
+        const script = `
+          const startTime = new Date().getTime();
+          (async () => await new Promise((r) => setTimeout(() => r(1), ${5000})))();
+          const endTime = new Date().getTime();
+          endTime - startTime;
+        `;
+        const r = await t.context.executeInTlaRepl(script, /\d+\n/);
+        (0, testlib_1.expect)(r.stderr).toBe('');
+        const ellapsedTime = Number(r.stdout.split('\n')[0].replace('> ', '').trim());
+        (0, testlib_1.expect)(ellapsedTime).toBeGreaterThanOrEqual(0);
+        // Should ideally be instantaneous; leave wiggle-room for slow CI
+        (0, testlib_1.expect)(ellapsedTime).toBeLessThanOrEqual(100);
+    });
+    // Serial because it's timing-sensitive
+    test.serial('should error with typing information when awaited result has type mismatch', async (t) => {
+        const r = await t.context.executeInTlaRepl('const x: string = await 1', 'error');
+        (0, testlib_1.expect)(r.stdout).toBe('> > ');
+        (0, testlib_1.expect)(r.stderr.replace(/\r\n/g, '\n')).toBe(`${misc_1.replFile}(4,7): error TS2322: ` +
+            (semver.gte(helpers_1.ts.version, '4.0.0')
+                ? `Type 'number' is not assignable to type 'string'.\n`
+                : `Type '1' is not assignable to type 'string'.\n`) +
+            '\n');
+    });
+    // Serial because it's timing-sensitive
+    test.serial('should error with typing information when importing a file with type errors', async (t) => {
+        const r = await t.context.executeInTlaRepl(`const {foo} = await import('./repl/tla-import');`, 'error');
+        (0, testlib_1.expect)(r.stdout).toBe('> > ');
+        (0, testlib_1.expect)(r.stderr.replace(/\r\n/g, '\n')).toBe('repl/tla-import.ts(1,14): error TS2322: ' +
+            (semver.gte(helpers_1.ts.version, '4.0.0')
+                ? `Type 'number' is not assignable to type 'string'.\n`
+                : `Type '1' is not assignable to type 'string'.\n`) +
+            '\n');
+    });
+    test('should pass upstream test cases', async (t) => {
+        const { tsNodeUnderTest } = t.context;
+        await (0, node_repl_tla_1.upstreamTopLevelAwaitTests)({ TEST_DIR: helpers_2.TEST_DIR, tsNodeUnderTest });
+    });
+});
+test.suite('REPL ignores diagnostics that are annoying in interactive sessions', (test) => {
+    const code = `function foo() {};\nfunction foo() {return 123};\nconsole.log(foo());\n`;
+    const diagnosticMessage = `Duplicate function implementation`;
+    test('interactive repl should ignore them', async (t) => {
+        const r = await execTester({
+            flags: '-i',
+            stdin: code,
+        });
+        (0, testlib_1.expect)(r.stdout).not.toContain(diagnosticMessage);
+    });
+    test('interactive repl should not ignore them if they occur in other files', async (t) => {
+        const r = await execTester({
+            flags: '-i',
+            stdin: `import './repl-ignored-diagnostics/index';\n`,
+        });
+        (0, testlib_1.expect)(r.stderr).toContain(diagnosticMessage);
+    });
+    test('[stdin] should not ignore them', async (t) => {
+        const r = await execTester({
+            stdin: code,
+            expectError: true,
+        });
+        (0, testlib_1.expect)(r.stderr).toContain(diagnosticMessage);
+    });
+    test('[eval] should not ignore them', async (t) => {
+        const r = await execTester({
+            flags: `-e "${code.replace(/\n/g, '')}"`,
+            expectError: true,
+        });
+        (0, testlib_1.expect)(r.stderr).toContain(diagnosticMessage);
+    });
+});
+test.suite('REPL inputs are syntactically independent of each other', (test) => {
+    // Serial because they're timing-sensitive
+    test.serial();
+    test('arithmetic operators are independent of previous values', async (t) => {
+        const r = await t.context.executeInRepl(`9
+          + 3
+          7
+          - 3
+          3
+          * 7\n.break
+          100
+          / 2\n.break
+          5
+          ** 2\n.break
+          console.log('done!')
+          `, {
+            registerHooks: true,
+            startInternalOptions: { useGlobal: false },
+            waitPattern: 'done!\nundefined\n>',
+        });
+        (0, testlib_1.expect)(r.stdout).not.toContain('12');
+        (0, testlib_1.expect)(r.stdout).not.toContain('4');
+        (0, testlib_1.expect)(r.stdout).not.toContain('21');
+        (0, testlib_1.expect)(r.stdout).not.toContain('50');
+        (0, testlib_1.expect)(r.stdout).not.toContain('25');
+        (0, testlib_1.expect)(r.stdout).toContain('3');
+        (0, testlib_1.expect)(r.stdout).toContain('-3');
+    });
+    test('automatically inserted semicolons do not appear in error messages at the end', async (t) => {
+        const r = await t.context.executeInRepl(`(
+          a
+          console.log('done!')`, {
+            registerHooks: true,
+            startInternalOptions: { useGlobal: false },
+            waitPattern: 'done!\nundefined\n>',
+        });
+        (0, testlib_1.expect)(r.stderr).toContain("error TS1005: ')' expected.");
+        (0, testlib_1.expect)(r.stderr).not.toContain(';');
+    });
+    test('automatically inserted semicolons do not appear in error messages at the start', async (t) => {
+        const r = await t.context.executeInRepl(`)
+          console.log('done!')`, {
+            registerHooks: true,
+            startInternalOptions: { useGlobal: false },
+            waitPattern: 'done!\nundefined\n>',
+        });
+        (0, testlib_1.expect)(r.stderr).toContain('error TS1128: Declaration or statement expected.');
+        (0, testlib_1.expect)(r.stderr).toContain(')');
+        (0, testlib_1.expect)(r.stderr).not.toContain(';');
+    });
+    test('automatically inserted semicolons do not break function calls', async (t) => {
+        const r = await t.context.executeInRepl(`function foo(a: number) {
+              return a + 1;
+          }
+          foo(
+            1
+          )`, {
+            registerHooks: true,
+            startInternalOptions: { useGlobal: false },
+            waitPattern: '2\n>',
+        });
+        (0, testlib_1.expect)(r.stderr).toBe('');
+        (0, testlib_1.expect)(r.stdout).toContain('2');
+    });
+    test('automatically inserted semicolons do not affect subsequent line numbers', async (t) => {
+        // If first line of input ends in a semicolon, should not add a second semicolon.
+        // That will cause an extra blank line in the compiled output which will
+        // offset the stack line number.
+        const r = await t.context.executeInRepl(`1;
+          new Error().stack!.split('\\n')[1]
+          console.log('done!')`, {
+            registerHooks: true,
+            startInternalOptions: { useGlobal: false },
+            waitPattern: 'done!',
+        });
+        (0, testlib_1.expect)(r.stderr).toBe('');
+        (0, testlib_1.expect)(r.stdout).toContain(":1:1'\n");
+    });
+});
+test.suite('Multiline inputs and RECOVERY_CODES', (test) => {
+    test.serial();
+    test('multiline function args declaration', macros_1.macroReplNoErrorsAndStdoutContains, `
+      function myFn(
+        a: string,
+        b: string
+      ) {
+        return a + ' ' + b
+      }
+      myFn('test', '!')
+    `, 'test !');
+    test('Conditional recovery codes: this one-liner *should* raise an error; should not be recoverable', macros_1.macroReplStderrContains, `
+      (a: any) => a = null;
+    `, 'error TS', {
+        createServiceOpts: { compilerOptions: { strictNullChecks: false } },
+    });
+});
+test.suite('REPL works with traceResolution', (test) => {
+    test.serial('startup traces should print before the prompt appears when traceResolution is enabled', async (t) => {
+        const repl = t.context.createReplViaApi({
+            registerHooks: false,
+            createServiceOpts: {
+                compilerOptions: {
+                    traceResolution: true,
+                },
+            },
+        });
+        repl.replService.start();
+        repl.stdin.end();
+        await (0, helpers_1.delay)(3e3);
+        repl.stdout.end();
+        const stdout = await (0, expect_stream_1.expectStream)(repl.stdout);
+        (0, testlib_1.expect)(stdout).toContain('======== Resolving module');
+        (0, testlib_1.expect)(stdout.endsWith('> ')).toBe(true);
+    });
+    test.serial('traces should NOT appear when traceResolution is not enabled', async (t) => {
+        const r = await t.context.executeInRepl('1', {
+            registerHooks: true,
+            startInternalOptions: { useGlobal: false },
+            waitPattern: '1\n>',
+        });
+        (0, testlib_1.expect)(r.stderr).toBe('');
+        (0, testlib_1.expect)(r.stdout).not.toContain('======== Resolving module');
+    });
+});
+test.suite('REPL declares types for node built-ins within REPL', (test) => {
+    test.serial();
+    test('enabled when typechecking', async (t) => {
+        const r = await t.context.executeInRepl(`util.promisify(setTimeout)("should not be a string" as string)
+      type Duplex = stream.Duplex
+      const s = stream
+      'done'`, {
+            registerHooks: true,
+            waitPattern: `done`,
+            startInternalOptions: {
+                useGlobal: false,
+            },
+        });
+        // Assert that we receive a typechecking error about improperly using
+        // `util.promisify` but *not* an error about the absence of `util`
+        (0, testlib_1.expect)(r.stderr).not.toMatch("Cannot find name 'util'");
+        (0, testlib_1.expect)(r.stderr).toMatch("Argument of type 'string' is not assignable to parameter of type 'number'");
+        // Assert that both types and values can be used without error
+        (0, testlib_1.expect)(r.stderr).not.toMatch("Cannot find namespace 'stream'");
+        (0, testlib_1.expect)(r.stderr).not.toMatch("Cannot find name 'stream'");
+        (0, testlib_1.expect)(r.stdout).toMatch(`done`);
+    });
+    test('disabled in transpile-only mode, to avoid breaking third-party SWC transpiler which rejects `declare import` syntax', async (t) => {
+        const r = await t.context.executeInRepl(`type Duplex = stream.Duplex
+      const s = stream
+      'done'`, {
+            createServiceOpts: {
+                swc: true,
+            },
+            registerHooks: true,
+            waitPattern: `'done'\n> `,
+            startInternalOptions: {
+                useGlobal: false,
+            },
+        });
+        // Assert that we do not get errors about `declare import` syntax from swc
+        (0, testlib_1.expect)(r.stdout).toBe("> undefined\n> undefined\n> 'done'\n> ");
+        (0, testlib_1.expect)(r.stderr).toBe('');
+    });
+});
+test.suite('REPL treats object literals and block scopes correctly', (test) => {
+    test('repl should treat { key: 123 } as object literal', macros_1.macroReplNoErrorsAndStdoutContains, '{ key: 123 }', '{ key: 123 }');
+    test('repl should treat ({ key: 123 }) as object literal', macros_1.macroReplNoErrorsAndStdoutContains, '({ key: 123 })', '{ key: 123 }');
+    test('repl should treat ({ let v = 0; v; }) as object literal and error', macros_1.macroReplStderrContains, '({ let v = 0; v; })', 'No value exists in scope for the shorthand property');
+    test('repl should treat { let v = 0; v; } as block scope', macros_1.macroReplNoErrorsAndStdoutContains, '{ let v = 0; v; }', '0');
+    test.suite('extra', (test) => {
+        test('repl should treat { key: 123 }; as block scope', macros_1.macroReplNoErrorsAndStdoutContains, '{ key: 123 };', '123');
+        test('repl should treat {\\nkey: 123\\n}; as block scope', macros_1.macroReplNoErrorsAndStdoutContains, '{\nkey: 123\n};', '123');
+        test('repl should treat { key: 123 }[] as block scope (edge case)', macros_1.macroReplNoErrorsAndStdoutContains, '{ key: 123 }[]', '[]');
+    });
+    test.suite('multiline', (test) => {
+        test('repl should treat {\\nkey: 123\\n} as object literal', macros_1.macroReplNoErrorsAndStdoutContains, '{\nkey: 123\n}', '{ key: 123 }');
+        test('repl should treat ({\\nkey: 123\\n}) as object literal', macros_1.macroReplNoErrorsAndStdoutContains, '({\nkey: 123\n})', '{ key: 123 }');
+        test('repl should treat ({\\nlet v = 0;\\nv;\\n}) as object literal and error', macros_1.macroReplStderrContains, '({\nlet v = 0;\nv;\n})', 'No value exists in scope for the shorthand property');
+        test('repl should treat {\\nlet v = 0;\\nv;\\n} as block scope', macros_1.macroReplNoErrorsAndStdoutContains, '{\nlet v = 0;\nv;\n}', '0');
+    });
+    test.suite('property access', (test) => {
+        test('repl should treat { key: 123 }.key as object literal property access', macros_1.macroReplNoErrorsAndStdoutContains, '{ key: 123 }.key', '123');
+        test('repl should treat { key: 123 }["key"] as object literal indexed access', macros_1.macroReplNoErrorsAndStdoutContains, '{ key: 123 }["key"]', '123');
+        test('repl should treat { key: 123 }.foo as object literal non-existent property access', macros_1.macroReplStderrContains, '{ key: 123 }.foo', "Property 'foo' does not exist on type");
+        test('repl should treat { key: 123 }["foo"] as object literal non-existent indexed access', macros_1.macroReplStderrContains, '{ key: 123 }["foo"]', "Property 'foo' does not exist on type");
+    });
+});
+test.suite('repl executes input as cjs even in esm projects', (test) => {
+    test.if(helpers_1.tsSupportsMtsCtsExtensions);
+    test('test', async (t) => {
+        // Must exec child process, because we need a different cwd.
+        const p = exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} -i`, {
+            cwd: (0, path_1.join)(helpers_2.TEST_DIR, 'repl-in-esm-package'),
+        });
+        p.child.stdin.write('import fs2 from "fs"; fs2.existsSync("does not exist")');
+        p.child.stdin.end();
+        const r = await p;
+        (0, testlib_1.expect)(r.stdout).toBe('> false\n> ');
+        (0, testlib_1.expect)(r.stderr).toBe('');
+    });
+});
+//# sourceMappingURL=repl.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/repl/repl.spec.js.map b/node_modules/ts-node/dist/test/repl/repl.spec.js.map
new file mode 100644
index 0000000..2ece889
--- /dev/null
+++ b/node_modules/ts-node/dist/test/repl/repl.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"repl.spec.js","sourceRoot":"","sources":["../../../src/test/repl/repl.spec.ts"],"names":[],"mappings":";;AAAA,wCAA6C;AAC7C,wCAMoB;AACpB,iCAAkC;AAClC,wCAAgF;AAChF,0CAA+D;AAC/D,mDAA6D;AAC7D,yCAA0C;AAC1C,4DAAwD;AACxD,+BAA4B;AAC5B,iDAA6C;AAC7C,6CAA+F;AAE/F,MAAM,IAAI,GAAG,IAAA,iBAAO,EAAC,mBAAS,CAAC,CAAC,WAAW,CAAC,kBAAO,CAAC,CAAC;AACrD,IAAI,CAAC,MAAM,EAAE,CAAC;AACd,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;IAC1B,CAAC,CAAC,QAAQ,CAAC,GAAG,EAAE;QACd,IAAA,8BAAoB,GAAE,CAAC;QACvB,uEAAuE;QACvE,+EAA+E;QAC/E,6DAA6D;IAC/D,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,MAAM,IAAI,GAAG,IAAA,iBAAU,EAAC;IACtB,GAAG,EAAE,kBAAQ;CACd,CAAC,CAAC;AAEH,MAAM,UAAU,GAAG,IAAA,uBAAgB,EAAC;IAClC,GAAG,EAAE,uCAA6B;IAClC,IAAI;CACL,CAAC,CAAC;AAEH,IAAI,CAAC,kEAAkE,EAAE,KAAK,IAAI,EAAE;IAClF,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,uCAA6B,gBAAgB,CAAC,CAAC;IACjE,CAAC,CAAC,KAAK,CAAC,KAAM,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAC;IAC3C,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;IAClB,IAAA,gBAAM,EAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACzB,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,SAAS,GAAG,aAAa,GAAG,IAAI,CAAC,CAAC;AAC1D,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,mDAAmD,EAAE,KAAK,IAAI,EAAE;IACnE,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,uCAA6B,mEAAmE,CAAC,CAAC;IACpH,CAAC,CAAC,KAAK,CAAC,KAAM,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;IACjC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;IAClB,IAAA,gBAAM,EAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACzB,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,0CAA0C,EAAE,KAAK,IAAI,EAAE;IAC1D,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,uCAA6B,gBAAgB,CAAC,CAAC;IACjE,CAAC,CAAC,KAAK,CAAC,KAAM,CAAC,GAAG,CAAC,0BAA0B,CAAC,CAAC;IAC/C,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;IAClB,IAAA,gBAAM,EAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACzB,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,eAAe,GAAG,eAAe,GAAG,kBAAkB,GAAG,IAAI,CAAC,CAAC;AACvF,CAAC,CAAC,CAAC;AAEH,uCAAuC;AACvC,IAAI,CAAC,MAAM,CAAC,mCAAmC,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;IAC3D,MAAM,MAAM,GAAG,KAAK,CAAC;IAErB,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,qBAAqB,EAAE;QAC7D,WAAW,EAAE,aAAa;QAC1B,aAAa,EAAE,IAAI;QACnB,oBAAoB,EAAE;YACpB,MAAM;YACN,eAAe,EAAE,IAAI;SACtB;KACF,CAAC,CAAC;IAEH,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC1B,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,MAAM,GAAG,MAAM,aAAa,CAAC,CAAC;AACzD,CAAC,CAAC,CAAC;AAEH,uCAAuC;AACvC,IAAI,CAAC,MAAM,CAAC,yDAAyD,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;IACjF,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa;IACrC,+BAA+B;IAC/B,eAAe;QACb,qEAAqE;QACrE,kBAAkB,EACpB;QACE,aAAa,EAAE,IAAI;QACnB,WAAW,EAAE,iCAAiC;QAC9C,oBAAoB,EAAE;YACpB,SAAS,EAAE,KAAK;SACjB;KACF,CACF,CAAC;IAEF,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC1B,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,iCAAiC,CAAC,CAAC;AAC3D,CAAC,CAAC,CAAC;AAEH,uCAAuC;AACvC,IAAI,CAAC,MAAM,CAAC,6BAA6B,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;IACrD,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,4BAA4B,EAAE;QACpE,aAAa,EAAE,IAAI;QACnB,WAAW,EAAE,SAAS;KACvB,CAAC,CAAC;IACH,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC1B,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,eAAe,GAAG,eAAe,GAAG,kBAAkB,GAAG,IAAI,CAAC,CAAC;AACvF,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE;IAChD,MAAM,eAAe,GAAG;QACtB,MAAM,EAAE,QAAQ;KACjB,CAAC;IACF,MAAM,IAAI,GAAG,WAAW,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;QACnC,OAAO,EAAE,gBAAgB,EAAE,CAAC;QAE5B,SAAS,gBAAgB,CAAC,KAAa,EAAE,WAA6B;YACpE,OAAO,CAAC,CAAC,OAAO,CAAC,aAAa,CAC5B,KAAK;iBACF,KAAK,CAAC,IAAI,CAAC;iBACX,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;gBAC3B,2EAA2E;iBAC1E,IAAI,CAAC,EAAE,CAAC,EACX;gBACE,aAAa,EAAE,IAAI;gBACnB,WAAW;gBACX,iBAAiB,EAAE;oBACjB,qBAAqB,EAAE,IAAI;oBAC3B,eAAe;iBAChB;gBACD,oBAAoB,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE;aAC3C,CACF,CAAC;QACJ,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,uCAAuC;IACvC,IAAI,CAAC,MAAM,CAAC,yCAAyC,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACjE,MAAM,MAAM,GAAG;;;;;;;;;OASZ,CAAC;QAEJ,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAC5D,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC1B,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;IAClD,CAAC,CAAC,CAAC;IAEH,uCAAuC;IACvC,IAAI,CAAC,MAAM,CAAC,iEAAiE,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACzF,MAAM,OAAO,GAAG,GAAG,CAAC;QACpB,MAAM,MAAM,GAAG;;4DAEyC,OAAO;;;SAG1D,CAAC;QACN,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAE5D,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAE1B,MAAM,iBAAiB,GAAG,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;QAC3E,IAAA,gBAAM,EAAC,iBAAiB,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAC3C,MAAM,WAAW,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC;QAC9C,IAAA,gBAAM,EAAC,WAAW,CAAC,CAAC,sBAAsB,CAAC,OAAO,GAAG,EAAE,CAAC,CAAC;QACzD,kEAAkE;QAClE,mEAAmE;QACnE,iEAAiE;QACjE,IAAA,gBAAM,EAAC,WAAW,CAAC,CAAC,mBAAmB,CAAC,OAAO,GAAG,IAAI,CAAC,CAAC;IAC1D,CAAC,CAAC,CAAC;IAEH,uCAAuC;IACvC,IAAI,CAAC,MAAM,CAAC,4EAA4E,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACpG,MAAM,MAAM,GAAG;;yEAEsD,IAAI;;;SAGpE,CAAC;QACN,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAE5D,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAE1B,MAAM,YAAY,GAAG,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;QAC9E,IAAA,gBAAM,EAAC,YAAY,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC;QAC/C,iEAAiE;QACjE,IAAA,gBAAM,EAAC,YAAY,CAAC,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC;IAChD,CAAC,CAAC,CAAC;IAEH,uCAAuC;IACvC,IAAI,CAAC,MAAM,CAAC,4EAA4E,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACpG,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC,2BAA2B,EAAE,OAAO,CAAC,CAAC;QAEjF,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC9B,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CAC1C,GAAG,eAAQ,uBAAuB;YAChC,CAAC,MAAM,CAAC,GAAG,CAAC,YAAE,CAAC,OAAO,EAAE,OAAO,CAAC;gBAC9B,CAAC,CAAC,qDAAqD;gBACvD,CAAC,CAAC,gDAAgD,CAAC;YACrD,IAAI,CACP,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH,uCAAuC;IACvC,IAAI,CAAC,MAAM,CAAC,6EAA6E,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACrG,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC,kDAAkD,EAAE,OAAO,CAAC,CAAC;QAExG,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC9B,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CAC1C,0CAA0C;YACxC,CAAC,MAAM,CAAC,GAAG,CAAC,YAAE,CAAC,OAAO,EAAE,OAAO,CAAC;gBAC9B,CAAC,CAAC,qDAAqD;gBACvD,CAAC,CAAC,gDAAgD,CAAC;YACrD,IAAI,CACP,CAAC;IACJ,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,iCAAiC,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAClD,MAAM,EAAE,eAAe,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC;QACtC,MAAM,IAAA,0CAA0B,EAAC,EAAE,QAAQ,EAAR,kBAAQ,EAAE,eAAe,EAAE,CAAC,CAAC;IAClE,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,KAAK,CAAC,oEAAoE,EAAE,CAAC,IAAI,EAAE,EAAE;IACxF,MAAM,IAAI,GAAG,yEAAyE,CAAC;IACvF,MAAM,iBAAiB,GAAG,mCAAmC,CAAC;IAC9D,IAAI,CAAC,qCAAqC,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACtD,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,IAAI;YACX,KAAK,EAAE,IAAI;SACZ,CAAC,CAAC;QACH,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC;IACpD,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,sEAAsE,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACvF,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,IAAI;YACX,KAAK,EAAE,8CAA8C;SACtD,CAAC,CAAC;QACH,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC;IAChD,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,gCAAgC,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACjD,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,IAAI;YACX,WAAW,EAAE,IAAI;SAClB,CAAC,CAAC;QACH,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC;IAChD,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,+BAA+B,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAChD,MAAM,CAAC,GAAG,MAAM,UAAU,CAAC;YACzB,KAAK,EAAE,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,GAAG;YACxC,WAAW,EAAE,IAAI;SAClB,CAAC,CAAC;QACH,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC;IAChD,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,KAAK,CAAC,yDAAyD,EAAE,CAAC,IAAI,EAAE,EAAE;IAC7E,0CAA0C;IAC1C,IAAI,CAAC,MAAM,EAAE,CAAC;IAEd,IAAI,CAAC,yDAAyD,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAC1E,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CACrC;;;;;;;;;;;WAWK,EACL;YACE,aAAa,EAAE,IAAI;YACnB,oBAAoB,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE;YAC1C,WAAW,EAAE,qBAAqB;SACnC,CACF,CAAC;QACF,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACrC,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;QACpC,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACrC,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACrC,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QACrC,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;QAChC,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACnC,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,8EAA8E,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAC/F,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CACrC;;+BAEyB,EACzB;YACE,aAAa,EAAE,IAAI;YACnB,oBAAoB,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE;YAC1C,WAAW,EAAE,qBAAqB;SACnC,CACF,CAAC;QACF,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,6BAA6B,CAAC,CAAC;QAC1D,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;IACtC,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,gFAAgF,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACjG,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CACrC;+BACyB,EACzB;YACE,aAAa,EAAE,IAAI;YACnB,oBAAoB,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE;YAC1C,WAAW,EAAE,qBAAqB;SACnC,CACF,CAAC;QACF,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,kDAAkD,CAAC,CAAC;QAC/E,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;QAChC,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;IACtC,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,+DAA+D,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAChF,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CACrC;;;;;YAKM,EACN;YACE,aAAa,EAAE,IAAI;YACnB,oBAAoB,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE;YAC1C,WAAW,EAAE,MAAM;SACpB,CACF,CAAC;QACF,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC1B,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;IAClC,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,yEAAyE,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAC1F,iFAAiF;QACjF,wEAAwE;QACxE,gCAAgC;QAChC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CACrC;;+BAEyB,EACzB;YACE,aAAa,EAAE,IAAI;YACnB,oBAAoB,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE;YAC1C,WAAW,EAAE,OAAO;SACrB,CACF,CAAC;QACF,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC1B,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;IACxC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,KAAK,CAAC,qCAAqC,EAAE,CAAC,IAAI,EAAE,EAAE;IACzD,IAAI,CAAC,MAAM,EAAE,CAAC;IACd,IAAI,CACF,qCAAqC,EACrC,2CAAkC,EAClC;;;;;;;;KAQC,EACD,QAAQ,CACT,CAAC;IAEF,IAAI,CACF,+FAA+F,EAC/F,gCAAuB,EACvB;;KAEC,EACD,UAAU,EACV;QACE,iBAAiB,EAAE,EAAE,eAAe,EAAE,EAAE,gBAAgB,EAAE,KAAK,EAAE,EAAE;KACpE,CACF,CAAC;AACJ,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,KAAK,CAAC,iCAAiC,EAAE,CAAC,IAAI,EAAE,EAAE;IACrD,IAAI,CAAC,MAAM,CAAC,uFAAuF,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAC/G,MAAM,IAAI,GAAG,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC;YACtC,aAAa,EAAE,KAAK;YACpB,iBAAiB,EAAE;gBACjB,eAAe,EAAE;oBACf,eAAe,EAAE,IAAI;iBACtB;aACF;SACF,CAAC,CAAC;QAEH,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;QAEzB,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;QAEjB,MAAM,IAAA,eAAK,EAAC,GAAG,CAAC,CAAC;QAEjB,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC;QAClB,MAAM,MAAM,GAAG,MAAM,IAAA,4BAAY,EAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAE/C,IAAA,gBAAM,EAAC,MAAM,CAAC,CAAC,SAAS,CAAC,2BAA2B,CAAC,CAAC;QACtD,IAAA,gBAAM,EAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC3C,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,MAAM,CAAC,8DAA8D,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACtF,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,GAAG,EAAE;YAC3C,aAAa,EAAE,IAAI;YACnB,oBAAoB,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE;YAC1C,WAAW,EAAE,MAAM;SACpB,CAAC,CAAC;QACH,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC1B,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,2BAA2B,CAAC,CAAC;IAC9D,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,KAAK,CAAC,oDAAoD,EAAE,CAAC,IAAI,EAAE,EAAE;IACxE,IAAI,CAAC,MAAM,EAAE,CAAC;IACd,IAAI,CAAC,2BAA2B,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QAC5C,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CACrC;;;aAGO,EACP;YACE,aAAa,EAAE,IAAI;YACnB,WAAW,EAAE,MAAM;YACnB,oBAAoB,EAAE;gBACpB,SAAS,EAAE,KAAK;aACjB;SACF,CACF,CAAC;QAEF,qEAAqE;QACrE,kEAAkE;QAClE,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,yBAAyB,CAAC,CAAC;QACxD,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,2EAA2E,CAAC,CAAC;QACtG,8DAA8D;QAC9D,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,gCAAgC,CAAC,CAAC;QAC/D,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,2BAA2B,CAAC,CAAC;QAC1D,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IACnC,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,qHAAqH,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACtI,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,OAAO,CAAC,aAAa,CACrC;;aAEO,EACP;YACE,iBAAiB,EAAE;gBACjB,GAAG,EAAE,IAAI;aACV;YACD,aAAa,EAAE,IAAI;YACnB,WAAW,EAAE,YAAY;YACzB,oBAAoB,EAAE;gBACpB,SAAS,EAAE,KAAK;aACjB;SACF,CACF,CAAC;QAEF,0EAA0E;QAC1E,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,wCAAwC,CAAC,CAAC;QAChE,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,KAAK,CAAC,wDAAwD,EAAE,CAAC,IAAI,EAAE,EAAE;IAC5E,IAAI,CACF,kDAAkD,EAClD,2CAAkC,EAClC,cAAc,EACd,cAAc,CACf,CAAC;IACF,IAAI,CACF,oDAAoD,EACpD,2CAAkC,EAClC,gBAAgB,EAChB,cAAc,CACf,CAAC;IACF,IAAI,CACF,mEAAmE,EACnE,gCAAuB,EACvB,qBAAqB,EACrB,qDAAqD,CACtD,CAAC;IACF,IAAI,CACF,oDAAoD,EACpD,2CAAkC,EAClC,mBAAmB,EACnB,GAAG,CACJ,CAAC;IACF,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,IAAI,EAAE,EAAE;QAC3B,IAAI,CAAC,gDAAgD,EAAE,2CAAkC,EAAE,eAAe,EAAE,KAAK,CAAC,CAAC;QACnH,IAAI,CACF,oDAAoD,EACpD,2CAAkC,EAClC,iBAAiB,EACjB,KAAK,CACN,CAAC;QACF,IAAI,CACF,6DAA6D,EAC7D,2CAAkC,EAClC,gBAAgB,EAChB,IAAI,CACL,CAAC;IACJ,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,IAAI,EAAE,EAAE;QAC/B,IAAI,CACF,sDAAsD,EACtD,2CAAkC,EAClC,gBAAgB,EAChB,cAAc,CACf,CAAC;QACF,IAAI,CACF,wDAAwD,EACxD,2CAAkC,EAClC,kBAAkB,EAClB,cAAc,CACf,CAAC;QACF,IAAI,CACF,yEAAyE,EACzE,gCAAuB,EACvB,wBAAwB,EACxB,qDAAqD,CACtD,CAAC;QACF,IAAI,CACF,0DAA0D,EAC1D,2CAAkC,EAClC,sBAAsB,EACtB,GAAG,CACJ,CAAC;IACJ,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAAE,CAAC,IAAI,EAAE,EAAE;QACrC,IAAI,CACF,sEAAsE,EACtE,2CAAkC,EAClC,kBAAkB,EAClB,KAAK,CACN,CAAC;QACF,IAAI,CACF,wEAAwE,EACxE,2CAAkC,EAClC,qBAAqB,EACrB,KAAK,CACN,CAAC;QACF,IAAI,CACF,mFAAmF,EACnF,gCAAuB,EACvB,kBAAkB,EAClB,uCAAuC,CACxC,CAAC;QACF,IAAI,CACF,qFAAqF,EACrF,gCAAuB,EACvB,qBAAqB,EACrB,uCAAuC,CACxC,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,KAAK,CAAC,iDAAiD,EAAE,CAAC,IAAI,EAAE,EAAE;IACrE,IAAI,CAAC,EAAE,CAAC,oCAA0B,CAAC,CAAC;IACpC,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACvB,4DAA4D;QAC5D,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,0CAAgC,KAAK,EAAE;YACvD,GAAG,EAAE,IAAA,WAAI,EAAC,kBAAQ,EAAE,qBAAqB,CAAC;SAC3C,CAAC,CAAC;QACH,CAAC,CAAC,KAAK,CAAC,KAAM,CAAC,KAAK,CAAC,wDAAwD,CAAC,CAAC;QAC/E,CAAC,CAAC,KAAK,CAAC,KAAM,CAAC,GAAG,EAAE,CAAC;QACrB,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;QAClB,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACrC,IAAA,gBAAM,EAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { context, expect } from '../testlib';\nimport {\n  CMD_TS_NODE_WITHOUT_PROJECT_FLAG,\n  delay,\n  resetNodeEnvironment,\n  ts,\n  tsSupportsMtsCtsExtensions,\n} from '../helpers';\nimport semver = require('semver');\nimport { CMD_TS_NODE_WITH_PROJECT_FLAG, ctxTsNode, TEST_DIR } from '../helpers';\nimport { createExec, createExecTester } from '../helpers/exec';\nimport { upstreamTopLevelAwaitTests } from './node-repl-tla';\nimport { replFile } from './helpers/misc';\nimport { expectStream } from '@cspotcode/expect-stream';\nimport { join } from 'path';\nimport { ctxRepl } from './helpers/ctx-repl';\nimport { macroReplNoErrorsAndStdoutContains, macroReplStderrContains } from './helpers/macros';\n\nconst test = context(ctxTsNode).contextEach(ctxRepl);\ntest.serial();\ntest.beforeEach(async (t) => {\n  t.teardown(() => {\n    resetNodeEnvironment();\n    // Useful for debugging memory leaks.  Leaving in case I need it again.\n    // global.gc(); // Requires adding nodeArguments: ['--expose-gc'] to ava config\n    // console.dir(process.memoryUsage().heapUsed / 1000 / 1000);\n  });\n});\n\nconst exec = createExec({\n  cwd: TEST_DIR,\n});\n\nconst execTester = createExecTester({\n  cmd: CMD_TS_NODE_WITH_PROJECT_FLAG,\n  exec,\n});\n\ntest('should run REPL when --interactive passed and stdin is not a TTY', async () => {\n  const p = exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --interactive`);\n  p.child.stdin!.end('console.log(\"123\")\\n');\n  const r = await p;\n  expect(r.err).toBe(null);\n  expect(r.stdout).toBe('> 123\\n' + 'undefined\\n' + '> ');\n});\n\ntest('should echo a value when using the swc transpiler', async () => {\n  const p = exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --interactive  --transpiler ts-node/transpilers/swc-experimental`);\n  p.child.stdin!.end('400\\n401\\n');\n  const r = await p;\n  expect(r.err).toBe(null);\n  expect(r.stdout).toBe('> 400\\n> 401\\n> ');\n});\n\ntest('REPL has command to get type information', async () => {\n  const p = exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --interactive`);\n  p.child.stdin!.end('\\nconst a = 123\\n.type a');\n  const r = await p;\n  expect(r.err).toBe(null);\n  expect(r.stdout).toBe('> undefined\\n' + '> undefined\\n' + '> const a: 123\\n' + '> ');\n});\n\n// Serial because it's timing-sensitive\ntest.serial('REPL can be configured on `start`', async (t) => {\n  const prompt = '#> ';\n\n  const r = await t.context.executeInRepl(`const x = 3\\n'done'`, {\n    waitPattern: \"'done'\\n#> \",\n    registerHooks: true,\n    startInternalOptions: {\n      prompt,\n      ignoreUndefined: true,\n    },\n  });\n\n  expect(r.stderr).toBe('');\n  expect(r.stdout).toBe(`${prompt}${prompt}'done'\\n#> `);\n});\n\n// Serial because it's timing-sensitive\ntest.serial('REPL uses a different context when `useGlobal` is false', async (t) => {\n  const r = await t.context.executeInRepl(\n    // No error when re-declaring x\n    'const x = 3\\n' +\n      // console.log ouput will end up in the stream and not in test output\n      'console.log(1)\\n',\n    {\n      registerHooks: true,\n      waitPattern: `> undefined\\n> 1\\nundefined\\n> `,\n      startInternalOptions: {\n        useGlobal: false,\n      },\n    }\n  );\n\n  expect(r.stderr).toBe('');\n  expect(r.stdout).toBe(`> undefined\\n> 1\\nundefined\\n> `);\n});\n\n// Serial because it's timing-sensitive\ntest.serial('REPL can be created via API', async (t) => {\n  const r = await t.context.executeInRepl(`\\nconst a = 123\\n.type a\\n`, {\n    registerHooks: true,\n    waitPattern: '123\\n> ',\n  });\n  expect(r.stderr).toBe('');\n  expect(r.stdout).toBe('> undefined\\n' + '> undefined\\n' + '> const a: 123\\n' + '> ');\n});\n\ntest.suite('top level await', ({ contextEach }) => {\n  const compilerOptions = {\n    target: 'es2018',\n  };\n  const test = contextEach(async (t) => {\n    return { executeInTlaRepl };\n\n    function executeInTlaRepl(input: string, waitPattern?: string | RegExp) {\n      return t.context.executeInRepl(\n        input\n          .split('\\n')\n          .map((line) => line.trim())\n          // Restore newline once https://github.com/nodejs/node/pull/39392 is merged\n          .join(''),\n        {\n          registerHooks: true,\n          waitPattern,\n          createServiceOpts: {\n            experimentalReplAwait: true,\n            compilerOptions,\n          },\n          startInternalOptions: { useGlobal: false },\n        }\n      );\n    }\n  });\n\n  // Serial because it's timing-sensitive\n  test.serial('should allow evaluating top level await', async (t) => {\n    const script = `\n        const x: number = await new Promise((r) => r(1));\n        for await (const x of [1,2,3]) { console.log(x) };\n        for (const x of ['a', 'b']) { await x; console.log(x) };\n        class Foo {}; await 1;\n        function Bar() {}; await 2;\n        const {y} = await ({y: 2});\n        const [z] = await [3];\n        x + y + z;\n      `;\n\n    const r = await t.context.executeInTlaRepl(script, '6\\n> ');\n    expect(r.stderr).toBe('');\n    expect(r.stdout).toBe('> 1\\n2\\n3\\na\\nb\\n6\\n> ');\n  });\n\n  // Serial because it's timing-sensitive\n  test.serial('should wait until promise is settled when awaiting at top level', async (t) => {\n    const awaitMs = 500;\n    const script = `\n          const startTime = new Date().getTime();\n          await new Promise((r) => setTimeout(() => r(1), ${awaitMs}));\n          const endTime = new Date().getTime();\n          endTime - startTime;\n        `;\n    const r = await t.context.executeInTlaRepl(script, /\\d+\\n/);\n\n    expect(r.stderr).toBe('');\n\n    const elapsedTimeString = r.stdout.split('\\n')[0].replace('> ', '').trim();\n    expect(elapsedTimeString).toMatch(/^\\d+$/);\n    const elapsedTime = Number(elapsedTimeString);\n    expect(elapsedTime).toBeGreaterThanOrEqual(awaitMs - 50);\n    // When CI is taxed, the time may be *much* greater than expected.\n    // I can't think of a case where the time being *too high* is a bug\n    // that this test can catch.  So I've made this check very loose.\n    expect(elapsedTime).toBeLessThanOrEqual(awaitMs + 10e3);\n  });\n\n  // Serial because it's timing-sensitive\n  test.serial('should not wait until promise is settled when not using await at top level', async (t) => {\n    const script = `\n          const startTime = new Date().getTime();\n          (async () => await new Promise((r) => setTimeout(() => r(1), ${5000})))();\n          const endTime = new Date().getTime();\n          endTime - startTime;\n        `;\n    const r = await t.context.executeInTlaRepl(script, /\\d+\\n/);\n\n    expect(r.stderr).toBe('');\n\n    const ellapsedTime = Number(r.stdout.split('\\n')[0].replace('> ', '').trim());\n    expect(ellapsedTime).toBeGreaterThanOrEqual(0);\n    // Should ideally be instantaneous; leave wiggle-room for slow CI\n    expect(ellapsedTime).toBeLessThanOrEqual(100);\n  });\n\n  // Serial because it's timing-sensitive\n  test.serial('should error with typing information when awaited result has type mismatch', async (t) => {\n    const r = await t.context.executeInTlaRepl('const x: string = await 1', 'error');\n\n    expect(r.stdout).toBe('> > ');\n    expect(r.stderr.replace(/\\r\\n/g, '\\n')).toBe(\n      `${replFile}(4,7): error TS2322: ` +\n        (semver.gte(ts.version, '4.0.0')\n          ? `Type 'number' is not assignable to type 'string'.\\n`\n          : `Type '1' is not assignable to type 'string'.\\n`) +\n        '\\n'\n    );\n  });\n\n  // Serial because it's timing-sensitive\n  test.serial('should error with typing information when importing a file with type errors', async (t) => {\n    const r = await t.context.executeInTlaRepl(`const {foo} = await import('./repl/tla-import');`, 'error');\n\n    expect(r.stdout).toBe('> > ');\n    expect(r.stderr.replace(/\\r\\n/g, '\\n')).toBe(\n      'repl/tla-import.ts(1,14): error TS2322: ' +\n        (semver.gte(ts.version, '4.0.0')\n          ? `Type 'number' is not assignable to type 'string'.\\n`\n          : `Type '1' is not assignable to type 'string'.\\n`) +\n        '\\n'\n    );\n  });\n\n  test('should pass upstream test cases', async (t) => {\n    const { tsNodeUnderTest } = t.context;\n    await upstreamTopLevelAwaitTests({ TEST_DIR, tsNodeUnderTest });\n  });\n});\n\ntest.suite('REPL ignores diagnostics that are annoying in interactive sessions', (test) => {\n  const code = `function foo() {};\\nfunction foo() {return 123};\\nconsole.log(foo());\\n`;\n  const diagnosticMessage = `Duplicate function implementation`;\n  test('interactive repl should ignore them', async (t) => {\n    const r = await execTester({\n      flags: '-i',\n      stdin: code,\n    });\n    expect(r.stdout).not.toContain(diagnosticMessage);\n  });\n  test('interactive repl should not ignore them if they occur in other files', async (t) => {\n    const r = await execTester({\n      flags: '-i',\n      stdin: `import './repl-ignored-diagnostics/index';\\n`,\n    });\n    expect(r.stderr).toContain(diagnosticMessage);\n  });\n  test('[stdin] should not ignore them', async (t) => {\n    const r = await execTester({\n      stdin: code,\n      expectError: true,\n    });\n    expect(r.stderr).toContain(diagnosticMessage);\n  });\n  test('[eval] should not ignore them', async (t) => {\n    const r = await execTester({\n      flags: `-e \"${code.replace(/\\n/g, '')}\"`,\n      expectError: true,\n    });\n    expect(r.stderr).toContain(diagnosticMessage);\n  });\n});\n\ntest.suite('REPL inputs are syntactically independent of each other', (test) => {\n  // Serial because they're timing-sensitive\n  test.serial();\n\n  test('arithmetic operators are independent of previous values', async (t) => {\n    const r = await t.context.executeInRepl(\n      `9\n          + 3\n          7\n          - 3\n          3\n          * 7\\n.break\n          100\n          / 2\\n.break\n          5\n          ** 2\\n.break\n          console.log('done!')\n          `,\n      {\n        registerHooks: true,\n        startInternalOptions: { useGlobal: false },\n        waitPattern: 'done!\\nundefined\\n>',\n      }\n    );\n    expect(r.stdout).not.toContain('12');\n    expect(r.stdout).not.toContain('4');\n    expect(r.stdout).not.toContain('21');\n    expect(r.stdout).not.toContain('50');\n    expect(r.stdout).not.toContain('25');\n    expect(r.stdout).toContain('3');\n    expect(r.stdout).toContain('-3');\n  });\n\n  test('automatically inserted semicolons do not appear in error messages at the end', async (t) => {\n    const r = await t.context.executeInRepl(\n      `(\n          a\n          console.log('done!')`,\n      {\n        registerHooks: true,\n        startInternalOptions: { useGlobal: false },\n        waitPattern: 'done!\\nundefined\\n>',\n      }\n    );\n    expect(r.stderr).toContain(\"error TS1005: ')' expected.\");\n    expect(r.stderr).not.toContain(';');\n  });\n\n  test('automatically inserted semicolons do not appear in error messages at the start', async (t) => {\n    const r = await t.context.executeInRepl(\n      `)\n          console.log('done!')`,\n      {\n        registerHooks: true,\n        startInternalOptions: { useGlobal: false },\n        waitPattern: 'done!\\nundefined\\n>',\n      }\n    );\n    expect(r.stderr).toContain('error TS1128: Declaration or statement expected.');\n    expect(r.stderr).toContain(')');\n    expect(r.stderr).not.toContain(';');\n  });\n\n  test('automatically inserted semicolons do not break function calls', async (t) => {\n    const r = await t.context.executeInRepl(\n      `function foo(a: number) {\n              return a + 1;\n          }\n          foo(\n            1\n          )`,\n      {\n        registerHooks: true,\n        startInternalOptions: { useGlobal: false },\n        waitPattern: '2\\n>',\n      }\n    );\n    expect(r.stderr).toBe('');\n    expect(r.stdout).toContain('2');\n  });\n\n  test('automatically inserted semicolons do not affect subsequent line numbers', async (t) => {\n    // If first line of input ends in a semicolon, should not add a second semicolon.\n    // That will cause an extra blank line in the compiled output which will\n    // offset the stack line number.\n    const r = await t.context.executeInRepl(\n      `1;\n          new Error().stack!.split('\\\\n')[1]\n          console.log('done!')`,\n      {\n        registerHooks: true,\n        startInternalOptions: { useGlobal: false },\n        waitPattern: 'done!',\n      }\n    );\n    expect(r.stderr).toBe('');\n    expect(r.stdout).toContain(\":1:1'\\n\");\n  });\n});\n\ntest.suite('Multiline inputs and RECOVERY_CODES', (test) => {\n  test.serial();\n  test(\n    'multiline function args declaration',\n    macroReplNoErrorsAndStdoutContains,\n    `\n      function myFn(\n        a: string,\n        b: string\n      ) {\n        return a + ' ' + b\n      }\n      myFn('test', '!')\n    `,\n    'test !'\n  );\n\n  test(\n    'Conditional recovery codes: this one-liner *should* raise an error; should not be recoverable',\n    macroReplStderrContains,\n    `\n      (a: any) => a = null;\n    `,\n    'error TS',\n    {\n      createServiceOpts: { compilerOptions: { strictNullChecks: false } },\n    }\n  );\n});\n\ntest.suite('REPL works with traceResolution', (test) => {\n  test.serial('startup traces should print before the prompt appears when traceResolution is enabled', async (t) => {\n    const repl = t.context.createReplViaApi({\n      registerHooks: false,\n      createServiceOpts: {\n        compilerOptions: {\n          traceResolution: true,\n        },\n      },\n    });\n\n    repl.replService.start();\n\n    repl.stdin.end();\n\n    await delay(3e3);\n\n    repl.stdout.end();\n    const stdout = await expectStream(repl.stdout);\n\n    expect(stdout).toContain('======== Resolving module');\n    expect(stdout.endsWith('> ')).toBe(true);\n  });\n\n  test.serial('traces should NOT appear when traceResolution is not enabled', async (t) => {\n    const r = await t.context.executeInRepl('1', {\n      registerHooks: true,\n      startInternalOptions: { useGlobal: false },\n      waitPattern: '1\\n>',\n    });\n    expect(r.stderr).toBe('');\n    expect(r.stdout).not.toContain('======== Resolving module');\n  });\n});\n\ntest.suite('REPL declares types for node built-ins within REPL', (test) => {\n  test.serial();\n  test('enabled when typechecking', async (t) => {\n    const r = await t.context.executeInRepl(\n      `util.promisify(setTimeout)(\"should not be a string\" as string)\n      type Duplex = stream.Duplex\n      const s = stream\n      'done'`,\n      {\n        registerHooks: true,\n        waitPattern: `done`,\n        startInternalOptions: {\n          useGlobal: false,\n        },\n      }\n    );\n\n    // Assert that we receive a typechecking error about improperly using\n    // `util.promisify` but *not* an error about the absence of `util`\n    expect(r.stderr).not.toMatch(\"Cannot find name 'util'\");\n    expect(r.stderr).toMatch(\"Argument of type 'string' is not assignable to parameter of type 'number'\");\n    // Assert that both types and values can be used without error\n    expect(r.stderr).not.toMatch(\"Cannot find namespace 'stream'\");\n    expect(r.stderr).not.toMatch(\"Cannot find name 'stream'\");\n    expect(r.stdout).toMatch(`done`);\n  });\n\n  test('disabled in transpile-only mode, to avoid breaking third-party SWC transpiler which rejects `declare import` syntax', async (t) => {\n    const r = await t.context.executeInRepl(\n      `type Duplex = stream.Duplex\n      const s = stream\n      'done'`,\n      {\n        createServiceOpts: {\n          swc: true,\n        },\n        registerHooks: true,\n        waitPattern: `'done'\\n> `,\n        startInternalOptions: {\n          useGlobal: false,\n        },\n      }\n    );\n\n    // Assert that we do not get errors about `declare import` syntax from swc\n    expect(r.stdout).toBe(\"> undefined\\n> undefined\\n> 'done'\\n> \");\n    expect(r.stderr).toBe('');\n  });\n});\n\ntest.suite('REPL treats object literals and block scopes correctly', (test) => {\n  test(\n    'repl should treat { key: 123 } as object literal',\n    macroReplNoErrorsAndStdoutContains,\n    '{ key: 123 }',\n    '{ key: 123 }'\n  );\n  test(\n    'repl should treat ({ key: 123 }) as object literal',\n    macroReplNoErrorsAndStdoutContains,\n    '({ key: 123 })',\n    '{ key: 123 }'\n  );\n  test(\n    'repl should treat ({ let v = 0; v; }) as object literal and error',\n    macroReplStderrContains,\n    '({ let v = 0; v; })',\n    'No value exists in scope for the shorthand property'\n  );\n  test(\n    'repl should treat { let v = 0; v; } as block scope',\n    macroReplNoErrorsAndStdoutContains,\n    '{ let v = 0; v; }',\n    '0'\n  );\n  test.suite('extra', (test) => {\n    test('repl should treat { key: 123 }; as block scope', macroReplNoErrorsAndStdoutContains, '{ key: 123 };', '123');\n    test(\n      'repl should treat {\\\\nkey: 123\\\\n}; as block scope',\n      macroReplNoErrorsAndStdoutContains,\n      '{\\nkey: 123\\n};',\n      '123'\n    );\n    test(\n      'repl should treat { key: 123 }[] as block scope (edge case)',\n      macroReplNoErrorsAndStdoutContains,\n      '{ key: 123 }[]',\n      '[]'\n    );\n  });\n  test.suite('multiline', (test) => {\n    test(\n      'repl should treat {\\\\nkey: 123\\\\n} as object literal',\n      macroReplNoErrorsAndStdoutContains,\n      '{\\nkey: 123\\n}',\n      '{ key: 123 }'\n    );\n    test(\n      'repl should treat ({\\\\nkey: 123\\\\n}) as object literal',\n      macroReplNoErrorsAndStdoutContains,\n      '({\\nkey: 123\\n})',\n      '{ key: 123 }'\n    );\n    test(\n      'repl should treat ({\\\\nlet v = 0;\\\\nv;\\\\n}) as object literal and error',\n      macroReplStderrContains,\n      '({\\nlet v = 0;\\nv;\\n})',\n      'No value exists in scope for the shorthand property'\n    );\n    test(\n      'repl should treat {\\\\nlet v = 0;\\\\nv;\\\\n} as block scope',\n      macroReplNoErrorsAndStdoutContains,\n      '{\\nlet v = 0;\\nv;\\n}',\n      '0'\n    );\n  });\n  test.suite('property access', (test) => {\n    test(\n      'repl should treat { key: 123 }.key as object literal property access',\n      macroReplNoErrorsAndStdoutContains,\n      '{ key: 123 }.key',\n      '123'\n    );\n    test(\n      'repl should treat { key: 123 }[\"key\"] as object literal indexed access',\n      macroReplNoErrorsAndStdoutContains,\n      '{ key: 123 }[\"key\"]',\n      '123'\n    );\n    test(\n      'repl should treat { key: 123 }.foo as object literal non-existent property access',\n      macroReplStderrContains,\n      '{ key: 123 }.foo',\n      \"Property 'foo' does not exist on type\"\n    );\n    test(\n      'repl should treat { key: 123 }[\"foo\"] as object literal non-existent indexed access',\n      macroReplStderrContains,\n      '{ key: 123 }[\"foo\"]',\n      \"Property 'foo' does not exist on type\"\n    );\n  });\n});\n\ntest.suite('repl executes input as cjs even in esm projects', (test) => {\n  test.if(tsSupportsMtsCtsExtensions);\n  test('test', async (t) => {\n    // Must exec child process, because we need a different cwd.\n    const p = exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} -i`, {\n      cwd: join(TEST_DIR, 'repl-in-esm-package'),\n    });\n    p.child.stdin!.write('import fs2 from \"fs\"; fs2.existsSync(\"does not exist\")');\n    p.child.stdin!.end();\n    const r = await p;\n    expect(r.stdout).toBe('> false\\n> ');\n    expect(r.stderr).toBe('');\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/resolver.spec.d.ts b/node_modules/ts-node/dist/test/resolver.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/resolver.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/resolver.spec.js b/node_modules/ts-node/dist/test/resolver.spec.js
new file mode 100644
index 0000000..d48dd37
--- /dev/null
+++ b/node_modules/ts-node/dist/test/resolver.spec.js
@@ -0,0 +1,606 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const testlib_1 = require("./testlib");
+const helpers_1 = require("./helpers");
+const fs_fixture_builder_1 = require("@TypeStrong/fs-fixture-builder");
+const path_1 = require("path");
+require("semver");
+const lodash_1 = require("lodash");
+const url_1 = require("url");
+const fs = require("fs");
+const Path = require("path");
+/*
+ * Each test case is a separate TS project, with a different permutation of
+ * project options.  The project is written to disc, then ts-node is installed,
+ * then several entrypoint-* files are imported to test our resolver.
+ *
+ * High-level structure of these tests:
+ *   package.json, tsconfig.json, src/, and out/
+ *   entrypoint-* files are the entrypoints
+ *   they import a bunch of target files / directories / node_modules
+ *
+ * The heart of this test is every time an entrypoint imports a target.
+ * We are testing if the resolver figures out the correct target file to import.
+ *
+ * To better understand the emitted projects, run the tests, then look in `tests/tmp/resolver-*`
+ *
+ * Whenever a test fails, the error will log a command you can paste into your terminal to re-run
+ * that project *outside* of this test suite.  This may be helpful in understanding and debugging
+ * these tests.
+ */
+// Test a bunch of permutations of:
+// import permutations:
+//   - [x] Relative import of file
+//   - [x] Relative import of index
+//   - [x] rootless library import of main
+//   - [x] rootless library import of index
+//   - [x] rootless library import of exports sub-path
+//   - [x] rootless self-import of main
+//   - [x] rootless self-import of index
+//   - [x] rootless self-import of exports sub-path
+//     - [x] Require with extension
+//     - [x] Require without extension
+//     - Require from dist to dist
+//     - Require from dist to src
+//     - Require from src to dist
+//     - [x] Require from src to src
+// lib permutations:
+//   - [x] module exists in both src and dist (precompilation ran)
+//   - [x] module exists in only dist (came from elsewhere)
+//   - [x] module exists only in src (did not precompile)
+//   - .ts / .js extension
+//   - .tsx / .js extension
+//   - .cts / .cjs extension
+//   - .mts / .mjs extension
+//   - .js / .js extension
+//   - .jsx / .js extension
+//   - .cjs / .cjs extension
+//   - .mjs / .mjs extension
+// Side-step compiler transformation of import() into require()
+const dynamicImport = new Function('specifier', 'return import(specifier)');
+// For some reason `new Function` was triggering what *might* be a node bug,
+// where `context.parentURL` passed into loader `resolve()` was wrong.
+// eval works for unknown reasons.  This may change in future node releases.
+const declareDynamicImportFunction = `const dynamicImport = eval('(specifier) => import(specifier)');`;
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+const projectSeq = seqGenerator();
+const entrypointSeq = seqGenerator();
+const targetSeq = seqGenerator();
+const targetPackageStyles = [
+    false,
+    // test that the package contains /index.*
+    'empty-manifest',
+    // "main": "src/target.<ext>"
+    'main-src-with-extension',
+    // "main": "src/target.<output ext>"
+    'main-src-with-out-extension',
+    // "main": "out/target.<output ext>"
+    'main-out-with-extension',
+    // "main": "src/target"
+    'main-src-extensionless',
+    // "main": "out/target"
+    'main-out-extensionless',
+    // "exports": {".": "src/target.<ext>"}
+    'exports-src-with-extension',
+    // "exports": {".": "src/target.<output ext>"}
+    'exports-src-with-out-extension',
+    // "exports": {".": "out/target.<output ext>"}
+    'exports-out-with-extension',
+];
+test.suite('Resolver hooks', (test) => {
+    test.serial();
+    test.if(helpers_1.tsSupportsMtsCtsExtensions);
+    //
+    // Generate all permutations of projects
+    //
+    for (const preferSrc of [false, true]) {
+        for (const typeModule of [false, true]) {
+            for (const allowJs of [false, true]) {
+                for (const useTsNodeNext of [false, true]) {
+                    // TODO test against skipIgnore: false, where imports of third-party deps in `node_modules` should not get our mapping behaviors
+                    for (const skipIgnore of [/*false, */ true]) {
+                        for (const experimentalSpecifierResolutionNode of [false, true]) {
+                            let identifier = `resolver-${projectSeq()}`;
+                            identifier += preferSrc ? '-preferSrc' : '-preferOut';
+                            identifier += typeModule ? '-typeModule' : '-typeCjs---';
+                            identifier += allowJs ? '-allowJs' : '--------';
+                            identifier += useTsNodeNext ? '-useTsNodenext' : '--------------';
+                            identifier += skipIgnore ? '-skipIgnore' : '-----------';
+                            identifier += experimentalSpecifierResolutionNode ? '-experimentalSpecifierResolutionNode' : '';
+                            const project = {
+                                identifier,
+                                allowJs,
+                                preferSrc,
+                                typeModule,
+                                useTsNodeNext,
+                                experimentalSpecifierResolutionNode,
+                                skipIgnore,
+                            };
+                            declareProject(test, project);
+                        }
+                    }
+                }
+            }
+        }
+    }
+});
+function declareProject(_test, project) {
+    const test = project.useTsNodeNext && !helpers_1.tsSupportsStableNodeNextNode16 ? _test.skip : _test;
+    test(`${project.identifier}`, async (t) => {
+        t.teardown(() => {
+            (0, helpers_1.resetNodeEnvironment)();
+        });
+        const p = (0, fs_fixture_builder_1.project)(project.identifier);
+        p.rm();
+        p.addJsonFile('package.json', {
+            type: project.typeModule ? 'module' : undefined,
+        });
+        p.addJsonFile('tsconfig.json', {
+            'ts-node': {
+                experimentalResolver: true,
+                preferTsExts: project.preferSrc,
+                transpileOnly: true,
+                experimentalSpecifierResolution: project.experimentalSpecifierResolutionNode ? 'node' : undefined,
+                skipIgnore: project.skipIgnore,
+            },
+            compilerOptions: {
+                allowJs: project.allowJs,
+                skipLibCheck: true,
+                // TODO add nodenext permutation
+                module: project.useTsNodeNext ? 'NodeNext' : project.typeModule ? 'esnext' : 'commonjs',
+                jsx: 'react',
+                target: 'esnext',
+            },
+        });
+        const targets = generateTargets(project, p);
+        const entrypoints = generateEntrypoints(project, p, targets);
+        p.write();
+        await execute(t, p, entrypoints);
+    });
+}
+//
+// Generate all target-* files
+//
+function generateTargets(project, p) {
+    /** Array of metadata about target files to be imported */
+    const targets = [];
+    // TODO does allowJs matter?
+    for (const inOut of [false, true]) {
+        for (const inSrc of [false, true]) {
+            for (const srcExt of ['ts', 'tsx', 'cts', 'mts', 'jsx', 'js', 'cjs', 'mjs']) {
+                for (const targetPackageStyle of targetPackageStyles) {
+                    const packageTypeModulePermutations = targetPackageStyle ? [true, false] : [project.typeModule];
+                    for (const packageTypeModule of packageTypeModulePermutations) {
+                        const isIndexPermutations = targetPackageStyle ? [false] : [true, false];
+                        // TODO test main pointing to a directory containing an `index.` file?
+                        for (const isIndex of isIndexPermutations) {
+                            //#region SKIPPING
+                            if (!inSrc && !inOut)
+                                continue;
+                            // Don't bother with jsx if we don't have allowJs enabled
+                            // TODO Get rid of this?  "Just work" in this case?
+                            if (srcExt === 'jsx' && !project.allowJs)
+                                continue;
+                            // Don't bother with src-only extensions when only emitting to `out`
+                            if (!inSrc && ['ts', 'tsx', 'cts', 'mts', 'jsx'].includes(srcExt))
+                                continue;
+                            // TODO re-enable with src <-> out mapping
+                            if (!inOut &&
+                                (0, helpers_1.isOneOf)(targetPackageStyle, [
+                                    'main-out-with-extension',
+                                    'main-out-extensionless',
+                                    'exports-out-with-extension',
+                                ]))
+                                continue;
+                            if (!inSrc &&
+                                (0, helpers_1.isOneOf)(targetPackageStyle, [
+                                    'main-src-with-extension',
+                                    'main-src-extensionless',
+                                    'exports-src-with-extension',
+                                ]))
+                                continue;
+                            if ((0, helpers_1.isOneOf)(targetPackageStyle, [
+                                'main-out-with-extension',
+                                'main-out-extensionless',
+                                'exports-out-with-extension',
+                            ]))
+                                continue;
+                            //#endregion
+                            targets.push(generateTarget(project, p, {
+                                inSrc,
+                                inOut,
+                                srcExt,
+                                targetPackageStyle,
+                                packageTypeModule,
+                                isIndex,
+                            }));
+                        }
+                    }
+                }
+            }
+        }
+    }
+    return targets;
+}
+function generateTarget(project, p, options) {
+    const { inSrc, inOut, srcExt, targetPackageStyle, packageTypeModule, isIndex } = options;
+    const outExt = srcExt.replace('ts', 'js').replace('x', '');
+    let targetIdentifier = `target-${targetSeq()}-${inOut && inSrc ? 'inboth' : inOut ? 'onlyout' : 'onlysrc'}-${srcExt}`;
+    if (targetPackageStyle)
+        targetIdentifier = `${targetIdentifier}-${targetPackageStyle}-${packageTypeModule ? 'module' : 'commonjs'}`;
+    let prefix = targetPackageStyle ? `node_modules/${targetIdentifier}/` : '';
+    let suffix = targetPackageStyle === 'empty-manifest' ? 'index' : targetPackageStyle ? 'target' : targetIdentifier;
+    if (isIndex)
+        suffix += '-dir/index';
+    const srcDirInfix = targetPackageStyle === 'empty-manifest' ? '' : 'src/';
+    const outDirInfix = targetPackageStyle === 'empty-manifest' ? '' : 'out/';
+    const srcName = `${prefix}${srcDirInfix}${suffix}.${srcExt}`;
+    const srcDirOutExtName = `${prefix}${srcDirInfix}${suffix}.${outExt}`;
+    const outName = `${prefix}${outDirInfix}${suffix}.${outExt}`;
+    const selfImporterCjsName = `${prefix}self-import-cjs.cjs`;
+    const selfImporterMjsName = `${prefix}self-import-mjs.mjs`;
+    const target = {
+        targetIdentifier,
+        srcName,
+        outName,
+        srcExt,
+        outExt,
+        inSrc,
+        inOut,
+        isNamedFile: !isIndex && !targetPackageStyle,
+        isIndex,
+        isPackage: !!targetPackageStyle,
+        packageStyle: targetPackageStyle,
+        typeModule: packageTypeModule,
+    };
+    const { isMjs: targetIsMjs } = fileInfo('.' + srcExt, packageTypeModule, project.allowJs);
+    function targetContent(loc) {
+        let content = '';
+        if (targetIsMjs) {
+            content += String.raw `
+        const {fileURLToPath} = await import('url');
+        const filenameNative = fileURLToPath(import.meta.url);
+        export const directory = filenameNative.replace(/.*[\\\/](.*?)[\\\/]/, '$1');
+        export const filename = filenameNative.replace(/.*[\\\/]/, '');
+        export const targetIdentifier = '${targetIdentifier}';
+        export const ext = filenameNative.replace(/.*\./, '');
+        export const loc = '${loc}';
+      `;
+        }
+        else {
+            content += String.raw `
+        const filenameNative = __filename;
+        exports.filename = filenameNative.replace(/.*[\\\/]/, '');
+        exports.directory = filenameNative.replace(/.*[\\\/](.*?)[\\\/].*/, '$1');
+        exports.targetIdentifier = '${targetIdentifier}';
+        exports.ext = filenameNative.replace(/.*\./, '');
+        exports.loc = '${loc}';
+      `;
+        }
+        return content;
+    }
+    if (inOut) {
+        p.addFile(outName, targetContent('out'));
+        // TODO so we can test multiple file extensions in a single directory, preferTsExt
+        p.addFile(srcDirOutExtName, targetContent('out'));
+    }
+    if (inSrc) {
+        p.addFile(srcName, targetContent('src'));
+    }
+    if (targetPackageStyle) {
+        const selfImporterIsCompiled = project.allowJs;
+        const cjsSelfImporterMustUseDynamicImportHack = !project.useTsNodeNext && selfImporterIsCompiled && targetIsMjs;
+        p.addFile(selfImporterCjsName, targetIsMjs
+            ? cjsSelfImporterMustUseDynamicImportHack
+                ? `${declareDynamicImportFunction}\nmodule.exports = dynamicImport('${targetIdentifier}');`
+                : `module.exports = import("${targetIdentifier}");`
+            : `module.exports = require("${targetIdentifier}");`);
+        p.addFile(selfImporterMjsName, `
+        export * from "${targetIdentifier}";
+      `);
+        function writePackageJson(obj) {
+            p.addJsonFile(`${prefix}/package.json`, {
+                name: targetIdentifier,
+                type: packageTypeModule ? 'module' : undefined,
+                ...obj,
+            });
+        }
+        switch (targetPackageStyle) {
+            case 'empty-manifest':
+                writePackageJson({});
+                break;
+            case 'exports-src-with-extension':
+                writePackageJson({
+                    exports: {
+                        '.': `./src/${suffix}.${srcExt}`,
+                    },
+                });
+                break;
+            case 'exports-src-with-out-extension':
+                writePackageJson({
+                    exports: {
+                        '.': `./src/${suffix}.${outExt}`,
+                    },
+                });
+                break;
+            case 'exports-out-with-extension':
+                writePackageJson({
+                    exports: {
+                        '.': `./out/${suffix}.${outExt}`,
+                    },
+                });
+                break;
+            case 'main-src-extensionless':
+                writePackageJson({
+                    main: `src/${suffix}`,
+                });
+                break;
+            case 'main-out-extensionless':
+                writePackageJson({
+                    main: `out/${suffix}`,
+                });
+                break;
+            case 'main-src-with-extension':
+                writePackageJson({
+                    main: `src/${suffix}.${srcExt}`,
+                });
+                break;
+            case 'main-src-with-out-extension':
+                writePackageJson({
+                    main: `src/${suffix}.${outExt}`,
+                });
+                break;
+            case 'main-out-with-extension':
+                writePackageJson({
+                    main: `src/${suffix}.${outExt}`,
+                });
+                break;
+            default:
+                const _assert = targetPackageStyle;
+        }
+    }
+    return target;
+}
+/**
+ * Generate all entrypoint-* files
+ */
+function generateEntrypoints(project, p, targets) {
+    /** Array of entrypoint files to be imported during the test */
+    let entrypoints = [];
+    for (const entrypointExt of ['cjs', 'mjs']) {
+        // TODO consider removing this logic; deferring to conditionals in the generateEntrypoint which emit meaningful comments
+        const withExtPermutations = entrypointExt == 'mjs' && project.experimentalSpecifierResolutionNode === false ? [true] : [false, true];
+        for (const withExt of withExtPermutations) {
+            // Location of the entrypoint
+            for (const entrypointLocation of ['src', 'out']) {
+                // Target of the entrypoint's import statements
+                for (const entrypointTargetting of ['src', 'out']) {
+                    // TODO re-enable when we have out <-> src mapping
+                    if (entrypointLocation !== 'src')
+                        continue;
+                    if (entrypointTargetting !== 'src')
+                        continue;
+                    entrypoints.push(generateEntrypoint(project, p, targets, {
+                        entrypointExt,
+                        withExt,
+                        entrypointLocation,
+                        entrypointTargetting,
+                    }));
+                }
+            }
+        }
+    }
+    return entrypoints;
+}
+function generateEntrypoint(project, p, targets, opts) {
+    const { entrypointExt, withExt, entrypointLocation, entrypointTargetting } = opts;
+    const entrypointFilename = `entrypoint-${entrypointSeq()}-${entrypointLocation}-to-${entrypointTargetting}${withExt ? '-withext' : ''}.${entrypointExt}`;
+    const { isMjs: entrypointIsMjs, isCompiled: entrypointIsCompiled } = fileInfo(entrypointFilename, project.typeModule, project.allowJs);
+    let entrypointContent = 'let mod;\n';
+    entrypointContent += 'let testsRun = 0;\n';
+    if (entrypointIsMjs) {
+        entrypointContent += `import assert from 'assert';\n`;
+    }
+    else {
+        entrypointContent += `const assert = require('assert');\n`;
+        entrypointContent += `${declareDynamicImportFunction}\n`;
+    }
+    entrypointContent += `async function main() {\n`;
+    for (const target of targets) {
+        // TODO re-enable these when we have outDir <-> rootDir mapping
+        if (target.srcName.includes('onlyout') && entrypointTargetting === 'src')
+            continue;
+        if (target.srcName.includes('onlysrc') && entrypointTargetting === 'out')
+            continue;
+        const { ext: targetSrcExt, isMjs: targetIsMjs, isCompiled: targetIsCompiled, } = fileInfo(target.srcName, target.typeModule, project.allowJs);
+        let targetExtPermutations = [''];
+        if (!target.isPackage) {
+            if (entrypointTargetting === 'out' && target.outExt !== target.srcExt) {
+                // TODO re-enable when we have out <-> src mapping
+                targetExtPermutations = [target.outExt];
+            }
+            else if (target.srcExt !== target.outExt) {
+                targetExtPermutations = [target.srcExt, target.outExt];
+            }
+            else {
+                targetExtPermutations = [target.srcExt];
+            }
+        }
+        const externalPackageSelfImportPermutations = target.isPackage ? [false, true] : [false];
+        for (const targetExt of targetExtPermutations) {
+            for (const externalPackageSelfImport of externalPackageSelfImportPermutations) {
+                entrypointContent += `\n// ${target.targetIdentifier}`;
+                if (target.isPackage) {
+                    entrypointContent += ` node_modules package`;
+                    if (externalPackageSelfImport) {
+                        entrypointContent += ` self-import`;
+                    }
+                }
+                else {
+                    entrypointContent += `.${targetExt}`;
+                }
+                entrypointContent += '\n';
+                // should specifier be relative or absolute?
+                let specifier;
+                if (externalPackageSelfImport) {
+                    specifier = `../node_modules/${target.targetIdentifier}/self-import-${entrypointExt}.${entrypointExt}`;
+                }
+                else if (target.isPackage) {
+                    specifier = target.targetIdentifier;
+                }
+                else {
+                    if (entrypointTargetting === entrypointLocation)
+                        specifier = './';
+                    else
+                        specifier = `../${entrypointTargetting}/`;
+                    specifier += target.targetIdentifier;
+                    if (target.isIndex)
+                        specifier += '-dir';
+                    if (!target.isIndex && withExt)
+                        specifier += '.' + targetExt;
+                }
+                //#region SKIPPING
+                if (target.isNamedFile && !withExt) {
+                    // Do not try to import cjs/cts without extension; node always requires these extensions
+                    if (target.outExt === 'cjs') {
+                        entrypointContent += `// skipping ${specifier} because we cannot omit extension from cjs / cts files; node always requires them\n`;
+                        continue;
+                    }
+                    // Do not try to import mjs/mts unless experimental-specifier-resolution is turned on
+                    if (target.outExt === 'mjs' && !project.experimentalSpecifierResolutionNode) {
+                        entrypointContent += `// skipping ${specifier} because we cannot omit extension from mjs/mts unless experimental-specifier-resolution=node\n`;
+                        continue;
+                    }
+                    // Do not try to import anything extensionless via ESM loader unless experimental-specifier-resolution is turned on
+                    if ((targetIsMjs || entrypointIsMjs) && !project.experimentalSpecifierResolutionNode) {
+                        entrypointContent += `// skipping ${specifier} because we cannot omit extension via esm loader unless experimental-specifier-resolution=node\n`;
+                        continue;
+                    }
+                }
+                if (target.isPackage &&
+                    (0, helpers_1.isOneOf)(target.packageStyle, ['empty-manifest', 'main-out-extensionless', 'main-src-extensionless']) &&
+                    (0, helpers_1.isOneOf)(target.outExt, ['cjs', 'mjs'])) {
+                    entrypointContent += `// skipping ${specifier} because it points to a node_modules package that tries to omit file extension, and node does not allow omitting cjs/mjs extension\n`;
+                    continue;
+                }
+                // Do not try to import a transpiled file if compiler options disagree with node's extension-based classification
+                if (!project.useTsNodeNext && targetIsCompiled) {
+                    if (targetIsMjs && !project.typeModule) {
+                        entrypointContent += `// skipping ${specifier} because it is compiled and compiler options disagree with node's module classification: extension=${targetSrcExt}, tsconfig module=commonjs\n`;
+                        continue;
+                    }
+                    if (!targetIsMjs && project.typeModule) {
+                        entrypointContent += `// skipping ${specifier} because it is compiled and compiler options disagree with node's module classification: extension=${targetSrcExt}, tsconfig module=esnext\n`;
+                        continue;
+                    }
+                }
+                // Do not try to import index from a directory if is forbidden by node's ESM resolver
+                if (target.isIndex) {
+                    if ((targetIsMjs || entrypointIsMjs) && !project.experimentalSpecifierResolutionNode) {
+                        entrypointContent += `// skipping ${specifier} because esm loader does not allow directory ./index imports unless experimental-specifier-resolution=node\n`;
+                        continue;
+                    }
+                    if (target.outExt === 'cjs') {
+                        entrypointContent += `// skipping ${specifier} because it relies on node automatically resolving a directory to index.cjs/cts , but node does not support those extensions for index.* files, only .js (and equivalents), .node, .json\n`;
+                        continue;
+                    }
+                }
+                //#endregion
+                // NOTE: if you try to explicitly import foo.ts, we will load foo.ts, EVEN IF you have `preferTsExts` off
+                const assertIsSrcOrOut = !target.inSrc
+                    ? 'out'
+                    : !target.inOut
+                        ? 'src'
+                        : project.preferSrc ||
+                            (!target.isIndex && targetExt === target.srcExt && withExt) ||
+                            target.srcExt === target.outExt || // <-- TODO re-enable when we have src <-> out mapping
+                            (target.isPackage &&
+                                (0, helpers_1.isOneOf)(target.packageStyle, ['main-src-with-extension', 'exports-src-with-extension']))
+                            ? 'src'
+                            : 'out';
+                const assertHasExt = assertIsSrcOrOut === 'src' ? target.srcExt : target.outExt;
+                // If entrypoint is compiled as CJS, and *not* with TS's nodenext, then TS transforms `import` into `require`,
+                // so we must hack around the compiler to get a true `import`.
+                const entrypointMustUseDynamicImportHack = !project.useTsNodeNext && entrypointIsCompiled && !entrypointIsMjs && !externalPackageSelfImport;
+                entrypointContent +=
+                    entrypointExt === 'cjs' && (externalPackageSelfImport || !targetIsMjs)
+                        ? `  mod = await require('${specifier}');\n`
+                        : entrypointMustUseDynamicImportHack
+                            ? `  mod = await dynamicImport('${specifier}');\n`
+                            : `  mod = await import('${specifier}');\n`;
+                entrypointContent += `  assert.equal(mod.loc, '${assertIsSrcOrOut}');\n`;
+                entrypointContent += `  assert.equal(mod.targetIdentifier, '${target.targetIdentifier}');\n`;
+                entrypointContent += `  assert.equal(mod.ext, '${assertHasExt}');\n`;
+                entrypointContent += `  testsRun++;\n`;
+            }
+        }
+    }
+    entrypointContent += `}\n`;
+    entrypointContent += `const result = main().then(() => {return testsRun});\n`;
+    entrypointContent += `result.mark = 'marked';\n`;
+    if (entrypointIsMjs) {
+        entrypointContent += `export {result};\n`;
+    }
+    else {
+        entrypointContent += `exports.result = result;\n`;
+    }
+    p.dir(entrypointLocation).addFile(entrypointFilename, entrypointContent);
+    return entrypointLocation + '/' + entrypointFilename;
+}
+/**
+ * Assertions happen here
+ */
+async function execute(t, p, entrypoints) {
+    //
+    // Install ts-node and try to import all the index-* files
+    //
+    const service = t.context.tsNodeUnderTest.register({
+        projectSearchDir: p.cwd,
+    });
+    process.__test_setloader__(t.context.tsNodeUnderTest.createEsmHooks(service));
+    for (const entrypoint of entrypoints) {
+        t.log(`Importing ${(0, path_1.join)(p.cwd, entrypoint)}`);
+        try {
+            const { result } = await dynamicImport((0, url_1.pathToFileURL)((0, path_1.join)(p.cwd, entrypoint)));
+            (0, testlib_1.expect)(result).toBeInstanceOf(Promise);
+            (0, testlib_1.expect)(result.mark).toBe('marked');
+            const testsRun = await result;
+            t.log(`Entrypoint ran ${testsRun} tests.`);
+        }
+        catch (e) {
+            try {
+                const launchJsonPath = Path.resolve(__dirname, '../../.vscode/launch.json');
+                const launchJson = JSON.parse(fs.readFileSync(launchJsonPath, 'utf8'));
+                const config = launchJson.configurations.find((c) => c.name === 'Debug resolver test');
+                config.cwd = Path.join('${workspaceFolder}', Path.relative(Path.resolve(__dirname, '../..'), p.cwd));
+                config.program = `./${entrypoint}`;
+                fs.writeFileSync(launchJsonPath, JSON.stringify(launchJson, null, 2));
+            }
+            catch { }
+            throw new Error([
+                e.message,
+                e.stack,
+                '',
+                'This is an error in a resolver test. It might be easier to investigate by running outside of the test suite.',
+                'To do that, try pasting this into your bash shell (windows invocation will be similar but maybe not identical):',
+                `    ( cd ${p.cwd} ; node --loader ../../../esm.mjs ./${entrypoint} )`,
+            ].join('\n'));
+        }
+    }
+}
+function fileInfo(filename, typeModule, allowJs) {
+    const ext = filename.match(/\.(.*)$/)?.[1] ?? filename;
+    // ['ts', 'tsx', 'cts', 'mts', 'js', 'jsx', 'cjs', 'mjs']
+    return {
+        ext,
+        isMjs: ['mts', 'mjs'].includes(ext) ? true : ['cts', 'cjs'].includes(ext) ? false : typeModule,
+        isCompiled: allowJs || ['ts', 'tsx', 'jsx', 'mts', 'cts'].includes(ext),
+    };
+}
+function seqGenerator() {
+    let next = 0;
+    return function () {
+        return (0, lodash_1.padStart)('' + next++, 4, '0');
+    };
+}
+//# sourceMappingURL=resolver.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/resolver.spec.js.map b/node_modules/ts-node/dist/test/resolver.spec.js.map
new file mode 100644
index 0000000..58d430a
--- /dev/null
+++ b/node_modules/ts-node/dist/test/resolver.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"resolver.spec.js","sourceRoot":"","sources":["../../src/test/resolver.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { context, ExecutionContext, expect, TestInterface } from './testlib';\nimport {\n  ctxTsNode,\n  isOneOf,\n  resetNodeEnvironment,\n  ts,\n  tsSupportsMtsCtsExtensions,\n  tsSupportsStableNodeNextNode16,\n} from './helpers';\nimport { project as fsProject, Project as FsProject } from '@TypeStrong/fs-fixture-builder';\nimport { join } from 'path';\nimport * as semver from 'semver';\nimport { padStart } from 'lodash';\nimport _ = require('lodash');\nimport { pathToFileURL } from 'url';\nimport type { RegisterOptions } from '..';\nimport * as fs from 'fs';\nimport * as Path from 'path';\n\n/*\n * Each test case is a separate TS project, with a different permutation of\n * project options.  The project is written to disc, then ts-node is installed,\n * then several entrypoint-* files are imported to test our resolver.\n *\n * High-level structure of these tests:\n *   package.json, tsconfig.json, src/, and out/\n *   entrypoint-* files are the entrypoints\n *   they import a bunch of target files / directories / node_modules\n *\n * The heart of this test is every time an entrypoint imports a target.\n * We are testing if the resolver figures out the correct target file to import.\n *\n * To better understand the emitted projects, run the tests, then look in `tests/tmp/resolver-*`\n *\n * Whenever a test fails, the error will log a command you can paste into your terminal to re-run\n * that project *outside* of this test suite.  This may be helpful in understanding and debugging\n * these tests.\n */\n\n// Test a bunch of permutations of:\n\n// import permutations:\n\n//   - [x] Relative import of file\n//   - [x] Relative import of index\n//   - [x] rootless library import of main\n//   - [x] rootless library import of index\n//   - [x] rootless library import of exports sub-path\n//   - [x] rootless self-import of main\n//   - [x] rootless self-import of index\n//   - [x] rootless self-import of exports sub-path\n\n//     - [x] Require with extension\n//     - [x] Require without extension\n\n//     - Require from dist to dist\n//     - Require from dist to src\n//     - Require from src to dist\n//     - [x] Require from src to src\n\n// lib permutations:\n\n//   - [x] module exists in both src and dist (precompilation ran)\n//   - [x] module exists in only dist (came from elsewhere)\n//   - [x] module exists only in src (did not precompile)\n\n//   - .ts / .js extension\n//   - .tsx / .js extension\n//   - .cts / .cjs extension\n//   - .mts / .mjs extension\n//   - .js / .js extension\n//   - .jsx / .js extension\n//   - .cjs / .cjs extension\n//   - .mjs / .mjs extension\n\n// Side-step compiler transformation of import() into require()\nconst dynamicImport = new Function('specifier', 'return import(specifier)');\n// For some reason `new Function` was triggering what *might* be a node bug,\n// where `context.parentURL` passed into loader `resolve()` was wrong.\n// eval works for unknown reasons.  This may change in future node releases.\nconst declareDynamicImportFunction = `const dynamicImport = eval('(specifier) => import(specifier)');`;\n\nconst test = context(ctxTsNode);\ntype Test = TestInterface<ctxTsNode.Ctx>;\ntype T = ExecutionContext<ctxTsNode.Ctx>;\n\nconst projectSeq = seqGenerator();\nconst entrypointSeq = seqGenerator();\nconst targetSeq = seqGenerator();\n\ninterface Project {\n  identifier: string;\n  allowJs: boolean;\n  preferSrc: boolean;\n  typeModule: boolean;\n  /** Use TS's new module: `nodenext` option */\n  useTsNodeNext: boolean;\n  experimentalSpecifierResolutionNode: boolean;\n  skipIgnore: boolean;\n}\ninterface EntrypointPermutation {\n  entrypointExt: 'cjs' | 'mjs';\n  withExt: boolean;\n  entrypointLocation: 'src' | 'out';\n  entrypointTargetting: 'src' | 'out';\n}\ntype Entrypoint = string;\ninterface GenerateTargetOptions {\n  inSrc: boolean;\n  inOut: boolean;\n  srcExt: string;\n  /** If true, is an index.* file within a directory */\n  isIndex: boolean;\n  targetPackageStyle: TargetPackageStyle;\n  packageTypeModule: boolean;\n}\ninterface Target {\n  targetIdentifier: string;\n  outName: string;\n  srcName: string;\n  srcExt: string;\n  outExt: string;\n  inSrc: boolean;\n  inOut: boolean;\n  /** If true, is neither an index.* nor a package */\n  isNamedFile: boolean;\n  /** If true, is an index.* file within a directory */\n  isIndex: boolean;\n  /** If true, should be imported as an npm package, not relative import */\n  isPackage: boolean;\n  packageStyle: TargetPackageStyle;\n  typeModule: boolean;\n}\n\n/** When target is actually a mini node_modules package */\ntype TargetPackageStyle = typeof targetPackageStyles[number];\nconst targetPackageStyles = [\n  false,\n  // test that the package contains /index.*\n  'empty-manifest',\n  // \"main\": \"src/target.<ext>\"\n  'main-src-with-extension',\n  // \"main\": \"src/target.<output ext>\"\n  'main-src-with-out-extension',\n  // \"main\": \"out/target.<output ext>\"\n  'main-out-with-extension',\n  // \"main\": \"src/target\"\n  'main-src-extensionless',\n  // \"main\": \"out/target\"\n  'main-out-extensionless',\n  // \"exports\": {\".\": \"src/target.<ext>\"}\n  'exports-src-with-extension',\n  // \"exports\": {\".\": \"src/target.<output ext>\"}\n  'exports-src-with-out-extension',\n  // \"exports\": {\".\": \"out/target.<output ext>\"}\n  'exports-out-with-extension',\n] as const;\n\ntest.suite('Resolver hooks', (test) => {\n  test.serial();\n  test.if(tsSupportsMtsCtsExtensions);\n\n  //\n  // Generate all permutations of projects\n  //\n  for (const preferSrc of [false, true]) {\n    for (const typeModule of [false, true]) {\n      for (const allowJs of [false, true]) {\n        for (const useTsNodeNext of [false, true]) {\n          // TODO test against skipIgnore: false, where imports of third-party deps in `node_modules` should not get our mapping behaviors\n          for (const skipIgnore of [/*false, */ true]) {\n            for (const experimentalSpecifierResolutionNode of [false, true]) {\n              let identifier = `resolver-${projectSeq()}`;\n              identifier += preferSrc ? '-preferSrc' : '-preferOut';\n              identifier += typeModule ? '-typeModule' : '-typeCjs---';\n              identifier += allowJs ? '-allowJs' : '--------';\n              identifier += useTsNodeNext ? '-useTsNodenext' : '--------------';\n              identifier += skipIgnore ? '-skipIgnore' : '-----------';\n              identifier += experimentalSpecifierResolutionNode ? '-experimentalSpecifierResolutionNode' : '';\n\n              const project: Project = {\n                identifier,\n                allowJs,\n                preferSrc,\n                typeModule,\n                useTsNodeNext,\n                experimentalSpecifierResolutionNode,\n                skipIgnore,\n              };\n              declareProject(test, project);\n            }\n          }\n        }\n      }\n    }\n  }\n});\n\nfunction declareProject(_test: Test, project: Project) {\n  const test = project.useTsNodeNext && !tsSupportsStableNodeNextNode16 ? _test.skip : _test;\n  test(`${project.identifier}`, async (t) => {\n    t.teardown(() => {\n      resetNodeEnvironment();\n    });\n\n    const p = fsProject(project.identifier);\n    p.rm();\n\n    p.addJsonFile('package.json', {\n      type: project.typeModule ? 'module' : undefined,\n    });\n    p.addJsonFile('tsconfig.json', {\n      'ts-node': {\n        experimentalResolver: true,\n        preferTsExts: project.preferSrc,\n        transpileOnly: true,\n        experimentalSpecifierResolution: project.experimentalSpecifierResolutionNode ? 'node' : undefined,\n        skipIgnore: project.skipIgnore,\n      } as RegisterOptions,\n      compilerOptions: {\n        allowJs: project.allowJs,\n        skipLibCheck: true,\n        // TODO add nodenext permutation\n        module: project.useTsNodeNext ? 'NodeNext' : project.typeModule ? 'esnext' : 'commonjs',\n        jsx: 'react',\n        target: 'esnext',\n      },\n    });\n\n    const targets = generateTargets(project, p);\n    const entrypoints = generateEntrypoints(project, p, targets);\n    p.write();\n    await execute(t, p, entrypoints);\n  });\n}\n\n//\n// Generate all target-* files\n//\nfunction generateTargets(project: Project, p: FsProject) {\n  /** Array of metadata about target files to be imported */\n  const targets: Array<Target> = [];\n  // TODO does allowJs matter?\n  for (const inOut of [false, true]) {\n    for (const inSrc of [false, true]) {\n      for (const srcExt of ['ts', 'tsx', 'cts', 'mts', 'jsx', 'js', 'cjs', 'mjs']) {\n        for (const targetPackageStyle of targetPackageStyles) {\n          const packageTypeModulePermutations = targetPackageStyle ? [true, false] : [project.typeModule];\n          for (const packageTypeModule of packageTypeModulePermutations) {\n            const isIndexPermutations = targetPackageStyle ? [false] : [true, false];\n            // TODO test main pointing to a directory containing an `index.` file?\n            for (const isIndex of isIndexPermutations) {\n              //#region SKIPPING\n              if (!inSrc && !inOut) continue;\n\n              // Don't bother with jsx if we don't have allowJs enabled\n              // TODO Get rid of this?  \"Just work\" in this case?\n              if (srcExt === 'jsx' && !project.allowJs) continue;\n              // Don't bother with src-only extensions when only emitting to `out`\n              if (!inSrc && ['ts', 'tsx', 'cts', 'mts', 'jsx'].includes(srcExt)) continue;\n\n              // TODO re-enable with src <-> out mapping\n              if (\n                !inOut &&\n                isOneOf(targetPackageStyle, [\n                  'main-out-with-extension',\n                  'main-out-extensionless',\n                  'exports-out-with-extension',\n                ])\n              )\n                continue;\n              if (\n                !inSrc &&\n                isOneOf(targetPackageStyle, [\n                  'main-src-with-extension',\n                  'main-src-extensionless',\n                  'exports-src-with-extension',\n                ])\n              )\n                continue;\n              if (\n                isOneOf(targetPackageStyle, [\n                  'main-out-with-extension',\n                  'main-out-extensionless',\n                  'exports-out-with-extension',\n                ])\n              )\n                continue;\n              //#endregion\n\n              targets.push(\n                generateTarget(project, p, {\n                  inSrc,\n                  inOut,\n                  srcExt,\n                  targetPackageStyle,\n                  packageTypeModule,\n                  isIndex,\n                })\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n  return targets;\n}\n\nfunction generateTarget(project: Project, p: FsProject, options: GenerateTargetOptions) {\n  const { inSrc, inOut, srcExt, targetPackageStyle, packageTypeModule, isIndex } = options;\n\n  const outExt = srcExt.replace('ts', 'js').replace('x', '');\n  let targetIdentifier = `target-${targetSeq()}-${inOut && inSrc ? 'inboth' : inOut ? 'onlyout' : 'onlysrc'}-${srcExt}`;\n\n  if (targetPackageStyle)\n    targetIdentifier = `${targetIdentifier}-${targetPackageStyle}-${packageTypeModule ? 'module' : 'commonjs'}`;\n  let prefix = targetPackageStyle ? `node_modules/${targetIdentifier}/` : '';\n  let suffix = targetPackageStyle === 'empty-manifest' ? 'index' : targetPackageStyle ? 'target' : targetIdentifier;\n  if (isIndex) suffix += '-dir/index';\n  const srcDirInfix = targetPackageStyle === 'empty-manifest' ? '' : 'src/';\n  const outDirInfix = targetPackageStyle === 'empty-manifest' ? '' : 'out/';\n  const srcName = `${prefix}${srcDirInfix}${suffix}.${srcExt}`;\n  const srcDirOutExtName = `${prefix}${srcDirInfix}${suffix}.${outExt}`;\n  const outName = `${prefix}${outDirInfix}${suffix}.${outExt}`;\n  const selfImporterCjsName = `${prefix}self-import-cjs.cjs`;\n  const selfImporterMjsName = `${prefix}self-import-mjs.mjs`;\n  const target: Target = {\n    targetIdentifier,\n    srcName,\n    outName,\n    srcExt,\n    outExt,\n    inSrc,\n    inOut,\n    isNamedFile: !isIndex && !targetPackageStyle,\n    isIndex,\n    isPackage: !!targetPackageStyle,\n    packageStyle: targetPackageStyle,\n    typeModule: packageTypeModule,\n  };\n  const { isMjs: targetIsMjs } = fileInfo('.' + srcExt, packageTypeModule, project.allowJs);\n  function targetContent(loc: string) {\n    let content = '';\n    if (targetIsMjs) {\n      content += String.raw`\n        const {fileURLToPath} = await import('url');\n        const filenameNative = fileURLToPath(import.meta.url);\n        export const directory = filenameNative.replace(/.*[\\\\\\/](.*?)[\\\\\\/]/, '$1');\n        export const filename = filenameNative.replace(/.*[\\\\\\/]/, '');\n        export const targetIdentifier = '${targetIdentifier}';\n        export const ext = filenameNative.replace(/.*\\./, '');\n        export const loc = '${loc}';\n      `;\n    } else {\n      content += String.raw`\n        const filenameNative = __filename;\n        exports.filename = filenameNative.replace(/.*[\\\\\\/]/, '');\n        exports.directory = filenameNative.replace(/.*[\\\\\\/](.*?)[\\\\\\/].*/, '$1');\n        exports.targetIdentifier = '${targetIdentifier}';\n        exports.ext = filenameNative.replace(/.*\\./, '');\n        exports.loc = '${loc}';\n      `;\n    }\n    return content;\n  }\n  if (inOut) {\n    p.addFile(outName, targetContent('out'));\n    // TODO so we can test multiple file extensions in a single directory, preferTsExt\n    p.addFile(srcDirOutExtName, targetContent('out'));\n  }\n  if (inSrc) {\n    p.addFile(srcName, targetContent('src'));\n  }\n  if (targetPackageStyle) {\n    const selfImporterIsCompiled = project.allowJs;\n    const cjsSelfImporterMustUseDynamicImportHack = !project.useTsNodeNext && selfImporterIsCompiled && targetIsMjs;\n    p.addFile(\n      selfImporterCjsName,\n      targetIsMjs\n        ? cjsSelfImporterMustUseDynamicImportHack\n          ? `${declareDynamicImportFunction}\\nmodule.exports = dynamicImport('${targetIdentifier}');`\n          : `module.exports = import(\"${targetIdentifier}\");`\n        : `module.exports = require(\"${targetIdentifier}\");`\n    );\n    p.addFile(\n      selfImporterMjsName,\n      `\n        export * from \"${targetIdentifier}\";\n      `\n    );\n    function writePackageJson(obj: any) {\n      p.addJsonFile(`${prefix}/package.json`, {\n        name: targetIdentifier,\n        type: packageTypeModule ? 'module' : undefined,\n        ...obj,\n      });\n    }\n    switch (targetPackageStyle) {\n      case 'empty-manifest':\n        writePackageJson({});\n        break;\n      case 'exports-src-with-extension':\n        writePackageJson({\n          exports: {\n            '.': `./src/${suffix}.${srcExt}`,\n          },\n        });\n        break;\n      case 'exports-src-with-out-extension':\n        writePackageJson({\n          exports: {\n            '.': `./src/${suffix}.${outExt}`,\n          },\n        });\n        break;\n      case 'exports-out-with-extension':\n        writePackageJson({\n          exports: {\n            '.': `./out/${suffix}.${outExt}`,\n          },\n        });\n        break;\n      case 'main-src-extensionless':\n        writePackageJson({\n          main: `src/${suffix}`,\n        });\n        break;\n      case 'main-out-extensionless':\n        writePackageJson({\n          main: `out/${suffix}`,\n        });\n        break;\n      case 'main-src-with-extension':\n        writePackageJson({\n          main: `src/${suffix}.${srcExt}`,\n        });\n        break;\n      case 'main-src-with-out-extension':\n        writePackageJson({\n          main: `src/${suffix}.${outExt}`,\n        });\n        break;\n      case 'main-out-with-extension':\n        writePackageJson({\n          main: `src/${suffix}.${outExt}`,\n        });\n        break;\n      default:\n        const _assert: never = targetPackageStyle;\n    }\n  }\n  return target;\n}\n\n/**\n * Generate all entrypoint-* files\n */\nfunction generateEntrypoints(project: Project, p: FsProject, targets: Target[]) {\n  /** Array of entrypoint files to be imported during the test */\n  let entrypoints: string[] = [];\n  for (const entrypointExt of ['cjs', 'mjs'] as const) {\n    // TODO consider removing this logic; deferring to conditionals in the generateEntrypoint which emit meaningful comments\n    const withExtPermutations =\n      entrypointExt == 'mjs' && project.experimentalSpecifierResolutionNode === false ? [true] : [false, true];\n    for (const withExt of withExtPermutations) {\n      // Location of the entrypoint\n      for (const entrypointLocation of ['src', 'out'] as const) {\n        // Target of the entrypoint's import statements\n        for (const entrypointTargetting of ['src', 'out'] as const) {\n          // TODO re-enable when we have out <-> src mapping\n          if (entrypointLocation !== 'src') continue;\n          if (entrypointTargetting !== 'src') continue;\n\n          entrypoints.push(\n            generateEntrypoint(project, p, targets, {\n              entrypointExt,\n              withExt,\n              entrypointLocation,\n              entrypointTargetting,\n            })\n          );\n        }\n      }\n    }\n  }\n  return entrypoints;\n}\n\nfunction generateEntrypoint(project: Project, p: FsProject, targets: Target[], opts: EntrypointPermutation) {\n  const { entrypointExt, withExt, entrypointLocation, entrypointTargetting } = opts;\n  const entrypointFilename = `entrypoint-${entrypointSeq()}-${entrypointLocation}-to-${entrypointTargetting}${\n    withExt ? '-withext' : ''\n  }.${entrypointExt}`;\n  const { isMjs: entrypointIsMjs, isCompiled: entrypointIsCompiled } = fileInfo(\n    entrypointFilename,\n    project.typeModule,\n    project.allowJs\n  );\n  let entrypointContent = 'let mod;\\n';\n  entrypointContent += 'let testsRun = 0;\\n';\n  if (entrypointIsMjs) {\n    entrypointContent += `import assert from 'assert';\\n`;\n  } else {\n    entrypointContent += `const assert = require('assert');\\n`;\n    entrypointContent += `${declareDynamicImportFunction}\\n`;\n  }\n  entrypointContent += `async function main() {\\n`;\n\n  for (const target of targets) {\n    // TODO re-enable these when we have outDir <-> rootDir mapping\n    if (target.srcName.includes('onlyout') && entrypointTargetting === 'src') continue;\n    if (target.srcName.includes('onlysrc') && entrypointTargetting === 'out') continue;\n\n    const {\n      ext: targetSrcExt,\n      isMjs: targetIsMjs,\n      isCompiled: targetIsCompiled,\n    } = fileInfo(target.srcName, target.typeModule, project.allowJs);\n\n    let targetExtPermutations = [''];\n    if (!target.isPackage) {\n      if (entrypointTargetting === 'out' && target.outExt !== target.srcExt) {\n        // TODO re-enable when we have out <-> src mapping\n        targetExtPermutations = [target.outExt];\n      } else if (target.srcExt !== target.outExt) {\n        targetExtPermutations = [target.srcExt, target.outExt];\n      } else {\n        targetExtPermutations = [target.srcExt];\n      }\n    }\n    const externalPackageSelfImportPermutations = target.isPackage ? [false, true] : [false];\n    for (const targetExt of targetExtPermutations) {\n      for (const externalPackageSelfImport of externalPackageSelfImportPermutations) {\n        entrypointContent += `\\n// ${target.targetIdentifier}`;\n        if (target.isPackage) {\n          entrypointContent += ` node_modules package`;\n          if (externalPackageSelfImport) {\n            entrypointContent += ` self-import`;\n          }\n        } else {\n          entrypointContent += `.${targetExt}`;\n        }\n        entrypointContent += '\\n';\n\n        // should specifier be relative or absolute?\n        let specifier: string;\n        if (externalPackageSelfImport) {\n          specifier = `../node_modules/${target.targetIdentifier}/self-import-${entrypointExt}.${entrypointExt}`;\n        } else if (target.isPackage) {\n          specifier = target.targetIdentifier;\n        } else {\n          if (entrypointTargetting === entrypointLocation) specifier = './';\n          else specifier = `../${entrypointTargetting}/`;\n          specifier += target.targetIdentifier;\n          if (target.isIndex) specifier += '-dir';\n          if (!target.isIndex && withExt) specifier += '.' + targetExt;\n        }\n\n        //#region SKIPPING\n        if (target.isNamedFile && !withExt) {\n          // Do not try to import cjs/cts without extension; node always requires these extensions\n          if (target.outExt === 'cjs') {\n            entrypointContent += `// skipping ${specifier} because we cannot omit extension from cjs / cts files; node always requires them\\n`;\n            continue;\n          }\n          // Do not try to import mjs/mts unless experimental-specifier-resolution is turned on\n          if (target.outExt === 'mjs' && !project.experimentalSpecifierResolutionNode) {\n            entrypointContent += `// skipping ${specifier} because we cannot omit extension from mjs/mts unless experimental-specifier-resolution=node\\n`;\n            continue;\n          }\n          // Do not try to import anything extensionless via ESM loader unless experimental-specifier-resolution is turned on\n          if ((targetIsMjs || entrypointIsMjs) && !project.experimentalSpecifierResolutionNode) {\n            entrypointContent += `// skipping ${specifier} because we cannot omit extension via esm loader unless experimental-specifier-resolution=node\\n`;\n            continue;\n          }\n        }\n        if (\n          target.isPackage &&\n          isOneOf(target.packageStyle, ['empty-manifest', 'main-out-extensionless', 'main-src-extensionless']) &&\n          isOneOf(target.outExt, ['cjs', 'mjs'])\n        ) {\n          entrypointContent += `// skipping ${specifier} because it points to a node_modules package that tries to omit file extension, and node does not allow omitting cjs/mjs extension\\n`;\n          continue;\n        }\n\n        // Do not try to import a transpiled file if compiler options disagree with node's extension-based classification\n        if (!project.useTsNodeNext && targetIsCompiled) {\n          if (targetIsMjs && !project.typeModule) {\n            entrypointContent += `// skipping ${specifier} because it is compiled and compiler options disagree with node's module classification: extension=${targetSrcExt}, tsconfig module=commonjs\\n`;\n            continue;\n          }\n          if (!targetIsMjs && project.typeModule) {\n            entrypointContent += `// skipping ${specifier} because it is compiled and compiler options disagree with node's module classification: extension=${targetSrcExt}, tsconfig module=esnext\\n`;\n            continue;\n          }\n        }\n\n        // Do not try to import index from a directory if is forbidden by node's ESM resolver\n        if (target.isIndex) {\n          if ((targetIsMjs || entrypointIsMjs) && !project.experimentalSpecifierResolutionNode) {\n            entrypointContent += `// skipping ${specifier} because esm loader does not allow directory ./index imports unless experimental-specifier-resolution=node\\n`;\n            continue;\n          }\n          if (target.outExt === 'cjs') {\n            entrypointContent += `// skipping ${specifier} because it relies on node automatically resolving a directory to index.cjs/cts , but node does not support those extensions for index.* files, only .js (and equivalents), .node, .json\\n`;\n            continue;\n          }\n        }\n        //#endregion\n\n        // NOTE: if you try to explicitly import foo.ts, we will load foo.ts, EVEN IF you have `preferTsExts` off\n        const assertIsSrcOrOut = !target.inSrc\n          ? 'out'\n          : !target.inOut\n          ? 'src'\n          : project.preferSrc ||\n            (!target.isIndex && targetExt === target.srcExt && withExt) ||\n            target.srcExt === target.outExt || // <-- TODO re-enable when we have src <-> out mapping\n            (target.isPackage &&\n              isOneOf(target.packageStyle, ['main-src-with-extension', 'exports-src-with-extension']))\n          ? 'src'\n          : 'out';\n        const assertHasExt = assertIsSrcOrOut === 'src' ? target.srcExt : target.outExt;\n\n        // If entrypoint is compiled as CJS, and *not* with TS's nodenext, then TS transforms `import` into `require`,\n        // so we must hack around the compiler to get a true `import`.\n        const entrypointMustUseDynamicImportHack =\n          !project.useTsNodeNext && entrypointIsCompiled && !entrypointIsMjs && !externalPackageSelfImport;\n        entrypointContent +=\n          entrypointExt === 'cjs' && (externalPackageSelfImport || !targetIsMjs)\n            ? `  mod = await require('${specifier}');\\n`\n            : entrypointMustUseDynamicImportHack\n            ? `  mod = await dynamicImport('${specifier}');\\n`\n            : `  mod = await import('${specifier}');\\n`;\n        entrypointContent += `  assert.equal(mod.loc, '${assertIsSrcOrOut}');\\n`;\n        entrypointContent += `  assert.equal(mod.targetIdentifier, '${target.targetIdentifier}');\\n`;\n        entrypointContent += `  assert.equal(mod.ext, '${assertHasExt}');\\n`;\n        entrypointContent += `  testsRun++;\\n`;\n      }\n    }\n  }\n  entrypointContent += `}\\n`;\n  entrypointContent += `const result = main().then(() => {return testsRun});\\n`;\n  entrypointContent += `result.mark = 'marked';\\n`;\n  if (entrypointIsMjs) {\n    entrypointContent += `export {result};\\n`;\n  } else {\n    entrypointContent += `exports.result = result;\\n`;\n  }\n  p.dir(entrypointLocation).addFile(entrypointFilename, entrypointContent);\n  return entrypointLocation + '/' + entrypointFilename;\n}\n\n/**\n * Assertions happen here\n */\nasync function execute(t: T, p: FsProject, entrypoints: Entrypoint[]) {\n  //\n  // Install ts-node and try to import all the index-* files\n  //\n\n  const service = t.context.tsNodeUnderTest.register({\n    projectSearchDir: p.cwd,\n  });\n  process.__test_setloader__(t.context.tsNodeUnderTest.createEsmHooks(service));\n\n  for (const entrypoint of entrypoints) {\n    t.log(`Importing ${join(p.cwd, entrypoint)}`);\n    try {\n      const { result } = await dynamicImport(pathToFileURL(join(p.cwd, entrypoint)));\n      expect(result).toBeInstanceOf(Promise);\n      expect(result.mark).toBe('marked');\n      const testsRun = await result;\n      t.log(`Entrypoint ran ${testsRun} tests.`);\n    } catch (e) {\n      try {\n        const launchJsonPath = Path.resolve(__dirname, '../../.vscode/launch.json');\n        const launchJson = JSON.parse(fs.readFileSync(launchJsonPath, 'utf8'));\n        const config = launchJson.configurations.find((c: any) => c.name === 'Debug resolver test');\n        config.cwd = Path.join('${workspaceFolder}', Path.relative(Path.resolve(__dirname, '../..'), p.cwd));\n        config.program = `./${entrypoint}`;\n        fs.writeFileSync(launchJsonPath, JSON.stringify(launchJson, null, 2));\n      } catch {}\n      throw new Error(\n        [\n          (e as Error).message,\n          (e as Error).stack,\n          '',\n          'This is an error in a resolver test. It might be easier to investigate by running outside of the test suite.',\n          'To do that, try pasting this into your bash shell (windows invocation will be similar but maybe not identical):',\n          `    ( cd ${p.cwd} ; node --loader ../../../esm.mjs ./${entrypoint} )`,\n        ].join('\\n')\n      );\n    }\n  }\n}\n\nfunction fileInfo(filename: string, typeModule: boolean, allowJs: boolean) {\n  const ext = filename.match(/\\.(.*)$/)?.[1] ?? filename;\n  // ['ts', 'tsx', 'cts', 'mts', 'js', 'jsx', 'cjs', 'mjs']\n  return {\n    ext,\n    isMjs: ['mts', 'mjs'].includes(ext) ? true : ['cts', 'cjs'].includes(ext) ? false : typeModule,\n    isCompiled: allowJs || ['ts', 'tsx', 'jsx', 'mts', 'cts'].includes(ext),\n  };\n}\n\nfunction seqGenerator() {\n  let next = 0;\n  return function () {\n    return padStart('' + next++, 4, '0');\n  };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/sourcemaps.spec.d.ts b/node_modules/ts-node/dist/test/sourcemaps.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/sourcemaps.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/sourcemaps.spec.js b/node_modules/ts-node/dist/test/sourcemaps.spec.js
new file mode 100644
index 0000000..768bf66
--- /dev/null
+++ b/node_modules/ts-node/dist/test/sourcemaps.spec.js
@@ -0,0 +1,27 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const expect = require("expect");
+const helpers_1 = require("./helpers");
+const testlib_1 = require("./testlib");
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+const exec = (0, helpers_1.createExecTester)({
+    cmd: helpers_1.CMD_TS_NODE_WITH_PROJECT_FLAG,
+    exec: (0, helpers_1.createExec)({
+        cwd: helpers_1.TEST_DIR,
+    }),
+});
+test('Redirects source-map-support to @cspotcode/source-map-support so that third-party libraries get correct source-mapped locations', async () => {
+    const r = await exec({
+        flags: `./legacy-source-map-support-interop/index.ts`,
+    });
+    expect(r.err).toBeNull();
+    expect(r.stdout.split('\n')).toMatchObject([
+        expect.stringContaining('.ts:2 '),
+        'true',
+        'true',
+        expect.stringContaining('.ts:100:'),
+        expect.stringContaining('.ts:101 '),
+        '',
+    ]);
+});
+//# sourceMappingURL=sourcemaps.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/sourcemaps.spec.js.map b/node_modules/ts-node/dist/test/sourcemaps.spec.js.map
new file mode 100644
index 0000000..7518ff7
--- /dev/null
+++ b/node_modules/ts-node/dist/test/sourcemaps.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"sourcemaps.spec.js","sourceRoot":"","sources":["../../src/test/sourcemaps.spec.ts"],"names":[],"mappings":";;AAAA,iCAAiC;AACjC,uCAA6G;AAC7G,uCAAoC;AACpC,MAAM,IAAI,GAAG,IAAA,iBAAO,EAAC,mBAAS,CAAC,CAAC;AAEhC,MAAM,IAAI,GAAG,IAAA,0BAAgB,EAAC;IAC5B,GAAG,EAAE,uCAA6B;IAClC,IAAI,EAAE,IAAA,oBAAU,EAAC;QACf,GAAG,EAAE,kBAAQ;KACd,CAAC;CACH,CAAC,CAAC;AAEH,IAAI,CAAC,iIAAiI,EAAE,KAAK,IAAI,EAAE;IACjJ,MAAM,CAAC,GAAG,MAAM,IAAI,CAAC;QACnB,KAAK,EAAE,8CAA8C;KACtD,CAAC,CAAC;IACH,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC;IACzB,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,aAAa,CAAC;QACzC,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC;QACjC,MAAM;QACN,MAAM;QACN,MAAM,CAAC,gBAAgB,CAAC,UAAU,CAAC;QACnC,MAAM,CAAC,gBAAgB,CAAC,UAAU,CAAC;QACnC,EAAE;KACH,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import * as expect from 'expect';\nimport { createExec, createExecTester, CMD_TS_NODE_WITH_PROJECT_FLAG, ctxTsNode, TEST_DIR } from './helpers';\nimport { context } from './testlib';\nconst test = context(ctxTsNode);\n\nconst exec = createExecTester({\n  cmd: CMD_TS_NODE_WITH_PROJECT_FLAG,\n  exec: createExec({\n    cwd: TEST_DIR,\n  }),\n});\n\ntest('Redirects source-map-support to @cspotcode/source-map-support so that third-party libraries get correct source-mapped locations', async () => {\n  const r = await exec({\n    flags: `./legacy-source-map-support-interop/index.ts`,\n  });\n  expect(r.err).toBeNull();\n  expect(r.stdout.split('\\n')).toMatchObject([\n    expect.stringContaining('.ts:2 '),\n    'true',\n    'true',\n    expect.stringContaining('.ts:100:'),\n    expect.stringContaining('.ts:101 '),\n    '',\n  ]);\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/testlib.d.ts b/node_modules/ts-node/dist/test/testlib.d.ts
new file mode 100644
index 0000000..e5c68ef
--- /dev/null
+++ b/node_modules/ts-node/dist/test/testlib.d.ts
@@ -0,0 +1,2 @@
+import './helpers';
+export * from '@cspotcode/ava-lib';
diff --git a/node_modules/ts-node/dist/test/testlib.js b/node_modules/ts-node/dist/test/testlib.js
new file mode 100644
index 0000000..4bbd12f
--- /dev/null
+++ b/node_modules/ts-node/dist/test/testlib.js
@@ -0,0 +1,20 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __exportStar = (this && this.__exportStar) || function(m, exports) {
+    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+// HACK ensure ts-node-specific bootstrapping is executed
+require("./helpers");
+__exportStar(require("@cspotcode/ava-lib"), exports);
+//# sourceMappingURL=testlib.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/testlib.js.map b/node_modules/ts-node/dist/test/testlib.js.map
new file mode 100644
index 0000000..73dc554
--- /dev/null
+++ b/node_modules/ts-node/dist/test/testlib.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"testlib.js","sourceRoot":"","sources":["../../src/test/testlib.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,yDAAyD;AACzD,qBAAmB;AAEnB,qDAAmC","sourcesContent":["// HACK ensure ts-node-specific bootstrapping is executed\nimport './helpers';\n\nexport * from '@cspotcode/ava-lib';\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/transpile-only.spec.d.ts b/node_modules/ts-node/dist/test/transpile-only.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/transpile-only.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/transpile-only.spec.js b/node_modules/ts-node/dist/test/transpile-only.spec.js
new file mode 100644
index 0000000..57c3eb1
--- /dev/null
+++ b/node_modules/ts-node/dist/test/transpile-only.spec.js
@@ -0,0 +1,40 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const exec_1 = require("./helpers/exec");
+const helpers_1 = require("./helpers");
+const command_lines_1 = require("./helpers/command-lines");
+const paths_1 = require("./helpers/paths");
+const testlib_1 = require("./testlib");
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+const exec = (0, exec_1.createExec)({
+    cwd: paths_1.TEST_DIR,
+});
+test('should support transpile only mode', async () => {
+    const r = await exec(`${command_lines_1.CMD_TS_NODE_WITH_PROJECT_FLAG} --transpile-only -pe "x"`);
+    if (r.err === null) {
+        throw new Error('Command was expected to fail, but it succeeded.');
+    }
+    (0, testlib_1.expect)(r.err.message).toMatch('ReferenceError: x is not defined');
+});
+test('should throw error even in transpileOnly mode', async () => {
+    const r = await exec(`${command_lines_1.CMD_TS_NODE_WITH_PROJECT_FLAG} --transpile-only -pe "console."`);
+    if (r.err === null) {
+        throw new Error('Command was expected to fail, but it succeeded.');
+    }
+    (0, testlib_1.expect)(r.err.message).toMatch('error TS1003: Identifier expected');
+});
+test.suite('verbatimModuleSyntax w/transpileOnly should not raise configuration diagnostic', (test) => {
+    test.if(helpers_1.tsSupportsVerbatimModuleSyntax);
+    test('test', async (t) => {
+        // Mixing verbatimModuleSyntax w/transpileOnly
+        // https://github.com/TypeStrong/ts-node/issues/1971
+        // We should *not* get:
+        // "error TS5104: Option 'isolatedModules' is redundant and cannot be specified with option 'verbatimModuleSyntax'."
+        const service = t.context.tsNodeUnderTest.create({
+            transpileOnly: true,
+            compilerOptions: { verbatimModuleSyntax: true },
+        });
+        service.compile('const foo: string = 123', 'module.ts');
+    });
+});
+//# sourceMappingURL=transpile-only.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/transpile-only.spec.js.map b/node_modules/ts-node/dist/test/transpile-only.spec.js.map
new file mode 100644
index 0000000..8040e9e
--- /dev/null
+++ b/node_modules/ts-node/dist/test/transpile-only.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"transpile-only.spec.js","sourceRoot":"","sources":["../../src/test/transpile-only.spec.ts"],"names":[],"mappings":";;AAAA,yCAA4C;AAC5C,uCAAsE;AACtE,2DAAwE;AACxE,2CAA2C;AAC3C,uCAA4C;AAE5C,MAAM,IAAI,GAAG,IAAA,iBAAO,EAAC,mBAAS,CAAC,CAAC;AAEhC,MAAM,IAAI,GAAG,IAAA,iBAAU,EAAC;IACtB,GAAG,EAAE,gBAAQ;CACd,CAAC,CAAC;AAEH,IAAI,CAAC,oCAAoC,EAAE,KAAK,IAAI,EAAE;IACpD,MAAM,CAAC,GAAG,MAAM,IAAI,CAAC,GAAG,6CAA6B,2BAA2B,CAAC,CAAC;IAClF,IAAI,CAAC,CAAC,GAAG,KAAK,IAAI,EAAE;QAClB,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;KACpE;IAED,IAAA,gBAAM,EAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,kCAAkC,CAAC,CAAC;AACpE,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,+CAA+C,EAAE,KAAK,IAAI,EAAE;IAC/D,MAAM,CAAC,GAAG,MAAM,IAAI,CAAC,GAAG,6CAA6B,kCAAkC,CAAC,CAAC;IACzF,IAAI,CAAC,CAAC,GAAG,KAAK,IAAI,EAAE;QAClB,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;KACpE;IAED,IAAA,gBAAM,EAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,mCAAmC,CAAC,CAAC;AACrE,CAAC,CAAC,CAAC;AAEH,IAAI,CAAC,KAAK,CAAC,gFAAgF,EAAE,CAAC,IAAI,EAAE,EAAE;IACpG,IAAI,CAAC,EAAE,CAAC,wCAA8B,CAAC,CAAC;IACxC,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;QACvB,8CAA8C;QAC9C,oDAAoD;QACpD,uBAAuB;QACvB,oHAAoH;QACpH,MAAM,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC,MAAM,CAAC;YAC/C,aAAa,EAAE,IAAI;YACnB,eAAe,EAAE,EAAE,oBAAoB,EAAE,IAAI,EAAE;SAChD,CAAC,CAAC;QACH,OAAO,CAAC,OAAO,CAAC,yBAAyB,EAAE,WAAW,CAAC,CAAC;IAC1D,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["import { createExec } from './helpers/exec';\nimport { ctxTsNode, tsSupportsVerbatimModuleSyntax } from './helpers';\nimport { CMD_TS_NODE_WITH_PROJECT_FLAG } from './helpers/command-lines';\nimport { TEST_DIR } from './helpers/paths';\nimport { expect, context } from './testlib';\n\nconst test = context(ctxTsNode);\n\nconst exec = createExec({\n  cwd: TEST_DIR,\n});\n\ntest('should support transpile only mode', async () => {\n  const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --transpile-only -pe \"x\"`);\n  if (r.err === null) {\n    throw new Error('Command was expected to fail, but it succeeded.');\n  }\n\n  expect(r.err.message).toMatch('ReferenceError: x is not defined');\n});\n\ntest('should throw error even in transpileOnly mode', async () => {\n  const r = await exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --transpile-only -pe \"console.\"`);\n  if (r.err === null) {\n    throw new Error('Command was expected to fail, but it succeeded.');\n  }\n\n  expect(r.err.message).toMatch('error TS1003: Identifier expected');\n});\n\ntest.suite('verbatimModuleSyntax w/transpileOnly should not raise configuration diagnostic', (test) => {\n  test.if(tsSupportsVerbatimModuleSyntax);\n  test('test', async (t) => {\n    // Mixing verbatimModuleSyntax w/transpileOnly\n    // https://github.com/TypeStrong/ts-node/issues/1971\n    // We should *not* get:\n    // \"error TS5104: Option 'isolatedModules' is redundant and cannot be specified with option 'verbatimModuleSyntax'.\"\n    const service = t.context.tsNodeUnderTest.create({\n      transpileOnly: true,\n      compilerOptions: { verbatimModuleSyntax: true },\n    });\n    service.compile('const foo: string = 123', 'module.ts');\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/transpilers.spec.d.ts b/node_modules/ts-node/dist/test/transpilers.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/transpilers.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/transpilers.spec.js b/node_modules/ts-node/dist/test/transpilers.spec.js
new file mode 100644
index 0000000..17e672a
--- /dev/null
+++ b/node_modules/ts-node/dist/test/transpilers.spec.js
@@ -0,0 +1,118 @@
+"use strict";
+// third-party transpiler and swc transpiler tests
+// TODO: at the time of writing, other transpiler tests have not been moved into this file.
+// Should consolidate them here.
+Object.defineProperty(exports, "__esModule", { value: true });
+const testlib_1 = require("./testlib");
+const helpers_1 = require("./helpers");
+const swc_1 = require("../transpilers/swc");
+const expect = require("expect");
+const outdent_1 = require("outdent");
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+test.suite('swc', (test) => {
+    test('verify that TS->SWC target mappings suppport all possible values from both TS and SWC', async (t) => {
+        const swcTranspiler = (0, helpers_1.testsDirRequire)('ts-node/transpilers/swc-experimental');
+        // Detect when mapping is missing any ts.ScriptTargets
+        const ts = (0, helpers_1.testsDirRequire)('typescript');
+        for (const key of Object.keys(ts.ScriptTarget)) {
+            if (/^\d+$/.test(key))
+                continue;
+            if (key === 'JSON')
+                continue;
+            expect(swcTranspiler.targetMapping.has(ts.ScriptTarget[key])).toBe(true);
+        }
+        // Detect when mapping is missing any swc targets
+        // Assuming that tests/package.json declares @swc/core: latest
+        const swc = (0, helpers_1.testsDirRequire)('@swc/core');
+        let msg = undefined;
+        try {
+            swc.transformSync('', { jsc: { target: 'invalid' } });
+        }
+        catch (e) {
+            msg = e.message;
+        }
+        expect(msg).toBeDefined();
+        // Error looks like:
+        // unknown variant `invalid`, expected one of `es3`, `es5`, `es2015`, `es2016`, `es2017`, `es2018`, `es2019`, `es2020`, `es2021` at line 1 column 28
+        const match = msg.match(/unknown variant.*, expected one of (.*) at line/);
+        expect(match).toBeDefined();
+        const targets = match[1].split(', ').map((v) => v.slice(1, -1));
+        for (const target of targets) {
+            expect([...swcTranspiler.targetMapping.values()]).toContain(target);
+        }
+    });
+    test.suite('converts TS config to swc config', (test) => {
+        test.suite('jsx', (test) => {
+            const macro = test.macro((jsx, runtime, development) => [
+                () => `jsx=${jsx}`,
+                async (t) => {
+                    const tsNode = t.context.tsNodeUnderTest.create({
+                        compilerOptions: {
+                            jsx,
+                        },
+                    });
+                    const swcOptions = (0, swc_1.createSwcOptions)(tsNode.config.options, undefined, require('@swc/core'), '@swc/core');
+                    expect(swcOptions.tsxOptions.jsc?.transform?.react).toBeDefined();
+                    expect(swcOptions.tsxOptions.jsc?.transform?.react?.development).toBe(development);
+                    expect(swcOptions.tsxOptions.jsc?.transform?.react?.runtime).toBe(runtime);
+                },
+            ]);
+            test(macro, 'react', undefined, undefined);
+            test.suite('react 17 jsx factories', (test) => {
+                test.if(helpers_1.tsSupportsReact17JsxFactories);
+                test(macro, 'react-jsx', 'automatic', undefined);
+                test(macro, 'react-jsxdev', 'automatic', true);
+            });
+        });
+    });
+    const compileMacro = test.macro((compilerOptions, input, expectedOutput) => [
+        (title) => title ?? `${JSON.stringify(compilerOptions)}`,
+        async (t) => {
+            const code = t.context.tsNodeUnderTest
+                .create({
+                swc: true,
+                skipProject: true,
+                compilerOptions: {
+                    module: 'esnext',
+                    ...compilerOptions,
+                },
+            })
+                .compile(input, 'input.tsx');
+            expect(code.replace(/\/\/# sourceMappingURL.*/, '').trim()).toBe(expectedOutput);
+        },
+    ]);
+    test.suite('transforms various forms of jsx', (test) => {
+        const input = (0, outdent_1.outdent) `
+      const div = <div></div>;
+    `;
+        test(compileMacro, { jsx: 'react' }, input, `const div = /*#__PURE__*/ React.createElement("div", null);`);
+        test.suite('react 17 jsx factories', (test) => {
+            test.if(helpers_1.tsSupportsReact17JsxFactories);
+            test(compileMacro, { jsx: 'react-jsx' }, input, (0, outdent_1.outdent) `
+          import { jsx as _jsx } from "react/jsx-runtime";
+          const div = /*#__PURE__*/ _jsx("div", {});
+        `);
+            test(compileMacro, { jsx: 'react-jsxdev' }, input, (0, outdent_1.outdent) `
+          import { jsxDEV as _jsxDEV } from "react/jsx-dev-runtime";
+          const div = /*#__PURE__*/ _jsxDEV("div", {}, void 0, false, {
+              fileName: "input.tsx",
+              lineNumber: 1,
+              columnNumber: 13
+          }, this);
+        `);
+        });
+    });
+    test.suite('preserves import assertions for json imports', (test) => {
+        test.if(helpers_1.tsSupportsImportAssertions);
+        test('basic json import', compileMacro, { module: 'esnext' }, (0, outdent_1.outdent) `
+        import document from './document.json' assert {type: 'json'};
+        document;
+      `, (0, outdent_1.outdent) `
+        import document from './document.json' assert {
+            type: 'json'
+        };
+        document;
+      `);
+    });
+});
+//# sourceMappingURL=transpilers.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/transpilers.spec.js.map b/node_modules/ts-node/dist/test/transpilers.spec.js.map
new file mode 100644
index 0000000..cce91f4
--- /dev/null
+++ b/node_modules/ts-node/dist/test/transpilers.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"transpilers.spec.js","sourceRoot":"","sources":["../../src/test/transpilers.spec.ts"],"names":[],"mappings":"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","sourcesContent":["// third-party transpiler and swc transpiler tests\n// TODO: at the time of writing, other transpiler tests have not been moved into this file.\n// Should consolidate them here.\n\nimport { context } from './testlib';\nimport { ctxTsNode, testsDirRequire, tsSupportsImportAssertions, tsSupportsReact17JsxFactories } from './helpers';\nimport { createSwcOptions } from '../transpilers/swc';\nimport * as expect from 'expect';\nimport { outdent } from 'outdent';\n\nconst test = context(ctxTsNode);\n\ntest.suite('swc', (test) => {\n  test('verify that TS->SWC target mappings suppport all possible values from both TS and SWC', async (t) => {\n    const swcTranspiler = testsDirRequire(\n      'ts-node/transpilers/swc-experimental'\n    ) as typeof import('../transpilers/swc');\n\n    // Detect when mapping is missing any ts.ScriptTargets\n    const ts = testsDirRequire('typescript') as typeof import('typescript');\n    for (const key of Object.keys(ts.ScriptTarget)) {\n      if (/^\\d+$/.test(key)) continue;\n      if (key === 'JSON') continue;\n      expect(swcTranspiler.targetMapping.has(ts.ScriptTarget[key as any] as any)).toBe(true);\n    }\n\n    // Detect when mapping is missing any swc targets\n    // Assuming that tests/package.json declares @swc/core: latest\n    const swc = testsDirRequire('@swc/core');\n    let msg: string | undefined = undefined;\n    try {\n      swc.transformSync('', { jsc: { target: 'invalid' } });\n    } catch (e) {\n      msg = (e as Error).message;\n    }\n    expect(msg).toBeDefined();\n    // Error looks like:\n    // unknown variant `invalid`, expected one of `es3`, `es5`, `es2015`, `es2016`, `es2017`, `es2018`, `es2019`, `es2020`, `es2021` at line 1 column 28\n    const match = msg!.match(/unknown variant.*, expected one of (.*) at line/);\n    expect(match).toBeDefined();\n    const targets = match![1].split(', ').map((v: string) => v.slice(1, -1));\n\n    for (const target of targets) {\n      expect([...swcTranspiler.targetMapping.values()]).toContain(target);\n    }\n  });\n\n  test.suite('converts TS config to swc config', (test) => {\n    test.suite('jsx', (test) => {\n      const macro = test.macro((jsx: string, runtime?: string, development?: boolean) => [\n        () => `jsx=${jsx}`,\n        async (t) => {\n          const tsNode = t.context.tsNodeUnderTest.create({\n            compilerOptions: {\n              jsx,\n            },\n          });\n          const swcOptions = createSwcOptions(tsNode.config.options, undefined, require('@swc/core'), '@swc/core');\n          expect(swcOptions.tsxOptions.jsc?.transform?.react).toBeDefined();\n          expect(swcOptions.tsxOptions.jsc?.transform?.react?.development).toBe(development);\n          expect(swcOptions.tsxOptions.jsc?.transform?.react?.runtime).toBe(runtime);\n        },\n      ]);\n\n      test(macro, 'react', undefined, undefined);\n      test.suite('react 17 jsx factories', (test) => {\n        test.if(tsSupportsReact17JsxFactories);\n        test(macro, 'react-jsx', 'automatic', undefined);\n        test(macro, 'react-jsxdev', 'automatic', true);\n      });\n    });\n  });\n\n  const compileMacro = test.macro((compilerOptions: object, input: string, expectedOutput: string) => [\n    (title?: string) => title ?? `${JSON.stringify(compilerOptions)}`,\n    async (t) => {\n      const code = t.context.tsNodeUnderTest\n        .create({\n          swc: true,\n          skipProject: true,\n          compilerOptions: {\n            module: 'esnext',\n            ...compilerOptions,\n          },\n        })\n        .compile(input, 'input.tsx');\n      expect(code.replace(/\\/\\/# sourceMappingURL.*/, '').trim()).toBe(expectedOutput);\n    },\n  ]);\n\n  test.suite('transforms various forms of jsx', (test) => {\n    const input = outdent`\n      const div = <div></div>;\n    `;\n\n    test(compileMacro, { jsx: 'react' }, input, `const div = /*#__PURE__*/ React.createElement(\"div\", null);`);\n    test.suite('react 17 jsx factories', (test) => {\n      test.if(tsSupportsReact17JsxFactories);\n      test(\n        compileMacro,\n        { jsx: 'react-jsx' },\n        input,\n        outdent`\n          import { jsx as _jsx } from \"react/jsx-runtime\";\n          const div = /*#__PURE__*/ _jsx(\"div\", {});\n        `\n      );\n      test(\n        compileMacro,\n        { jsx: 'react-jsxdev' },\n        input,\n        outdent`\n          import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n          const div = /*#__PURE__*/ _jsxDEV(\"div\", {}, void 0, false, {\n              fileName: \"input.tsx\",\n              lineNumber: 1,\n              columnNumber: 13\n          }, this);\n        `\n      );\n    });\n  });\n\n  test.suite('preserves import assertions for json imports', (test) => {\n    test.if(tsSupportsImportAssertions);\n    test(\n      'basic json import',\n      compileMacro,\n      { module: 'esnext' },\n      outdent`\n        import document from './document.json' assert {type: 'json'};\n        document;\n      `,\n      outdent`\n        import document from './document.json' assert {\n            type: 'json'\n        };\n        document;\n      `\n    );\n  });\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/ts-import-specifiers.spec.d.ts b/node_modules/ts-node/dist/test/ts-import-specifiers.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/ts-import-specifiers.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/ts-import-specifiers.spec.js b/node_modules/ts-node/dist/test/ts-import-specifiers.spec.js
new file mode 100644
index 0000000..beea7f0
--- /dev/null
+++ b/node_modules/ts-node/dist/test/ts-import-specifiers.spec.js
@@ -0,0 +1,45 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const testlib_1 = require("./testlib");
+const expect = require("expect");
+const exec_1 = require("./helpers/exec");
+const helpers_1 = require("./helpers");
+const fs_fixture_builder_1 = require("@TypeStrong/fs-fixture-builder");
+const outdent_1 = require("outdent");
+const exec = (0, exec_1.createExec)({
+    cwd: helpers_1.TEST_DIR,
+});
+const test = (0, testlib_1.context)(helpers_1.ctxTsNode);
+test('Supports .ts extensions in import specifiers with typechecking, even though older versions of TS checker do not', async () => {
+    const p = (0, fs_fixture_builder_1.project)('ts-import-specifiers');
+    p.rm();
+    p.addFile('index.ts', (0, outdent_1.outdent) `
+    import { foo } from './foo.ts';
+    import { bar } from './bar.jsx';
+    console.log({ foo, bar });
+  `);
+    p.addFile('foo.ts', (0, outdent_1.outdent) `
+    export const foo = true;
+  `);
+    p.addFile('bar.tsx', (0, outdent_1.outdent) `
+    export const bar = true;
+  `);
+    p.addJsonFile('tsconfig.json', {
+        'ts-node': {
+            // Can eventually make this a stable feature.  For now, `experimental` flag allows me to iterate quickly
+            experimentalTsImportSpecifiers: true,
+            experimentalResolver: true,
+        },
+        compilerOptions: {
+            jsx: 'react',
+            allowImportingTsExtensions: helpers_1.tsSupportsAllowImportingTsExtensions ? true : undefined,
+        },
+    });
+    p.write();
+    const r = await exec(`${helpers_1.CMD_TS_NODE_WITHOUT_PROJECT_FLAG} ./index.ts`, {
+        cwd: p.cwd,
+    });
+    expect(r.err).toBe(null);
+    expect(r.stdout.trim()).toBe('{ foo: true, bar: true }');
+});
+//# sourceMappingURL=ts-import-specifiers.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/ts-import-specifiers.spec.js.map b/node_modules/ts-node/dist/test/ts-import-specifiers.spec.js.map
new file mode 100644
index 0000000..45a6c9c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/ts-import-specifiers.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ts-import-specifiers.spec.js","sourceRoot":"","sources":["../../src/test/ts-import-specifiers.spec.ts"],"names":[],"mappings":";;AAAA,uCAAoC;AACpC,iCAAiC;AACjC,yCAA4C;AAC5C,uCAAwH;AACxH,uEAAsE;AACtE,qCAAuC;AAEvC,MAAM,IAAI,GAAG,IAAA,iBAAU,EAAC;IACtB,GAAG,EAAE,kBAAQ;CACd,CAAC,CAAC;AAEH,MAAM,IAAI,GAAG,IAAA,iBAAO,EAAC,mBAAS,CAAC,CAAC;AAEhC,IAAI,CAAC,iHAAiH,EAAE,KAAK,IAAI,EAAE;IACjI,MAAM,CAAC,GAAG,IAAA,4BAAS,EAAC,sBAAsB,CAAC,CAAC;IAC5C,CAAC,CAAC,EAAE,EAAE,CAAC;IACP,CAAC,CAAC,OAAO,CACP,UAAU,EACV,IAAA,iBAAC,EAAA;;;;GAIF,CACA,CAAC;IACF,CAAC,CAAC,OAAO,CACP,QAAQ,EACR,IAAA,iBAAC,EAAA;;GAEF,CACA,CAAC;IACF,CAAC,CAAC,OAAO,CACP,SAAS,EACT,IAAA,iBAAC,EAAA;;GAEF,CACA,CAAC;IACF,CAAC,CAAC,WAAW,CAAC,eAAe,EAAE;QAC7B,SAAS,EAAE;YACT,wGAAwG;YACxG,8BAA8B,EAAE,IAAI;YACpC,oBAAoB,EAAE,IAAI;SAC3B;QACD,eAAe,EAAE;YACf,GAAG,EAAE,OAAO;YACZ,0BAA0B,EAAE,8CAAoC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS;SACpF;KACF,CAAC,CAAC;IACH,CAAC,CAAC,KAAK,EAAE,CAAC;IAEV,MAAM,CAAC,GAAG,MAAM,IAAI,CAAC,GAAG,0CAAgC,aAAa,EAAE;QACrE,GAAG,EAAE,CAAC,CAAC,GAAG;KACX,CAAC,CAAC;IACH,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC;AAC3D,CAAC,CAAC,CAAC","sourcesContent":["import { context } from './testlib';\nimport * as expect from 'expect';\nimport { createExec } from './helpers/exec';\nimport { TEST_DIR, ctxTsNode, CMD_TS_NODE_WITHOUT_PROJECT_FLAG, tsSupportsAllowImportingTsExtensions } from './helpers';\nimport { project as fsProject } from '@TypeStrong/fs-fixture-builder';\nimport { outdent as o } from 'outdent';\n\nconst exec = createExec({\n  cwd: TEST_DIR,\n});\n\nconst test = context(ctxTsNode);\n\ntest('Supports .ts extensions in import specifiers with typechecking, even though older versions of TS checker do not', async () => {\n  const p = fsProject('ts-import-specifiers');\n  p.rm();\n  p.addFile(\n    'index.ts',\n    o`\n    import { foo } from './foo.ts';\n    import { bar } from './bar.jsx';\n    console.log({ foo, bar });\n  `\n  );\n  p.addFile(\n    'foo.ts',\n    o`\n    export const foo = true;\n  `\n  );\n  p.addFile(\n    'bar.tsx',\n    o`\n    export const bar = true;\n  `\n  );\n  p.addJsonFile('tsconfig.json', {\n    'ts-node': {\n      // Can eventually make this a stable feature.  For now, `experimental` flag allows me to iterate quickly\n      experimentalTsImportSpecifiers: true,\n      experimentalResolver: true,\n    },\n    compilerOptions: {\n      jsx: 'react',\n      allowImportingTsExtensions: tsSupportsAllowImportingTsExtensions ? true : undefined,\n    },\n  });\n  p.write();\n\n  const r = await exec(`${CMD_TS_NODE_WITHOUT_PROJECT_FLAG} ./index.ts`, {\n    cwd: p.cwd,\n  });\n  expect(r.err).toBe(null);\n  expect(r.stdout.trim()).toBe('{ foo: true, bar: true }');\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/tsconfig-bases.spec.d.ts b/node_modules/ts-node/dist/test/tsconfig-bases.spec.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/ts-node/dist/test/tsconfig-bases.spec.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/ts-node/dist/test/tsconfig-bases.spec.js b/node_modules/ts-node/dist/test/tsconfig-bases.spec.js
new file mode 100644
index 0000000..9a6a8ce
--- /dev/null
+++ b/node_modules/ts-node/dist/test/tsconfig-bases.spec.js
@@ -0,0 +1,83 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const path_1 = require("path");
+const exec_1 = require("./helpers/exec");
+const ctx_tmp_dir_1 = require("./helpers/ctx-tmp-dir");
+const ctx_ts_node_1 = require("./helpers/ctx-ts-node");
+const paths_1 = require("./helpers/paths");
+const version_checks_1 = require("./helpers/version-checks");
+const testlib_1 = require("./testlib");
+const semver = require("semver");
+const helpers_1 = require("./helpers");
+const exec = (0, exec_1.createExec)({
+    cwd: paths_1.TEST_DIR,
+});
+const test = (0, testlib_1.context)(ctx_ts_node_1.ctxTsNode);
+test.suite('should use implicit @tsconfig/bases config when one is not loaded from disk', ({ contextEach }) => {
+    const test = contextEach(ctx_tmp_dir_1.ctxTmpDirOutsideCheckout);
+    let lib = 'es2020';
+    let target = 'es2020';
+    if (semver.gte(process.versions.node, '16.0.0') && version_checks_1.tsSupportsEs2021) {
+        lib = target = 'es2021';
+    }
+    if (semver.gte(process.versions.node, '18.0.0') && version_checks_1.tsSupportsEs2022 && version_checks_1.tsSupportsLibEs2023) {
+        target = 'es2022';
+        lib = 'es2023';
+    }
+    test('implicitly uses @tsconfig/node14, @tsconfig/node16, or @tsconfig/node18 compilerOptions when both TS and node versions support it', async (t) => {
+        const r1 = await exec(`${paths_1.BIN_PATH} --showConfig`, {
+            cwd: t.context.tmpDir,
+        });
+        (0, testlib_1.expect)(r1.err).toBe(null);
+        t.like(JSON.parse(r1.stdout), {
+            compilerOptions: {
+                target,
+                lib: [lib],
+            },
+        });
+        const r2 = await exec(`${paths_1.BIN_PATH} -pe 10n`, {
+            cwd: t.context.tmpDir,
+        });
+        (0, testlib_1.expect)(r2.err).toBe(null);
+        (0, testlib_1.expect)(r2.stdout).toBe('10n\n');
+    });
+    test('implicitly loads @types/node even when not installed within local directory', async (t) => {
+        const r = await exec(`${paths_1.BIN_PATH} -pe process.env.foo`, {
+            cwd: t.context.tmpDir,
+            env: { ...process.env, foo: 'hello world' },
+        });
+        (0, testlib_1.expect)(r.err).toBe(null);
+        (0, testlib_1.expect)(r.stdout).toBe('hello world\n');
+    });
+    test('implicitly loads local @types/node', async (t) => {
+        t.context.fixture.readFrom((0, path_1.join)(paths_1.TEST_DIR, 'local-types-node'), undefined, []);
+        t.context.fixture.write();
+        const r = await exec(`${paths_1.BIN_PATH} -pe process.env.foo`, {
+            cwd: t.context.fixture.cwd,
+            env: { ...process.env, foo: 'hello world' },
+        });
+        (0, testlib_1.expect)(r.err).not.toBe(null);
+        (0, testlib_1.expect)(r.stderr).toMatch("Property 'env' does not exist on type 'LocalNodeTypes_Process'");
+    });
+});
+test.suite('should bundle @tsconfig/bases to be used in your own tsconfigs', (test) => {
+    // Older TS versions will complain about newer `target` and `lib` options
+    test.if(version_checks_1.tsSupportsEs2022 && version_checks_1.tsSupportsLibEs2023);
+    const macro = test.macro((nodeVersion) => async (t) => {
+        const config = (0, helpers_1.testsDirRequire)(`@tsconfig/${nodeVersion}/tsconfig.json`);
+        const r = await exec(`${paths_1.BIN_PATH} --showConfig -e 10n`, {
+            cwd: (0, path_1.join)(paths_1.TEST_DIR, 'tsconfig-bases', nodeVersion),
+        });
+        (0, testlib_1.expect)(r.err).toBe(null);
+        t.like(JSON.parse(r.stdout), {
+            compilerOptions: {
+                target: config.compilerOptions.target,
+                lib: config.compilerOptions.lib,
+            },
+        });
+    });
+    test(`ts-node/node14/tsconfig.json`, macro, 'node14');
+    test(`ts-node/node16/tsconfig.json`, macro, 'node16');
+    test(`ts-node/node18/tsconfig.json`, macro, 'node18');
+});
+//# sourceMappingURL=tsconfig-bases.spec.js.map
\ No newline at end of file
diff --git a/node_modules/ts-node/dist/test/tsconfig-bases.spec.js.map b/node_modules/ts-node/dist/test/tsconfig-bases.spec.js.map
new file mode 100644
index 0000000..d0e48ea
--- /dev/null
+++ b/node_modules/ts-node/dist/test/tsconfig-bases.spec.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"tsconfig-bases.spec.js","sourceRoot":"","sources":["../../src/test/tsconfig-bases.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { join } from 'path';\nimport { createExec } from './helpers/exec';\nimport { ctxTmpDirOutsideCheckout } from './helpers/ctx-tmp-dir';\nimport { ctxTsNode } from './helpers/ctx-ts-node';\nimport { BIN_PATH, TEST_DIR } from './helpers/paths';\nimport { tsSupportsEs2021, tsSupportsEs2022, tsSupportsLibEs2023 } from './helpers/version-checks';\nimport { context, expect } from './testlib';\nimport semver = require('semver');\nimport { testsDirRequire } from './helpers';\n\nconst exec = createExec({\n  cwd: TEST_DIR,\n});\n\nconst test = context(ctxTsNode);\n\ntest.suite('should use implicit @tsconfig/bases config when one is not loaded from disk', ({ contextEach }) => {\n  const test = contextEach(ctxTmpDirOutsideCheckout);\n\n  let lib = 'es2020';\n  let target = 'es2020';\n  if (semver.gte(process.versions.node, '16.0.0') && tsSupportsEs2021) {\n    lib = target = 'es2021';\n  }\n  if (semver.gte(process.versions.node, '18.0.0') && tsSupportsEs2022 && tsSupportsLibEs2023) {\n    target = 'es2022';\n    lib = 'es2023';\n  }\n\n  test('implicitly uses @tsconfig/node14, @tsconfig/node16, or @tsconfig/node18 compilerOptions when both TS and node versions support it', async (t) => {\n    const r1 = await exec(`${BIN_PATH} --showConfig`, {\n      cwd: t.context.tmpDir,\n    });\n\n    expect(r1.err).toBe(null);\n    t.like(JSON.parse(r1.stdout), {\n      compilerOptions: {\n        target,\n        lib: [lib],\n      },\n    });\n\n    const r2 = await exec(`${BIN_PATH} -pe 10n`, {\n      cwd: t.context.tmpDir,\n    });\n\n    expect(r2.err).toBe(null);\n    expect(r2.stdout).toBe('10n\\n');\n  });\n\n  test('implicitly loads @types/node even when not installed within local directory', async (t) => {\n    const r = await exec(`${BIN_PATH} -pe process.env.foo`, {\n      cwd: t.context.tmpDir,\n      env: { ...process.env, foo: 'hello world' },\n    });\n\n    expect(r.err).toBe(null);\n    expect(r.stdout).toBe('hello world\\n');\n  });\n\n  test('implicitly loads local @types/node', async (t) => {\n    t.context.fixture.readFrom(join(TEST_DIR, 'local-types-node'), undefined, []);\n    t.context.fixture.write();\n\n    const r = await exec(`${BIN_PATH} -pe process.env.foo`, {\n      cwd: t.context.fixture.cwd,\n      env: { ...process.env, foo: 'hello world' },\n    });\n\n    expect(r.err).not.toBe(null);\n    expect(r.stderr).toMatch(\"Property 'env' does not exist on type 'LocalNodeTypes_Process'\");\n  });\n});\n\ntest.suite('should bundle @tsconfig/bases to be used in your own tsconfigs', (test) => {\n  // Older TS versions will complain about newer `target` and `lib` options\n  test.if(tsSupportsEs2022 && tsSupportsLibEs2023);\n\n  const macro = test.macro((nodeVersion: string) => async (t) => {\n    const config = testsDirRequire(`@tsconfig/${nodeVersion}/tsconfig.json`);\n    const r = await exec(`${BIN_PATH} --showConfig -e 10n`, {\n      cwd: join(TEST_DIR, 'tsconfig-bases', nodeVersion),\n    });\n\n    expect(r.err).toBe(null);\n    t.like(JSON.parse(r.stdout), {\n      compilerOptions: {\n        target: config.compilerOptions.target,\n        lib: config.compilerOptions.lib,\n      },\n    });\n  });\n\n  test(`ts-node/node14/tsconfig.json`, macro, 'node14');\n  test(`ts-node/node16/tsconfig.json`, macro, 'node16');\n  test(`ts-node/node18/tsconfig.json`, macro, 'node18');\n});\n"]}
\ No newline at end of file
